{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///tick42-glue-core.min.js","webpack:///webpack/bootstrap 8cb2f5747093b3860f93","webpack:///./src_js/metrics/core/const/metric-types.js","webpack:///./~/callback-registry/lib/index.js","webpack:///./src_js/metrics/helpers.js","webpack:///external \"util\"","webpack:///./src_js/agm/helpers/random.js","webpack:///./~/shortid/lib/alphabet.js","webpack:///./~/ws/lib/PerMessageDeflate.js","webpack:///./src_js/agm/protocols/gw1/helpers.js","webpack:///external \"events\"","webpack:///./~/shortid/index.js","webpack:///./src_js/agm/helpers/promisify.js","webpack:///./src_js/agm/server/subscription.js","webpack:///./src_js/contexts/contextMessageReplaySpec.js","webpack:///./src_js/utils.js","webpack:///external \"crypto\"","webpack:///./package.json","webpack:///./~/options/lib/options.js","webpack:///./~/ws/lib/BufferUtil.js","webpack:///./~/ws/lib/ErrorCodes.js","webpack:///./~/ws/lib/Extensions.js","webpack:///./~/ws/lib/Receiver.js","webpack:///./~/ws/lib/Sender.js","webpack:///./~/ws/lib/WebSocket.js","webpack:///./src_js/connection/connection.js","webpack:///./src_js/contexts/bridges/gw3/gw3Messages.js","webpack:///./src_js/dummyConnection.js","webpack:///external \"http\"","webpack:///external \"url\"","webpack:///./src_js/glue.js","webpack:///./~/nanoid/format.js","webpack:///./~/nanoid/random.js","webpack:///./~/shortid/lib/build.js","webpack:///./~/shortid/lib/generate.js","webpack:///./~/shortid/lib/index.js","webpack:///./~/shortid/lib/is-valid.js","webpack:///./~/shortid/lib/random/random-byte.js","webpack:///./~/shortid/lib/random/random-from-seed.js","webpack:///./~/shortid/lib/util/cluster-worker-id.js","webpack:///./~/ultron/index.js","webpack:///./~/ws/index.js","webpack:///./~/ws/lib/BufferPool.js","webpack:///./~/ws/lib/BufferUtil.fallback.js","webpack:///./~/ws/lib/Receiver.hixie.js","webpack:///./~/ws/lib/Sender.hixie.js","webpack:///./~/ws/lib/Validation.fallback.js","webpack:///./~/ws/lib/Validation.js","webpack:///./~/ws/lib/WebSocketServer.js","webpack:///./src_js/agm/agm.js","webpack:///./src_js/agm/client/client.js","webpack:///./src_js/agm/client/invoke.js","webpack:///./src_js/agm/client/repository.js","webpack:///./src_js/agm/hc/agm.js","webpack:///./src_js/agm/hc/helpers.js","webpack:///./src_js/agm/hc/native.js","webpack:///./src_js/agm/instance.js","webpack:///./src_js/agm/main.js","webpack:///./src_js/agm/protocols/gw1/client-streaming.js","webpack:///./src_js/agm/protocols/gw1/client.js","webpack:///./src_js/agm/protocols/gw1/factory.js","webpack:///./src_js/agm/protocols/gw1/server-streaming.js","webpack:///./src_js/agm/protocols/gw1/server.js","webpack:///./src_js/agm/protocols/gw3/client-streaming.js","webpack:///./src_js/agm/protocols/gw3/client.js","webpack:///./src_js/agm/protocols/gw3/factory.js","webpack:///./src_js/agm/protocols/gw3/server-streaming.js","webpack:///./src_js/agm/protocols/gw3/server.js","webpack:///./src_js/agm/server/branch.js","webpack:///./src_js/agm/server/repository.js","webpack:///./src_js/agm/server/request.js","webpack:///./src_js/agm/server/server.js","webpack:///./src_js/agm/server/stream.js","webpack:///./src_js/agm/server/streaming.js","webpack:///./src_js/bus/main.js","webpack:///./src_js/bus/protocol.js","webpack:///./src_js/bus/utils.js","webpack:///./src_js/config.js","webpack:///./src_js/connection/gw3Connection.js","webpack:///./src_js/connection/main.js","webpack:///./src_js/connection/messageReplayer.js","webpack:///./src_js/connection/protocols/gw1.js","webpack:///./src_js/connection/protocols/gw3.js","webpack:///./src_js/connection/protocols/gw3Domain.js","webpack:///./src_js/connection/protocols/hc.js","webpack:///./src_js/connection/transports/hc.js","webpack:///./src_js/connection/transports/inproc.js","webpack:///./src_js/connection/transports/ws.js","webpack:///./src_js/contexts/bridges/gw3/gw3Bridge.js","webpack:///./src_js/contexts/bridges/gw3/gw3ContextData.js","webpack:///./src_js/contexts/bridges/hcBridge.js","webpack:///./src_js/contexts/contextsModule.js","webpack:///./src_js/contexts/helpers.js","webpack:///./src_js/contexts/main.js","webpack:///./src_js/logger/levels.js","webpack:///./src_js/logger/logger.js","webpack:///./src_js/logger/main.js","webpack:///./src_js/main.js","webpack:///./src_js/metrics/core/metrics/address.js","webpack:///./src_js/metrics/core/metrics/count.js","webpack:///./src_js/metrics/core/metrics/number.js","webpack:///./src_js/metrics/core/metrics/object.js","webpack:///./src_js/metrics/core/metrics/rate.js","webpack:///./src_js/metrics/core/metrics/statistics.js","webpack:///./src_js/metrics/core/metrics/string.js","webpack:///./src_js/metrics/core/metrics/timespan.js","webpack:///./src_js/metrics/core/metrics/timestamp.js","webpack:///./src_js/metrics/core/protocols/gw1/gw1.js","webpack:///./src_js/metrics/core/protocols/gw1/serializer.js","webpack:///./src_js/metrics/core/protocols/gw3/gw3.js","webpack:///./src_js/metrics/core/protocols/gw3/serializer.js","webpack:///./src_js/metrics/main.js","webpack:///./src_js/metrics/repository.js","webpack:///./src_js/metrics/system.js","webpack:///./src_js/timer.js","webpack:///external \"cluster\"","webpack:///external \"fs\"","webpack:///external \"https\"","webpack:///external \"stream\"","webpack:///external \"tls\"","webpack:///external \"zlib\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_8__","__WEBPACK_EXTERNAL_MODULE_14__","__WEBPACK_EXTERNAL_MODULE_26__","__WEBPACK_EXTERNAL_MODULE_27__","__WEBPACK_EXTERNAL_MODULE_113__","__WEBPACK_EXTERNAL_MODULE_114__","__WEBPACK_EXTERNAL_MODULE_115__","__WEBPACK_EXTERNAL_MODULE_116__","__WEBPACK_EXTERNAL_MODULE_117__","__WEBPACK_EXTERNAL_MODULE_118__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","DEFAULT","STRING","NUMBER","COUNT","RATE","STATISTICS","TIMESTAMP","ADDRESS","TIMESPAN","OBJECT","createRegistry","options","add","key","callback","callbacksForKey","callbacks","push","allForKey","reduce","acc","element","index","length","execute","argumentsArr","_i","arguments","results","forEach","result","apply","undefined","err","_handleError","exceptionArtifact","errParam","Error","_userErrorHandler","msg","stack","errorHandling","console","error","clear","validate","definition","parent","transport","shortid","reset","shuffled","setCharacters","_alphabet_","alphabet","ORIGINAL","unique","split","filter","item","ind","arr","lastIndexOf","join","characters","setSeed","seed","randomFromSeed","previousSeed","shuffle","characterIndex","sourceArray","targetArray","r","nextValue","Math","floor","splice","getShuffled","lookup","PerMessageDeflate","isServer","_options","_isServer","_inflate","_deflate","params","zlib","AVAILABLE_WINDOW_BITS","extensionName","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","paramsList","normalizeParams","acceptAsServer","acceptAsClient","accepted","some","map","keys","parseInt","indexOf","decompress","data","fin","onError","cleanup","onData","buffers","self","removeListener","endpoint","maxWindowBits","createInflateRaw","windowBits","on","write","Buffer","flush","concat","compress","createDeflateRaw","Z_SYNC_FLUSH","memLevel","slice","convertInfoToInstance","info","application","ApplicationName","environment","Environment","machine","MachineName","pid","ProcessId","region","Region","service","ServiceName","user","UserName","started","ProcessStartTime","isStreamingFlagSet","flags","isNaN","convertInstance","instance","default_1","promise","successCallback","errorCallback","then","ServerSubscription","protocol","repoMethod","subscription","stream","branchKey","close","server","closeSingleSubscription","pushDataToSingle","ContextMessageReplaySpec","types","GW_MESSAGE_CREATE_CONTEXT","GW_MESSAGE_ACTIVITY_CREATED","GW_MESSAGE_ACTIVITY_DESTROYED","GW_MESSAGE_CONTEXT_CREATED","GW_MESSAGE_CONTEXT_ADDED","GW_MESSAGE_SUBSCRIBE_CONTEXT","GW_MESSAGE_SUBSCRIBED_CONTEXT","GW_MESSAGE_UNSUBSCRIBE_CONTEXT","GW_MESSAGE_DESTROY_CONTEXT","GW_MESSAGE_CONTEXT_DESTROYED","GW_MESSAGE_UPDATE_CONTEXT","GW_MESSAGE_CONTEXT_UPDATED","GW_MESSAGE_JOINED_ACTIVITY","Utils","getGDMajorVersion","window","glueDesktop","version","ver","Number","substr","isNode","toString","global","process","e","description","main","browser","scripts","init-dev-mode","remove-installed-dependencies","clean","pre:build","file-versionify","tslint","tslint:fix","watch","build:dev","build:prod","docs","prepublish","test","test:only","test:core","test:agm","test:bus","repository","type","url","author","license","dependencies","callback-registry","es6-promise","util-deprecate","ws","devDependencies","@types/node","@types/shortid","archiver","babel-core","babel-loader","babel-plugin-add-module-exports","babel-preset-es2015","babel-preset-stage-2","chai","deep-equal","mocha","onchange","pre-commit","readline-sync","shelljs","tick42-gateway","tick42-webpack-config","typescript","webpack","Options","defaults","internalValues","values","merge","required","missing","copy","obj","read","filename","cb","fs","readFile","conf","JSON","parse","readFileSync","isDefined","isDefinedAndNonNull","freeze","code","isValidErrorCode","1000","1001","1002","1003","1004","1005","1006","1007","1008","1009","1010","1011","extensions","v","token","shift","trim","parsedParams","param","parts","format","util","isArray","k","Receiver","fragmentedPoolPrevUsed","fragmentedBufferPool","BufferPool","db","used","unfragmentedPoolPrevUsed","unfragmentedBufferPool","state","activeFragmentedOperation","lastFragment","masked","opcode","fragmentedOperation","overflow","headerBuffer","expectOffset","expectBuffer","expectHandler","currentMessage","messageHandlers","expectHeader","processPacket","dead","processing","onerror","ontext","onbinary","onclose","onping","onpong","readUInt16BE","start","readUInt32BE","fastCopy","srcBuffer","dstBuffer","dstOffset","clone","cloned","Validation","ErrorCodes","bufferUtil","BufferUtil","dataLength","toRead","min","bufferForHandler","handler","fromOverflow","pop","expectData","allocateFromPool","isFragmented","compressed","opcodes","endPacket","unmask","mask","buf","binary","concatBuffers","mergedBuffer","reason","protocolErrorCode","applyExtensions","messageBuffer","buffer","1","firstLength","getData","finish","packet","message","isValidUTF8","2","8","9","10","Sender","socket","events","EventEmitter","_socket","firstFragment","writeUInt16BE","offset","writeUInt32BE","getArrayBuffer","array","Uint8Array","byteLength","byteOffset","getRandomMask","random","inherits","dataBuffer","frameAndSend","ping","pong","send","finalFragment","compressFragment","emit","maskData","canModifyData","isBuffer","dataOffset","secondByte","mergeBuffers","totalLength","outputBuffer","_randomMask","WebSocket","address","protocols","Array","_ultron","_closeReceived","bytesReceived","readyState","supports","initAsServerClient","initAsClient","MessageEvent","dataArg","typeArg","target","CloseEvent","wasClean","OpenEvent","req","upgradeHead","protocolVersion","upgradeReq","CONNECTING","establishConnection","ReceiverHixie","SenderHixie","origin","host","headers","agent","pfx","passphrase","cert","ca","ciphers","rejectUnauthorized","perMessageDeflate","serverUrl","isUnixSocket","isSecure","httpObj","https","http","port","auth","extensionsOffer","Date","now","shasum","crypto","createHash","update","expectedServerKey","digest","headerHost","hostname","requestOptions","Connection","Upgrade","Host","Sec-WebSocket-Version","Sec-WebSocket-Key","Authorization","header","Extensions","Agent","path","socketPath","pathname","Origin","request","cleanupWebsocketResources","once","res","statusCode","abort","CLOSED","removeAllListeners","end","serverKey","serverProt","protList","protError","serverExtensions","ReceiverClass","SenderClass","firstHandler","OPEN","CLOSING","head","_receiver","dataHandler","realHandler","ultron","Ultron","setTimeout","setNoDelay","bind","nextTick","errorCode","_sender","startQueue","_queue","executeQueueSends","queue","sendStream","emitClose","clearTimeout","_closeTimer","_closeCode","_closeMessage","destroy","terminate","pause","dontFailWhenClosed","resume","ArrayBuffer","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","readable","Readable","Stream","final","amount","bufferSize","method","listener","listeners","_listener","set","addEventListener","onMessage","onClose","event","onOpen","callback_registry_1","ConnectionImpl","settings","ids","registry","_connected","_settings","_logger","logger","init","_protocol","_transport","onConnectedChanged","handleConnectionChanged","handleTransportMessage","product","id","isObjectBasedTransport","createObjectMessage","sendObject","strMessage","createStringMessage","messageHandler","toLowerCase","off","connected","disconnected","login","authRequest","open","logout","loggedIn","toAPI","that","distributeMessage","_this","handlers","handlerId","msgObj","processStringMessage","processObjectMessage","msgType","connection","Promise","resolve","main_1","main_2","main_3","main_4","main_5","config_1","dummyConnection_1","timer_1","utils_1","dummyConnection_2","main_6","contextMessageReplaySpec_1","GlueCore","userConfig","ext","registerLib","inner","t","initStartTime","startTime","ready","initTime","stop","initEndTime","endTime","libs","setupConnection","initTimer","internalConfig","subLogger","_connection","authPromise","reject","glue42gd","getGWToken","gatewayToken","authConfig","stringify","identity","agm","setupMetrics","metrics","_rootMetrics","_metrics","subSystem","_featureMetric_1","reportingSystem_1","def_1","conflation","featureMetric","action","payload","objectMetric","metricsLevel","setupAGM","agmConfig","forceGW","force","gdVersion","agmLib","_agm","setupContexts","hasActivities","activities","contexts","_contexts","ContextsModule","gdMajorVersion","replayer","drain","setupExternalLibs","externalLibs","lib","setupExternalLib","create","createCallback","waitForLibs","libsReadyPromises","all","constructGlueObject","feedbackFunc","invoke","glueVersion","glueInitTimer","glue","feedback","done","performance","timing","toJSON","memory","initTimes","time","period","hc","perfDataNeeded","updatePerfData","delay","perfDataDelay","config","enrichGlue","extOptions","setupBus","bus","busSettings","busLib","_bus","htmlContainer","loggerConfig","getConnection","publish","setupLogger","size","log","LN2","step","ceil","bytes","byte","randomFillSync","allocUnsafe","randomBytes","build","clusterWorkerId","str","seconds","REDUCE_TIME","previousSeconds","counter","generate","number","loopCounter","pow","seedValue","worker","workerId","newCharacters","isValid","isShortId","RegExp","replace","getNextValue","_seed_","cluster","clusterId","isMaster","NODE_ENV","NODE_UNIQUE_ID","ee","has","fn","context","__ultron","remove","args","_events","j","WS","Server","createServer","connect","createConnection","client","initialSize","growStrategy","shrinkStrategy","_growStrategy","_shrinkStrategy","_buffer","_offset","_used","_changeFactor","__defineGetter__","newBuf","forceNewBuffer","len","source","output","maskNum","readUInt32LE","num","writeUInt32LE","EMPTY","messageEnd","spanLength","bufferIndex","BODY","BINARYLENGTH","BINARYBODY","dataleft","outputIndex","bi","bl","lastBuffer","tail","continuationFrame","isClosed","isString","lengthbytes","writeStartMarker","writeEndMarker","String","fromCharCode","WebSocketServer","verifyClient","handleProtocols","noServer","disableHixie","clientTracking","TypeError","_server","writeHead","Content-Type","listen","_closeServer","_webSocketPaths","handleUpgrade","clients","handleHybiUpgrade","errorHandler","abortConnection","completeHybiUpgrade2","acceptExtensions","completeHybiUpgrade1","callbackCalled","secure","authorized","encrypted","STATUS_CODES","handleHixieUpgrade","onClientVerified","wshost","location","completeHandshake","nonce","rest","k1","k2","md5","spaces","hashBuffer","handshakeBuffer","received","response","u","upgrade","client_1","server_1","AGMImpl","clientRepository","serverRepository","configuration","serverRemoved","serverAdded","serverMethodRemoved","serverMethodAdded","methodRemoved","methodAdded","methodsForInstance","methods","methodFilter","servers","subscribe","createStream","streamDef","unregister","registerAsync","methodDefinition","register","argumentObj","additionalOptions","success","updateInstance","newInstance","invoke_1","promisify_1","Client","repo","clientInvocations","callProtocolSubscribe","targetServers","successProxy","errorProxy","methodResponseTimeout","waitTimeoutMs","methodDef","sub","method_response_timeout","wait_for_method_timeout","delayTillNow","currentServers","getServerMethodsByFilterAndTarget","retry_1","streamInfo","def","getInfoForUser","protocolState","getServers","serverMethodMap","getMethods","getMethodsForInstance","onMethodAdded","onMethodRemoved","onServerAdded","onServerRemoved","onServerMethodAdded","onServerMethodRemoved","methodResponseTimeoutMs","serversMethodMap","invokeUnExisting","serverMethodPair","invokeOnAll","callError","called_with","executed_by","returned","status","delayTillNow_1","retry_2","serverMethodsMap","successes","errors","sendResponse","result_1","invResult","all_return_values","all_errors","currentError","serverMethodsPair","filterByTarget","targetServerMethod","matchingMachine","matches","myMatches","instanceMatch","instanceFilter","instanceDefinition","containsProps","methodMatch","match","prop","constructor","allServers","matchingServers","resultMethodsObject","methodKey","prev","current","methodsForServer","getServerMethodsById","matchingMethods","random_1","ClientInvocations","_pendingCallbacks","onInvocationResult","invocationId","executedBy","resultMessage","processInvocationResult","argumentsObj","stuff","registerInvocation","calledWith","invocationInfo","timeout","ClientRepository","methodsCount","addServer","serverId","serverEntry","serverInfo","createUserServerInfo","getStreams","supportsStreaming","removeServerById","methodId","removeServerMethod","addServerMethod","createMethodId","methodEntity","createUserMethodInfo","getServersByMethod","methodInfo","accepts","returns","allMethods","unsubscribeFunc","getServerById","windowId","peerId","displayName","objectTypes","object_types","display_name","NativeAGM","helpers","agmFacade","methodInfoAsObject","stringToObject","validateMethodInfo","arg","caller","methodResult","tracker","successArgs","targetArgToObject","invoke2","a","parsed","subscriptionRequestHandler","subscriptionAddedHandler","subscriptionRemovedHandler","createStream2","parameters","subscribe2","jsonResult","agmParse","transformServerObject","transformMethodObject","subscribed","Helpers","facade","dateTimeIdentifier","jsonValueDatePrefix","lenOfIdentifier","unixTimestampMs","parseFloat","convertInstanceToRegex","serverFilter","instanceConverted","propValue","stringPropName","jsAgmFacade","cfgAsString","createConfig","successInit","nativeAGM","agm_1","helpers_1","create_stream","methods_for_instance","method_added","method_removed","server_added","server_removed","server_method_added","server_method_removed","initAsync","metricsIdentity","metricsConfig","createOwnInstance","userSubmittedProperties","resolvedIdentity","document","title","instance_1","native_1","factory_1","factory_2","repository_1","repository_2","protocolPromise","agmImpl","myIdentity","myInstance","ClientStreaming","sendRequest","nextResponseSubject","subscriptionsList","ERR_MSG_SUB_FAILED","subscriptionId","pendingSub","registerSubscription","responseSubject","requestSubject","trackedServers","streamId","streamSubjects","private","methodRequestSubject","methodResponseSubject","EventStreamAction","MethodRequestSubject","MethodResponseSubject","Context","ArgumentsJson","InvocationId","MethodName","ExecutionServer","Timeout","processPublisherMsg","serverIsKickingASubscriber","serverAcknowledgesGoodSubscription","serverHasPushedSomeDataIntoTheStream","onClosed","queued","closers","timeoutId","closersCount","closingServer_1","requestArguments","deletionsList","isRejecting","isKicking","StreamId","EventStreamSubject","ResultMessage","callArgs","acceptingServer","isFirstResponse","privateStreamSubject","generatePrivateStreamSubject","confirmatoryRequest","dataCallback","dataItem","closedCallback","onFailed","closeSubscription","serverInstance","this_1","isPrivateData","trackedServersFound","ls","receivedStreamData_1","ResultContextJson","onDataHandlers","queuedData","subId","methodName","client_streaming_1","ClientProtocol","respCounter","timers","streaming","listenForEvents","createServerInfo","createMethod","Method","Name","InputSignature","ResultSignature","Description","DisplayName","Version","ObjectTypeRestrictions","Flags","createServerId","processServerPresence","presence","isPresence","Instance","PublishingInterval","scheduleTimeout","MethodDefinitions","updateServerMethods","duration","timer","newMethods","oldMethods","newMethodsReduced","nm","handleInvokeResultMessage","Status","getAGM","unsubscribe","ServerStreaming","isStreamMsg","pushData","streamingMethod","branches","branchKeyToStreamIdMap","streamIdList","br","Boolean","sendResult","globalEventStreamSubject","closeAllSubscriptions","streamList","getBranchList","getUniqueBranchNames","getSubscriptionList","subscriptions","onSubAdded","handlerFunc","subAddedHandler","onSubRemoved","subRemovedHandler","onSubRequest","requestHandler","generateNewStreamId","streamingMethodName","rejectRequest","requestContext","MethodVersion","privateEventStreamSubject","closeIndividualSubscription","acceptRequestOnBranch","branch","getStreamId","processSubscriberMsg","clientWishesToSubscribe","clientWishesToUnsubscribe","clientAcknowledgesItDidSubscribe","clientPerSubHeartbeat","getBranchKey","needle","needleBranch","sendKickMessage","subItem","initialLength","ResponseContextJson","keysWithDuplicates","seen","bKey","server_streaming_1","HeartbeatInterval","ServerProtocol","invocationMessagesMap","reqCounter","handleMethodInvocationMessage","stopTimers","sendHeartbeat","heartbeatTimer","setInterval","clearInterval","presenceTimer","sendPresence","reqSubj","nextRequestSubject","createNewMethodMessage","announceNewMethod","streamConverted","onInvoked","methodInvocationResult","executedMethod","constructHeartbeat","constructPresence","getList","subject","methodList","invocationArgs","methodIdentifier","STATUS_AWAITING_ACCEPT","STATUS_SUBSCRIBED","ERR_MSG_SUB_REJECTED","session","subscriptionIdToLocalKeyMap","nextSubLocalKey","handleErrorSubscribing","errorResponse","tag","_tag","subLocalKey","callOnClosedHandlers","handleSubscribed","subscription_id","handleEventData","oob","snapshot","sendingServerId","receivedStreamData","handleSubscriptionCancelled","expectedNewLength","getNextSubscriptionLocalKey","server_id","method_id","arguments_kv","closingServerId","closingServer","sendFireAndForget","reason_uri","handlePeerAdded","handlePeerRemoved","handleMethodsAddedMessage","handleMethodsRemovedMessage","handleResultMessage","handleInvocationError","newPeerId","new_peer_id","remoteId","removedPeerId","removed_id","input_signature","result_signature","methodIdList","debug","libConfig","handleReconnect","registeredMethods","theFunction","userCallback","userCallbackAsync","handleInitialJoin","resolveReadyPromise","readyPromise","domain","onJoined","reconnect","ERR_URI_SUBSCRIPTION_FAILED","nextStreamId","handleAddInterest","handleRemoveInterest","subscriptionsMap","subscribeMsg","stream_id","sendSubscriptionFailed","publishMessage","postMessage","dropSubscriptionMessage","closeMultipleSubscriptions","subscriptionsToClose","drop","allSubscriptions","onSubscriptionLifetimeEvent","getById","eventName","getNextStreamId","caller_id","errorMsg","errorMessage","request_id","__awaiter","thisArg","_arguments","P","generator","fulfilled","next","rejected","__generator","body","verb","op","f","_","y","label","ops","trys","g","sent","throw","return","Symbol","iterator","handleInvokeMessage","isStreaming","registerMsg","_a","registrationCallbacks","fail","repoId","restrictions","handleRegisteredMessage","handleErrorRegister","peer_id","invocation_id","warn","callerId","subscription_1","ServerBranch","ServerRepository","nextId","Request","acceptOnBranch","__assign","assign","streaming_1","stream_1","invocations","onMethodInvoked","wrappedCallbackFunction","resultCallback","registerCore","wrappedCallback","serverMethod","streamCallbacks","streamFrontObject","forStream","methodToBeRemoved","unregisterWithPredicate","find","removeMethodsOrStreams","filterPredicate","methodsOrStreamsToRemove","sm","methodsToRemove","filterProps","methodDefProps","from","Set","isMatch","filterValue","methodDefValue","firstObjType","sort","secondObjTypes_1","hasADifference","objType","methodToExecute","unStrException","_result","branch_1","ServerStream","bList","def2","request_1","rc","rm","handleSubRequest","handleSubAdded","handleSubRemoved","protocol_1","successMessages","Protocol","watchOnEvent","topic","_b","routingKey","_c","removeEmptyValues","routing_key","target_identity","keysMatch","cleaned","obj1","obj2","keysObj1","allMatch","getApplication","getConfigProp","prop1","prop2","masterConfigProp1","masterConfig","userProp1","dynamicDefaultsProp1","dynamicDefaults","hardDefaultsProp1","hardDefaults","ifNotFalse","what","uid","shortid_1","GLUE_CONFIG","GLUE_DEFAULT_CONFIG","containerName","browserWindowName","appName","agm_application","documentTitle","system","metricsFacade","getIdentity","machineName","gateway","defaultProtocol","defaultWs","gwURL","reconnectInterval","gwConfig","reconnectAttempts","inproc","replaySpecs","gw","connectionConfig","contextConfig","channels","contextsEnabled","channelsConfig","pjson","__extends","extendStatics","b","setPrototypeOf","__proto__","__","connection_1","messageReplayer_1","GW3ConnectionImpl","_super","MessageReplayerImpl","gw3Protocol","superAPI","availableDomains","authToken","errorMessages","gw3_1","hc_1","ws_1","gw3Connection_1","gw1_1","hc_2","inproc_1","gw3Connection","gw3Port","specs","specsNames","messages","subs","subsRefCount","specs_1","spec","name_1","refCount","processMessage","isDone","name_2","GW1Protocol","messageObj","sendOptions","retryInterval","maxRetries","dateMinLen","datePrefixFirstChar","substring","datePrefixLen","datePrefix","milliseconds","ex","oldToJson","getTime","loginConfig","username","password","shouldTryLogin","authentication","secret","helloMsg","globalDomain","gw3Domain_1","skipPeerId","initialLogin","resolved_identity","available_domains","access_token","setLoggedIn","pingTimer","sessions","leave","isLoggedIn","domainName","domainLogger","handleDisconnected","initialLoginAttempts","createTokenReq","_latestOptions","isJoined","joinPromise","_connectionOn","destination","handleJoined","wasReconnect","tryReconnecting","handleConnectionDisconnected","handleConnectionLoggedIn","onLeft","handleErrorMessage","requestId","entry","requestsMap","handleSuccessMessage","getNextRequestId","successMsg","callbackRegistry","HCProtocol","HCTransport","connectionId","loggingFacade","Inproc","gwToken","connectToken","consoleLevel","_running","_initied","_registry","waitForSocketConnection","_ws","initiateSocket","notifyStatusChanged","onopen","onmessage","failed","retriesLeft","retries","gw3ContextData_1","GW3Bridge","_contextNameToData","_gw3Subscriptions","_nextCallbackSubscriptionNumber","_contextNameToId","_contextIdToName","_gw3Session","subscribeToContextCreatedMessages","subscribeToContextUpdatedMessages","subscribeToContextDestroyedMessages","handleContextCreatedMessage","handleContextUpdatedMessage","handleContextDestroyedMessage","dispose","contextName","createContext","lifetime","createContextMsg","context_id","contextData","GW3ContextData","isAnnounced","contextId","sentExplicitSubscription","invokeUpdateCallbacks","delta","calculatedDelta","calculateContextDelta","added","updated","removed","gwResponse","handleUpdated","updaterId","un","thisCallbackSubscriptionNumber","updateCallbacks","hadCallbacks","hasCallbacks","joinedActivity","sendSubscribe","subscriptionKey","sendUnsubscribe","extraData","oldContext","applyContextDelta","deepEqual","createdMessageTypes","createdMessageTypes_1","createdMessageType","contextCreatedMsg","activity_id","activityId","updatedMessageTypes","updatedMessageTypes_1","updatedMessageType","contextUpdatedMsg","justSeen","context_snapshot","updater_id","updateCallbackIndex","updateCallback","deepClone","destroyedMessageTypes","destroyedMessageTypes_1","destroyedMessageType","destroyedMsg","to","x","getState","HCBridge","_facade","sharedContextFacade","allObj","gw3Bridge_1","hcBridge_1","_bridge","checkName","added_1","updated_1","mergeObjectsProperties","hash","WeakMap","Map","val","withWhat","right","left","contextsModule_1","LogLevel","canPublish","level","restriction","order","trace","levels_1","LoggerImpl","metricSystem","_subloggers","_name","_parent","_path","_loggerFullName","existingSub","publishLevel","_publishLevel","_consoleLevel","metricsSystem","_metricLevel","_metricSystem","toAPIObject","loggerName","toPrint","GetConnection","Level","Logger","Message","Time","setState","logger_1","identityStr","mainLogger","glue_1","addressMetric","newValue","_value","updateMetric","me","getValueType","resolution","metric_types_1","createMetric","countMetric","incrementBy","increment","decrement","decrementBy","numberMetric","mergeValues","rateMetric","statisticsMetric","stringMetric","timespanMetric","timestampMetric","sendFull","subSystems","sendFullSystem","createSystem","metric","heartbeat","publishingInterval","heartbeatInterval","updateSystem","serializer_1","instanceInfo","metricToMessage","getMetricDefinition","_definition","getTypeFromValue","Composite","serializeValue","_metric","_valueTypes","valueOf","CompositeValue","InnerMetricName","valueType","rootStateMetric","composite","Value","defineRootMetricsMsg","replayRepo","replaySystem","ss","normalizeMetricName","createMetricsMsg","shadowedUpdateMetric","timestamp","stateObj","composeMsgForRootStateMetric","rootMetric","serializeMetric","getMetricValueByType","publishMetricsMsg","getMetricTypeByValue","getTypeByValue","serializedMetrics","memo","innerType","defineNestedComposite","publishNestedComposite","flatten","flat","toFlatten","getHighestState","aggregateDescription","idx","aggregatedState","getAggregateState","merged","highestState","clickStream","_root","system_1","rootSystem","useClickStream","navigator","userAgent","clickStream_1","documentClickHandler","className","tagName","href","page","attachEvent","urlMetric","appNameMetric","startUrl","nameSystem","descriptionSystem","_subSystems","_system","_repo","stateDescription","_state","_getOrCreateMetric","metricDef","string_1","number_1","count_1","address_1","object_1","timespan_1","timestamp_1","rate_1","statistics_1","_unionToMetricDef","metricDefinition","expectedType","matching","shadowedMetric","existing","_buildPath","shadowedSystem","aggState","shadowedSubSystem","_description","separator"],"mappings":"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","file":"tick42-glue-core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"util\"), require(\"events\"), require(\"crypto\"), require(\"http\"), require(\"url\"), require(\"cluster\"), require(\"fs\"), require(\"https\"), require(\"stream\"), require(\"tls\"), require(\"zlib\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"tick42-glue-core\", [\"util\", \"events\", \"crypto\", \"http\", \"url\", \"cluster\", \"fs\", \"https\", \"stream\", \"tls\", \"zlib\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tick42-glue-core\"] = factory(require(\"util\"), require(\"events\"), require(\"crypto\"), require(\"http\"), require(\"url\"), require(\"cluster\"), require(\"fs\"), require(\"https\"), require(\"stream\"), require(\"tls\"), require(\"zlib\"));\n\telse\n\t\troot[\"tick42-glue-core\"] = factory(root[\"util\"], root[\"events\"], root[\"crypto\"], root[\"http\"], root[\"url\"], root[\"cluster\"], root[\"fs\"], root[\"https\"], root[\"stream\"], root[\"tls\"], root[\"zlib\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_14__, __WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_27__, __WEBPACK_EXTERNAL_MODULE_113__, __WEBPACK_EXTERNAL_MODULE_114__, __WEBPACK_EXTERNAL_MODULE_115__, __WEBPACK_EXTERNAL_MODULE_116__, __WEBPACK_EXTERNAL_MODULE_117__, __WEBPACK_EXTERNAL_MODULE_118__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"util\"), require(\"events\"), require(\"crypto\"), require(\"http\"), require(\"url\"), require(\"cluster\"), require(\"fs\"), require(\"https\"), require(\"stream\"), require(\"tls\"), require(\"zlib\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"tick42-glue-core\", [\"util\", \"events\", \"crypto\", \"http\", \"url\", \"cluster\", \"fs\", \"https\", \"stream\", \"tls\", \"zlib\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tick42-glue-core\"] = factory(require(\"util\"), require(\"events\"), require(\"crypto\"), require(\"http\"), require(\"url\"), require(\"cluster\"), require(\"fs\"), require(\"https\"), require(\"stream\"), require(\"tls\"), require(\"zlib\"));\n\telse\n\t\troot[\"tick42-glue-core\"] = factory(root[\"util\"], root[\"events\"], root[\"crypto\"], root[\"http\"], root[\"url\"], root[\"cluster\"], root[\"fs\"], root[\"https\"], root[\"stream\"], root[\"tls\"], root[\"zlib\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_14__, __WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_27__, __WEBPACK_EXTERNAL_MODULE_113__, __WEBPACK_EXTERNAL_MODULE_114__, __WEBPACK_EXTERNAL_MODULE_115__, __WEBPACK_EXTERNAL_MODULE_116__, __WEBPACK_EXTERNAL_MODULE_117__, __WEBPACK_EXTERNAL_MODULE_118__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 95);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    DEFAULT: 0,\r\n    STRING: 1,\r\n    NUMBER: 2,\r\n    COUNT: 3,\r\n    RATE: 4,\r\n    STATISTICS: 6,\r\n    TIMESTAMP: 7,\r\n    ADDRESS: 8,\r\n    TIMESPAN: 10,\r\n    OBJECT: 11\r\n};\r\n//# sourceMappingURL=metric-types.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            callbacks[key] = allForKey;\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear\r\n    };\r\n}\r\n;\r\ncreateRegistry.default = createRegistry;\r\nmodule.exports = createRegistry;\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    validate: function (definition, parent, transport) {\r\n        if (definition === null || typeof definition !== \"object\") {\r\n            throw new Error(\"Missing definition\");\r\n        }\r\n        if (parent === null || typeof parent !== \"object\") {\r\n            throw new Error(\"Missing parent\");\r\n        }\r\n        if (transport === null || typeof transport !== \"object\") {\r\n            throw new Error(\"Missing transport\");\r\n        }\r\n    },\r\n};\r\n//# sourceMappingURL=helpers.js.map\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"util\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar shortid = __webpack_require__(9);\r\nexports.default = shortid;\r\n//# sourceMappingURL=random.js.map\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar randomFromSeed = __webpack_require__(36);\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nfunction get () {\n  return alphabet || ORIGINAL;\n}\n\nmodule.exports = {\n    get: get,\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\nvar zlib = __webpack_require__(118);\n\nvar AVAILABLE_WINDOW_BITS = [8, 9, 10, 11, 12, 13, 14, 15];\nvar DEFAULT_WINDOW_BITS = 15;\nvar DEFAULT_MEM_LEVEL = 8;\n\nPerMessageDeflate.extensionName = 'permessage-deflate';\n\n/**\n * Per-message Compression Extensions implementation\n */\n\nfunction PerMessageDeflate(options, isServer) {\n  this._options = options || {};\n  this._isServer = !!isServer;\n  this._inflate = null;\n  this._deflate = null;\n  this.params = null;\n}\n\n/**\n * Create extension parameters offer\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.offer = function() {\n  var params = {};\n  if (this._options.serverNoContextTakeover) {\n    params.server_no_context_takeover = true;\n  }\n  if (this._options.clientNoContextTakeover) {\n    params.client_no_context_takeover = true;\n  }\n  if (this._options.serverMaxWindowBits) {\n    params.server_max_window_bits = this._options.serverMaxWindowBits;\n  }\n  if (this._options.clientMaxWindowBits) {\n    params.client_max_window_bits = this._options.clientMaxWindowBits;\n  } else if (this._options.clientMaxWindowBits == null) {\n    params.client_max_window_bits = true;\n  }\n  return params;\n};\n\n/**\n * Accept extension offer\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.accept = function(paramsList) {\n  paramsList = this.normalizeParams(paramsList);\n\n  var params;\n  if (this._isServer) {\n    params = this.acceptAsServer(paramsList);\n  } else {\n    params = this.acceptAsClient(paramsList);\n  }\n\n  this.params = params;\n  return params;\n};\n\n/**\n * Accept extension offer from client\n *\n * @api private\n */\n\nPerMessageDeflate.prototype.acceptAsServer = function(paramsList) {\n  var accepted = {};\n  var result = paramsList.some(function(params) {\n    accepted = {};\n    if (this._options.serverNoContextTakeover === false && params.server_no_context_takeover) {\n      return;\n    }\n    if (this._options.serverMaxWindowBits === false && params.server_max_window_bits) {\n      return;\n    }\n    if (typeof this._options.serverMaxWindowBits === 'number' &&\n        typeof params.server_max_window_bits === 'number' &&\n        this._options.serverMaxWindowBits > params.server_max_window_bits) {\n      return;\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n      return;\n    }\n\n    if (this._options.serverNoContextTakeover || params.server_no_context_takeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover !== false && params.client_no_context_takeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof this._options.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n    } else if (typeof params.server_max_window_bits === 'number') {\n      accepted.server_max_window_bits = params.server_max_window_bits;\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits !== false && typeof params.client_max_window_bits === 'number') {\n      accepted.client_max_window_bits = params.client_max_window_bits;\n    }\n    return true;\n  }, this);\n\n  if (!result) {\n    throw new Error('Doesn\\'t support the offered configuration');\n  }\n\n  return accepted;\n};\n\n/**\n * Accept extension response from server\n *\n * @api privaye\n */\n\nPerMessageDeflate.prototype.acceptAsClient = function(paramsList) {\n  var params = paramsList[0];\n  if (this._options.clientNoContextTakeover != null) {\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n  }\n  if (this._options.clientMaxWindowBits != null) {\n    if (this._options.clientMaxWindowBits === false && params.client_max_window_bits) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number' &&\n        (!params.client_max_window_bits || params.client_max_window_bits > this._options.clientMaxWindowBits)) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n  }\n  return params;\n};\n\n/**\n * Normalize extensions parameters\n *\n * @api private\n */\n\nPerMessageDeflate.prototype.normalizeParams = function(paramsList) {\n  return paramsList.map(function(params) {\n    Object.keys(params).forEach(function(key) {\n      var value = params[key];\n      if (value.length > 1) {\n        throw new Error('Multiple extension parameters for ' + key);\n      }\n\n      value = value[0];\n\n      switch (key) {\n      case 'server_no_context_takeover':\n      case 'client_no_context_takeover':\n        if (value !== true) {\n          throw new Error('invalid extension parameter value for ' + key + ' (' + value + ')');\n        }\n        params[key] = true;\n        break;\n      case 'server_max_window_bits':\n      case 'client_max_window_bits':\n        if (typeof value === 'string') {\n          value = parseInt(value, 10);\n          if (!~AVAILABLE_WINDOW_BITS.indexOf(value)) {\n            throw new Error('invalid extension parameter value for ' + key + ' (' + value + ')');\n          }\n        }\n        if (!this._isServer && value === true) {\n          throw new Error('Missing extension parameter value for ' + key);\n        }\n        params[key] = value;\n        break;\n      default:\n        throw new Error('Not defined extension parameter (' + key + ')');\n      }\n    }, this);\n    return params;\n  }, this);\n};\n\n/**\n * Decompress message\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.decompress = function (data, fin, callback) {\n  var endpoint = this._isServer ? 'client' : 'server';\n\n  if (!this._inflate) {\n    var maxWindowBits = this.params[endpoint + '_max_window_bits'];\n    this._inflate = zlib.createInflateRaw({\n      windowBits: 'number' === typeof maxWindowBits ? maxWindowBits : DEFAULT_WINDOW_BITS\n    });\n  }\n\n  var self = this;\n  var buffers = [];\n\n  this._inflate.on('error', onError).on('data', onData);\n  this._inflate.write(data);\n  if (fin) {\n    this._inflate.write(new Buffer([0x00, 0x00, 0xff, 0xff]));\n  }\n  this._inflate.flush(function() {\n    cleanup();\n    callback(null, Buffer.concat(buffers));\n  });\n\n  function onError(err) {\n    cleanup();\n    callback(err);\n  }\n\n  function onData(data) {\n    buffers.push(data);\n  }\n\n  function cleanup() {\n    self._inflate.removeListener('error', onError);\n    self._inflate.removeListener('data', onData);\n    if (fin && self.params[endpoint + '_no_context_takeover']) {\n      self._inflate = null;\n    }\n  }\n};\n\n/**\n * Compress message\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.compress = function (data, fin, callback) {\n  var endpoint = this._isServer ? 'server' : 'client';\n\n  if (!this._deflate) {\n    var maxWindowBits = this.params[endpoint + '_max_window_bits'];\n    this._deflate = zlib.createDeflateRaw({\n      flush: zlib.Z_SYNC_FLUSH,\n      windowBits: 'number' === typeof maxWindowBits ? maxWindowBits : DEFAULT_WINDOW_BITS,\n      memLevel: this._options.memLevel || DEFAULT_MEM_LEVEL\n    });\n  }\n\n  var self = this;\n  var buffers = [];\n\n  this._deflate.on('error', onError).on('data', onData);\n  this._deflate.write(data);\n  this._deflate.flush(function() {\n    cleanup();\n    var data = Buffer.concat(buffers);\n    if (fin) {\n      data = data.slice(0, data.length - 4);\n    }\n    callback(null, data);\n  });\n\n  function onError(err) {\n    cleanup();\n    callback(err);\n  }\n\n  function onData(data) {\n    buffers.push(data);\n  }\n\n  function cleanup() {\n    self._deflate.removeListener('error', onError);\n    self._deflate.removeListener('data', onData);\n    if (fin && self.params[endpoint + '_no_context_takeover']) {\n      self._deflate = null;\n    }\n  }\n};\n\nmodule.exports = PerMessageDeflate;\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction convertInfoToInstance(info) {\r\n    if (typeof info !== \"object\") {\r\n        info = {};\r\n    }\r\n    return {\r\n        application: info.ApplicationName,\r\n        environment: info.Environment,\r\n        machine: info.MachineName,\r\n        pid: info.ProcessId,\r\n        region: info.Region,\r\n        service: info.ServiceName,\r\n        user: info.UserName,\r\n        started: info.ProcessStartTime,\r\n    };\r\n}\r\nexports.convertInfoToInstance = convertInfoToInstance;\r\nfunction isStreamingFlagSet(flags) {\r\n    if (typeof flags !== \"number\" || isNaN(flags)) {\r\n        return false;\r\n    }\r\n    var mask = 32;\r\n    var result = flags & mask;\r\n    return result === mask;\r\n}\r\nexports.isStreamingFlagSet = isStreamingFlagSet;\r\nfunction convertInstance(instance) {\r\n    return {\r\n        ApplicationName: instance.application,\r\n        ProcessId: instance.pid,\r\n        MachineName: instance.machine,\r\n        UserName: instance.user,\r\n        Environment: instance.environment,\r\n        Region: instance.region,\r\n    };\r\n}\r\nexports.convertInstance = convertInstance;\r\n//# sourceMappingURL=helpers.js.map\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"events\");\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = __webpack_require__(33);\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1(promise, successCallback, errorCallback) {\r\n    if (typeof successCallback !== \"function\" && typeof errorCallback !== \"function\") {\r\n        return promise;\r\n    }\r\n    if (typeof successCallback !== \"function\") {\r\n        successCallback = function () { };\r\n    }\r\n    else if (typeof errorCallback !== \"function\") {\r\n        errorCallback = function () { };\r\n    }\r\n    promise.then(successCallback, errorCallback);\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=promisify.js.map\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerSubscription = (function () {\r\n    function ServerSubscription(protocol, repoMethod, subscription) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.subscription = subscription;\r\n    }\r\n    Object.defineProperty(ServerSubscription.prototype, \"stream\", {\r\n        get: function () { return this.repoMethod.stream; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"arguments\", {\r\n        get: function () { return this.subscription.arguments || {}; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"branchKey\", {\r\n        get: function () { return this.subscription.branchKey; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"instance\", {\r\n        get: function () { return this.subscription.instance; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerSubscription.prototype.close = function () {\r\n        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);\r\n    };\r\n    ServerSubscription.prototype.push = function (data) {\r\n        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);\r\n    };\r\n    return ServerSubscription;\r\n}());\r\nexports.default = ServerSubscription;\r\n//# sourceMappingURL=subscription.js.map\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar msg = __webpack_require__(24);\r\nexports.ContextMessageReplaySpec = {\r\n    get name() {\r\n        return \"context\";\r\n    },\r\n    get types() {\r\n        return [\r\n            msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY\r\n        ];\r\n    }\r\n};\r\n//# sourceMappingURL=contextMessageReplaySpec.js.map\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Utils = (function () {\r\n    function Utils() {\r\n    }\r\n    Utils.getGDMajorVersion = function () {\r\n        if (typeof window === \"undefined\") {\r\n            return -1;\r\n        }\r\n        if (!window.glueDesktop) {\r\n            return -1;\r\n        }\r\n        if (!window.glueDesktop.version) {\r\n            return -1;\r\n        }\r\n        var ver = Number(window.glueDesktop.version.substr(0, 1));\r\n        return isNaN(ver) ? -1 : ver;\r\n    };\r\n    Utils.isNode = function () {\r\n        try {\r\n            return Object.prototype.toString.call(global.process) === \"[object process]\";\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    };\r\n    return Utils;\r\n}());\r\nexports.default = Utils;\r\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"crypto\");\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\"name\":\"tick42-glue-core\",\"version\":\"4.3.7\",\"description\":\"Glue42 core library including logger, connection, agm and metrics\",\"main\":\"./dist/node/tick42-glue-core.js\",\"types\":\"./glue.d.ts\",\"browser\":\"./dist/web/tick42-glue-core.js\",\"scripts\":{\"init-dev-mode\":\"node ./build/scripts/init-dev-mode.js\",\"remove-installed-dependencies\":\"node ./build/scripts/remove-installed-dependencies.js\",\"clean\":\"node ./build/scripts/clean.js\",\"pre:build\":\"npm run clean && npm run tslint && tsc && set NODE_ENV=development\",\"file-versionify\":\"node ./build/scripts/file-versionify.js\",\"tslint\":\"tslint -t codeFrame ./src/**.ts\",\"tslint:fix\":\"tslint -t codeFrame --fix ./src/**.ts\",\"watch\":\"onchange ./src/**/*.ts -- npm run build:dev\",\"build:dev\":\"npm run pre:build && set NODE_ENV=development && webpack && npm run file-versionify\",\"build:prod\":\"npm run pre:build && set NODE_ENV=development && webpack && set NODE_ENV=production && webpack && npm run file-versionify\",\"docs\":\"typedoc --options typedoc.json ./src\",\"prepublish\":\"npm run build:prod && npm run test:only\",\"test\":\"npm run build:dev && npm run test:only\",\"test:only\":\"mocha ./tests/ --recursive\",\"test:core\":\"mocha ./tests/core\",\"test:agm\":\"mocha ./tests/agm\",\"test:bus\":\"mocha ./tests/bus\"},\"repository\":{\"type\":\"git\",\"url\":\"https://stash.tick42.com/scm/tg/js-glue-core.git\"},\"author\":{\"name\":\"Tick42\",\"url\":\"http://www.glue42.com\"},\"license\":\"ISC\",\"dependencies\":{\"callback-registry\":\"^2.4.0\",\"es6-promise\":\"^4.1.0\",\"shortid\":\"^2.2.6\",\"util-deprecate\":\"^1.0.2\",\"ws\":\"^0.7.2\"},\"devDependencies\":{\"@types/node\":\"^10.7.0\",\"@types/shortid\":\"0.0.29\",\"archiver\":\"^1.3.0\",\"babel-core\":\"^6.25.0\",\"babel-loader\":\"^6.4.1\",\"babel-plugin-add-module-exports\":\"^0.2.1\",\"babel-preset-es2015\":\"^6.16.0\",\"babel-preset-stage-2\":\"^6.22.0\",\"chai\":\"^4.0.2\",\"deep-equal\":\"^1.0.1\",\"mocha\":\"^2.5.3\",\"onchange\":\"3.*\",\"pre-commit\":\"^1.1.3\",\"readline-sync\":\"^1.4.5\",\"shelljs\":\"^0.6.0\",\"tick42-gateway\":\"0.2.7\",\"tick42-webpack-config\":\"4.1.6\",\"tslint\":\"^5.11.0\",\"typescript\":\"^3.0.1\",\"webpack\":\"2.3.3\"}}\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar fs = __webpack_require__(114);\n\nfunction Options(defaults) {\n  var internalValues = {};\n  var values = this.value = {};\n  Object.keys(defaults).forEach(function(key) {\n    internalValues[key] = defaults[key];\n    Object.defineProperty(values, key, {\n      get: function() { return internalValues[key]; },\n      configurable: false,\n      enumerable: true\n    });\n  });\n  this.reset = function() {\n    Object.keys(defaults).forEach(function(key) {\n      internalValues[key] = defaults[key];\n    });\n    return this;\n  };\n  this.merge = function(options, required) {\n    options = options || {};\n    if (Object.prototype.toString.call(required) === '[object Array]') {\n      var missing = [];\n      for (var i = 0, l = required.length; i < l; ++i) {\n        var key = required[i];\n        if (!(key in options)) {\n          missing.push(key);\n        }\n      }\n      if (missing.length > 0) {\n        if (missing.length > 1) {\n          throw new Error('options ' +\n            missing.slice(0, missing.length - 1).join(', ') + ' and ' +\n            missing[missing.length - 1] + ' must be defined');\n        }\n        else throw new Error('option ' + missing[0] + ' must be defined');\n      }\n    }\n    Object.keys(options).forEach(function(key) {\n      if (key in internalValues) {\n        internalValues[key] = options[key];\n      }\n    });\n    return this;\n  };\n  this.copy = function(keys) {\n    var obj = {};\n    Object.keys(defaults).forEach(function(key) {\n      if (keys.indexOf(key) !== -1) {\n        obj[key] = values[key];\n      }\n    });\n    return obj;\n  };\n  this.read = function(filename, cb) {\n    if (typeof cb == 'function') {\n      var self = this;\n      fs.readFile(filename, function(error, data) {\n        if (error) return cb(error);\n        var conf = JSON.parse(data);\n        self.merge(conf);\n        cb();\n      });\n    }\n    else {\n      var conf = JSON.parse(fs.readFileSync(filename));\n      this.merge(conf);\n    }\n    return this;\n  };\n  this.isDefined = function(key) {\n    return typeof values[key] != 'undefined';\n  };\n  this.isDefinedAndNonNull = function(key) {\n    return typeof values[key] != 'undefined' && values[key] !== null;\n  };\n  Object.freeze(values);\n  Object.freeze(this);\n}\n\nmodule.exports = Options;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"bufferutil\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (e) {\n  module.exports = __webpack_require__(41);\n}\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports = {\n  isValidErrorCode: function(code) {\n    return (code >= 1000 && code <= 1011 && code != 1004 && code != 1005 && code != 1006) ||\n         (code >= 3000 && code <= 4999);\n  },\n  1000: 'normal',\n  1001: 'going away',\n  1002: 'protocol error',\n  1003: 'unsupported data',\n  1004: 'reserved',\n  1005: 'reserved for extensions',\n  1006: 'reserved for extensions',\n  1007: 'inconsistent or invalid data',\n  1008: 'policy violation',\n  1009: 'message too big',\n  1010: 'extension handshake missing',\n  1011: 'an unexpected condition prevented the request from being fulfilled',\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\nvar util = __webpack_require__(3);\n\n/**\n * Module exports.\n */\n\nexports.parse = parse;\nexports.format = format;\n\n/**\n * Parse extensions header value\n */\n\nfunction parse(value) {\n  value = value || '';\n\n  var extensions = {};\n\n  value.split(',').forEach(function(v) {\n    var params = v.split(';');\n    var token = params.shift().trim();\n    var paramsList = extensions[token] = extensions[token] || [];\n    var parsedParams = {};\n\n    params.forEach(function(param) {\n      var parts = param.trim().split('=');\n      var key = parts[0];\n      var value = parts[1];\n      if (typeof value === 'undefined') {\n        value = true;\n      } else {\n        // unquote value\n        if (value[0] === '\"') {\n          value = value.slice(1);\n        }\n        if (value[value.length - 1] === '\"') {\n          value = value.slice(0, value.length - 1);\n        }\n      }\n      (parsedParams[key] = parsedParams[key] || []).push(value);\n    });\n\n    paramsList.push(parsedParams);\n  });\n\n  return extensions;\n}\n\n/**\n * Format extensions header value\n */\n\nfunction format(value) {\n  return Object.keys(value).map(function(token) {\n    var paramsList = value[token];\n    if (!util.isArray(paramsList)) {\n      paramsList = [paramsList];\n    }\n    return paramsList.map(function(params) {\n      return [token].concat(Object.keys(params).map(function(k) {\n        var p = params[k];\n        if (!util.isArray(p)) p = [p];\n        return p.map(function(v) {\n          return v === true ? k : k + '=' + v;\n        }).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = __webpack_require__(3)\n  , Validation = __webpack_require__(45).Validation\n  , ErrorCodes = __webpack_require__(18)\n  , BufferPool = __webpack_require__(40)\n  , bufferUtil = __webpack_require__(17).BufferUtil\n  , PerMessageDeflate = __webpack_require__(6);\n\n/**\n * HyBi Receiver implementation\n */\n\nfunction Receiver (extensions) {\n  // memory pool for fragmented messages\n  var fragmentedPoolPrevUsed = -1;\n  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {\n    return db.used + length;\n  }, function(db) {\n    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed >= 0 ?\n      (fragmentedPoolPrevUsed + db.used) / 2 :\n      db.used;\n  });\n\n  // memory pool for unfragmented messages\n  var unfragmentedPoolPrevUsed = -1;\n  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {\n    return db.used + length;\n  }, function(db) {\n    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed >= 0 ?\n      (unfragmentedPoolPrevUsed + db.used) / 2 :\n      db.used;\n  });\n\n  this.extensions = extensions || {};\n  this.state = {\n    activeFragmentedOperation: null,\n    lastFragment: false,\n    masked: false,\n    opcode: 0,\n    fragmentedOperation: false\n  };\n  this.overflow = [];\n  this.headerBuffer = new Buffer(10);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.currentMessage = [];\n  this.messageHandlers = [];\n  this.expectHeader(2, this.processPacket);\n  this.dead = false;\n  this.processing = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  var dataLength = data.length;\n  if (dataLength == 0) return;\n  if (this.expectBuffer == null) {\n    this.overflow.push(data);\n    return;\n  }\n  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);\n  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);\n  this.expectOffset += toRead;\n  if (toRead < dataLength) {\n    this.overflow.push(data.slice(toRead));\n  }\n  while (this.expectBuffer && this.expectOffset == this.expectBuffer.length) {\n    var bufferForHandler = this.expectBuffer;\n    this.expectBuffer = null;\n    this.expectOffset = 0;\n    this.expectHandler.call(this, bufferForHandler);\n  }\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.overflow = null;\n  this.headerBuffer = null;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.unfragmentedBufferPool = null;\n  this.fragmentedBufferPool = null;\n  this.state = null;\n  this.currentMessage = null;\n  this.onerror = null;\n  this.ontext = null;\n  this.onbinary = null;\n  this.onclose = null;\n  this.onping = null;\n  this.onpong = null;\n};\n\n/**\n * Waits for a certain amount of header bytes to be available, then fires a callback.\n *\n * @api private\n */\n\nReceiver.prototype.expectHeader = function(length, handler) {\n  if (length == 0) {\n    handler(null);\n    return;\n  }\n  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);\n  this.expectHandler = handler;\n  var toRead = length;\n  while (toRead > 0 && this.overflow.length > 0) {\n    var fromOverflow = this.overflow.pop();\n    if (toRead < fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));\n    var read = Math.min(fromOverflow.length, toRead);\n    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\n    this.expectOffset += read;\n    toRead -= read;\n  }\n};\n\n/**\n * Waits for a certain amount of data bytes to be available, then fires a callback.\n *\n * @api private\n */\n\nReceiver.prototype.expectData = function(length, handler) {\n  if (length == 0) {\n    handler(null);\n    return;\n  }\n  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);\n  this.expectHandler = handler;\n  var toRead = length;\n  while (toRead > 0 && this.overflow.length > 0) {\n    var fromOverflow = this.overflow.pop();\n    if (toRead < fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));\n    var read = Math.min(fromOverflow.length, toRead);\n    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\n    this.expectOffset += read;\n    toRead -= read;\n  }\n};\n\n/**\n * Allocates memory from the buffer pool.\n *\n * @api private\n */\n\nReceiver.prototype.allocateFromPool = function(length, isFragmented) {\n  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);\n};\n\n/**\n * Start processing a new packet.\n *\n * @api private\n */\n\nReceiver.prototype.processPacket = function (data) {\n  if (this.extensions[PerMessageDeflate.extensionName]) {\n    if ((data[0] & 0x30) != 0) {\n      this.error('reserved fields (2, 3) must be empty', 1002);\n      return;\n    }\n  } else {\n    if ((data[0] & 0x70) != 0) {\n      this.error('reserved fields must be empty', 1002);\n      return;\n    }\n  }\n  this.state.lastFragment = (data[0] & 0x80) == 0x80;\n  this.state.masked = (data[1] & 0x80) == 0x80;\n  var compressed = (data[0] & 0x40) == 0x40;\n  var opcode = data[0] & 0xf;\n  if (opcode === 0) {\n    if (compressed) {\n      this.error('continuation frame cannot have the Per-message Compressed bits', 1002);\n      return;\n    }\n    // continuation frame\n    this.state.fragmentedOperation = true;\n    this.state.opcode = this.state.activeFragmentedOperation;\n    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {\n      this.error('continuation frame cannot follow current opcode', 1002);\n      return;\n    }\n  }\n  else {\n    if (opcode < 3 && this.state.activeFragmentedOperation != null) {\n      this.error('data frames after the initial data frame must have opcode 0', 1002);\n      return;\n    }\n    if (opcode >= 8 && compressed) {\n      this.error('control frames cannot have the Per-message Compressed bits', 1002);\n      return;\n    }\n    this.state.compressed = compressed;\n    this.state.opcode = opcode;\n    if (this.state.lastFragment === false) {\n      this.state.fragmentedOperation = true;\n      this.state.activeFragmentedOperation = opcode;\n    }\n    else this.state.fragmentedOperation = false;\n  }\n  var handler = opcodes[this.state.opcode];\n  if (typeof handler == 'undefined') this.error('no handler for opcode ' + this.state.opcode, 1002);\n  else {\n    handler.start.call(this, data);\n  }\n};\n\n/**\n * Endprocessing a packet.\n *\n * @api private\n */\n\nReceiver.prototype.endPacket = function() {\n  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);\n  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(false);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  if (this.state.lastFragment && this.state.opcode === this.state.activeFragmentedOperation) {\n    // end current fragmented operation\n    this.state.activeFragmentedOperation = null;\n  }\n  this.state.lastFragment = false;\n  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;\n  this.state.masked = false;\n  this.expectHeader(2, this.processPacket);\n};\n\n/**\n * Reset the parser state.\n *\n * @api private\n */\n\nReceiver.prototype.reset = function() {\n  if (this.dead) return;\n  this.state = {\n    activeFragmentedOperation: null,\n    lastFragment: false,\n    masked: false,\n    opcode: 0,\n    fragmentedOperation: false\n  };\n  this.fragmentedBufferPool.reset(true);\n  this.unfragmentedBufferPool.reset(true);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.overflow = [];\n  this.currentMessage = [];\n  this.messageHandlers = [];\n};\n\n/**\n * Unmask received data.\n *\n * @api private\n */\n\nReceiver.prototype.unmask = function (mask, buf, binary) {\n  if (mask != null && buf != null) bufferUtil.unmask(buf, mask);\n  if (binary) return buf;\n  return buf != null ? buf.toString('utf8') : '';\n};\n\n/**\n * Concatenates a list of buffers.\n *\n * @api private\n */\n\nReceiver.prototype.concatBuffers = function(buffers) {\n  var length = 0;\n  for (var i = 0, l = buffers.length; i < l; ++i) length += buffers[i].length;\n  var mergedBuffer = new Buffer(length);\n  bufferUtil.merge(mergedBuffer, buffers);\n  return mergedBuffer;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, protocolErrorCode) {\n  this.reset();\n  this.onerror(reason, protocolErrorCode);\n  return this;\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nReceiver.prototype.flush = function() {\n  if (this.processing || this.dead) return;\n\n  var handler = this.messageHandlers.shift();\n  if (!handler) return;\n\n  this.processing = true;\n  var self = this;\n\n  handler(function() {\n    self.processing = false;\n    self.flush();\n  });\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nReceiver.prototype.applyExtensions = function(messageBuffer, fin, compressed, callback) {\n  var self = this;\n  if (compressed) {\n    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {\n      if (self.dead) return;\n      if (err) {\n        callback(new Error('invalid compressed data'));\n        return;\n      }\n      callback(null, buffer);\n    });\n  } else {\n    callback(null, messageBuffer);\n  }\n};\n\n/**\n * Buffer utilities\n */\n\nfunction readUInt16BE(start) {\n  return (this[start]<<8) +\n         this[start+1];\n}\n\nfunction readUInt32BE(start) {\n  return (this[start]<<24) +\n         (this[start+1]<<16) +\n         (this[start+2]<<8) +\n         this[start+3];\n}\n\nfunction fastCopy(length, srcBuffer, dstBuffer, dstOffset) {\n  switch (length) {\n    default: srcBuffer.copy(dstBuffer, dstOffset, 0, length); break;\n    case 16: dstBuffer[dstOffset+15] = srcBuffer[15];\n    case 15: dstBuffer[dstOffset+14] = srcBuffer[14];\n    case 14: dstBuffer[dstOffset+13] = srcBuffer[13];\n    case 13: dstBuffer[dstOffset+12] = srcBuffer[12];\n    case 12: dstBuffer[dstOffset+11] = srcBuffer[11];\n    case 11: dstBuffer[dstOffset+10] = srcBuffer[10];\n    case 10: dstBuffer[dstOffset+9] = srcBuffer[9];\n    case 9: dstBuffer[dstOffset+8] = srcBuffer[8];\n    case 8: dstBuffer[dstOffset+7] = srcBuffer[7];\n    case 7: dstBuffer[dstOffset+6] = srcBuffer[6];\n    case 6: dstBuffer[dstOffset+5] = srcBuffer[5];\n    case 5: dstBuffer[dstOffset+4] = srcBuffer[4];\n    case 4: dstBuffer[dstOffset+3] = srcBuffer[3];\n    case 3: dstBuffer[dstOffset+2] = srcBuffer[2];\n    case 2: dstBuffer[dstOffset+1] = srcBuffer[1];\n    case 1: dstBuffer[dstOffset] = srcBuffer[0];\n  }\n}\n\nfunction clone(obj) {\n  var cloned = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      cloned[k] = obj[k];\n    }\n  }\n  return cloned;\n}\n\n/**\n * Opcode handlers\n */\n\nvar opcodes = {\n  // text\n  '1': {\n    start: function(data) {\n      var self = this;\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['1'].getData.call(self, firstLength);\n      }\n      else if (firstLength == 126) {\n        self.expectHeader(2, function(data) {\n          opcodes['1'].getData.call(self, readUInt16BE.call(data, 0));\n        });\n      }\n      else if (firstLength == 127) {\n        self.expectHeader(8, function(data) {\n          if (readUInt32BE.call(data, 0) != 0) {\n            self.error('packets with length spanning more than 32 bit is currently not supported', 1008);\n            return;\n          }\n          opcodes['1'].getData.call(self, readUInt32BE.call(data, 4));\n        });\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['1'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['1'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      var packet = this.unmask(mask, data, true) || new Buffer(0);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.applyExtensions(packet, state.lastFragment, state.compressed, function(err, buffer) {\n          if (err) return self.error(err.message, 1007);\n          if (buffer != null) self.currentMessage.push(buffer);\n\n          if (state.lastFragment) {\n            var messageBuffer = self.concatBuffers(self.currentMessage);\n            self.currentMessage = [];\n            if (!Validation.isValidUTF8(messageBuffer)) {\n              self.error('invalid utf8 sequence', 1007);\n              return;\n            }\n            self.ontext(messageBuffer.toString('utf8'), {masked: state.masked, buffer: messageBuffer});\n          }\n          callback();\n        });\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // binary\n  '2': {\n    start: function(data) {\n      var self = this;\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['2'].getData.call(self, firstLength);\n      }\n      else if (firstLength == 126) {\n        self.expectHeader(2, function(data) {\n          opcodes['2'].getData.call(self, readUInt16BE.call(data, 0));\n        });\n      }\n      else if (firstLength == 127) {\n        self.expectHeader(8, function(data) {\n          if (readUInt32BE.call(data, 0) != 0) {\n            self.error('packets with length spanning more than 32 bit is currently not supported', 1008);\n            return;\n          }\n          opcodes['2'].getData.call(self, readUInt32BE.call(data, 4, true));\n        });\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['2'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['2'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      var packet = this.unmask(mask, data, true) || new Buffer(0);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.applyExtensions(packet, state.lastFragment, state.compressed, function(err, buffer) {\n          if (err) return self.error(err.message, 1007);\n          if (buffer != null) self.currentMessage.push(buffer);\n          if (state.lastFragment) {\n            var messageBuffer = self.concatBuffers(self.currentMessage);\n            self.currentMessage = [];\n            self.onbinary(messageBuffer, {masked: state.masked, buffer: messageBuffer});\n          }\n          callback();\n        });\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // close\n  '8': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented close is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['8'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['8'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['8'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = self.unmask(mask, data, true);\n\n      var state = clone(this.state);\n      this.messageHandlers.push(function() {\n        if (data && data.length == 1) {\n          self.error('close packets with data must be at least two bytes long', 1002);\n          return;\n        }\n        var code = data && data.length > 1 ? readUInt16BE.call(data, 0) : 1000;\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          self.error('invalid error code', 1002);\n          return;\n        }\n        var message = '';\n        if (data && data.length > 2) {\n          var messageBuffer = data.slice(2);\n          if (!Validation.isValidUTF8(messageBuffer)) {\n            self.error('invalid utf8 sequence', 1007);\n            return;\n          }\n          message = messageBuffer.toString('utf8');\n        }\n        self.onclose(code, message, {masked: state.masked});\n        self.reset();\n      });\n      this.flush();\n    },\n  },\n  // ping\n  '9': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented ping is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['9'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['9'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['9'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = this.unmask(mask, data, true);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.onping(data, {masked: state.masked, binary: true});\n        callback();\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // pong\n  '10': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented pong is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['10'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (this.state.masked) {\n        this.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['10'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        this.expectData(length, function(data) {\n          opcodes['10'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = self.unmask(mask, data, true);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.onpong(data, {masked: state.masked, binary: true});\n        callback();\n      });\n      this.flush();\n      this.endPacket();\n    }\n  }\n}\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = __webpack_require__(8)\n  , util = __webpack_require__(3)\n  , EventEmitter = events.EventEmitter\n  , ErrorCodes = __webpack_require__(18)\n  , bufferUtil = __webpack_require__(17).BufferUtil\n  , PerMessageDeflate = __webpack_require__(6);\n\n/**\n * HyBi Sender implementation\n */\n\nfunction Sender(socket, extensions) {\n  events.EventEmitter.call(this);\n\n  this._socket = socket;\n  this.extensions = extensions || {};\n  this.firstFragment = true;\n  this.compress = false;\n  this.messageHandlers = [];\n  this.processing = false;\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (typeof code !== 'undefined') {\n    if (typeof code !== 'number' ||\n      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');\n  }\n  code = code || 1000;\n  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));\n  writeUInt16BE.call(dataBuffer, code, 0);\n  if (dataBuffer.length > 2) dataBuffer.write(data, 2);\n\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0x8, dataBuffer, true, mask);\n    callback();\n    if (typeof cb == 'function') cb();\n  });\n  this.flush();\n};\n\n/**\n * Sends a ping message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0x9, data || '', true, mask);\n    callback();\n  });\n  this.flush();\n};\n\n/**\n * Sends a pong message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0xa, data || '', true, mask);\n    callback();\n  });\n  this.flush();\n};\n\n/**\n * Sends text or binary data to the remote party.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  var finalFragment = options && options.fin === false ? false : true;\n  var mask = options && options.mask;\n  var compress = options && options.compress;\n  var opcode = options && options.binary ? 2 : 1;\n  if (this.firstFragment === false) {\n    opcode = 0;\n    compress = false;\n  } else {\n    this.firstFragment = false;\n    this.compress = compress;\n  }\n  if (finalFragment) this.firstFragment = true\n\n  var compressFragment = this.compress;\n\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {\n      if (err) {\n        if (typeof cb == 'function') cb(err);\n        else self.emit('error', err);\n        return;\n      }\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      callback();\n    });\n  });\n  this.flush();\n};\n\n/**\n * Frames and sends a piece of data according to the HyBi WebSocket protocol.\n *\n * @api private\n */\n\nSender.prototype.frameAndSend = function(opcode, data, finalFragment, maskData, compressed, cb) {\n  var canModifyData = false;\n\n  if (!data) {\n    try {\n      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0, 0] : [])), 'binary', cb);\n    }\n    catch (e) {\n      if (typeof cb == 'function') cb(e);\n      else this.emit('error', e);\n    }\n    return;\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    canModifyData = true;\n    if (data && (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {\n      data = getArrayBuffer(data);\n    } else {\n      data = new Buffer(data);\n    }\n  }\n\n  var dataLength = data.length\n    , dataOffset = maskData ? 6 : 2\n    , secondByte = dataLength;\n\n  if (dataLength >= 65536) {\n    dataOffset += 8;\n    secondByte = 127;\n  }\n  else if (dataLength > 125) {\n    dataOffset += 2;\n    secondByte = 126;\n  }\n\n  var mergeBuffers = dataLength < 32768 || (maskData && !canModifyData);\n  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;\n  var outputBuffer = new Buffer(totalLength);\n  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;\n  if (compressed) outputBuffer[0] |= 0x40;\n\n  switch (secondByte) {\n    case 126:\n      writeUInt16BE.call(outputBuffer, dataLength, 2);\n      break;\n    case 127:\n      writeUInt32BE.call(outputBuffer, 0, 2);\n      writeUInt32BE.call(outputBuffer, dataLength, 6);\n  }\n\n  if (maskData) {\n    outputBuffer[1] = secondByte | 0x80;\n    var mask = this._randomMask || (this._randomMask = getRandomMask());\n    outputBuffer[dataOffset - 4] = mask[0];\n    outputBuffer[dataOffset - 3] = mask[1];\n    outputBuffer[dataOffset - 2] = mask[2];\n    outputBuffer[dataOffset - 1] = mask[3];\n    if (mergeBuffers) {\n      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      bufferUtil.mask(data, mask, data, 0, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n  else {\n    outputBuffer[1] = secondByte;\n    if (mergeBuffers) {\n      data.copy(outputBuffer, dataOffset);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nSender.prototype.flush = function() {\n  if (this.processing) return;\n\n  var handler = this.messageHandlers.shift();\n  if (!handler) return;\n\n  this.processing = true;\n\n  var self = this;\n\n  handler(function() {\n    self.processing = false;\n    self.flush();\n  });\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nSender.prototype.applyExtensions = function(data, fin, compress, callback) {\n  if (compress && data) {\n    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);\n  } else {\n    callback(null, data);\n  }\n};\n\nmodule.exports = Sender;\n\nfunction writeUInt16BE(value, offset) {\n  this[offset] = (value & 0xff00)>>8;\n  this[offset+1] = value & 0xff;\n}\n\nfunction writeUInt32BE(value, offset) {\n  this[offset] = (value & 0xff000000)>>24;\n  this[offset+1] = (value & 0xff0000)>>16;\n  this[offset+2] = (value & 0xff00)>>8;\n  this[offset+3] = value & 0xff;\n}\n\nfunction getArrayBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var array = new Uint8Array(data.buffer || data)\n    , l = data.byteLength || data.length\n    , o = data.byteOffset || 0\n    , buffer = new Buffer(l);\n  for (var i = 0; i < l; ++i) {\n    buffer[i] = array[o+i];\n  }\n  return buffer;\n}\n\nfunction getRandomMask() {\n  return new Buffer([\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255)\n  ]);\n}\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar url = __webpack_require__(27)\n  , util = __webpack_require__(3)\n  , http = __webpack_require__(26)\n  , https = __webpack_require__(115)\n  , crypto = __webpack_require__(14)\n  , stream = __webpack_require__(116)\n  , Ultron = __webpack_require__(38)\n  , Options = __webpack_require__(16)\n  , Sender = __webpack_require__(21)\n  , Receiver = __webpack_require__(20)\n  , SenderHixie = __webpack_require__(43)\n  , ReceiverHixie = __webpack_require__(42)\n  , Extensions = __webpack_require__(19)\n  , PerMessageDeflate = __webpack_require__(6)\n  , EventEmitter = __webpack_require__(8).EventEmitter;\n\n/**\n * Constants\n */\n\n// Default protocol version\n\nvar protocolVersion = 13;\n\n// Close timeout\n\nvar closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly\n\n/**\n * WebSocket implementation\n *\n * @constructor\n * @param {String} address Connection address.\n * @param {String|Array} protocols WebSocket protocols.\n * @param {Object} options Additional connection options.\n * @api public\n */\nfunction WebSocket(address, protocols, options) {\n  EventEmitter.call(this);\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols;\n    protocols = null;\n  }\n\n  if ('string' === typeof protocols) {\n    protocols = [ protocols ];\n  }\n\n  if (!Array.isArray(protocols)) {\n    protocols = [];\n  }\n\n  this._socket = null;\n  this._ultron = null;\n  this._closeReceived = false;\n  this.bytesReceived = 0;\n  this.readyState = null;\n  this.supports = {};\n  this.extensions = {};\n\n  if (Array.isArray(address)) {\n    initAsServerClient.apply(this, address.concat(options));\n  } else {\n    initAsClient.apply(this, [address, protocols, options]);\n  }\n}\n\n/**\n * Inherits from EventEmitter.\n */\nutil.inherits(WebSocket, EventEmitter);\n\n/**\n * Ready States\n */\n[\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function each(state, index) {\n    WebSocket.prototype[state] = WebSocket[state] = index;\n});\n\n/**\n * Gracefully closes the connection, after sending a description message to the server\n *\n * @param {Object} data to be sent to the server\n * @api public\n */\nWebSocket.prototype.close = function close(code, data) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this.readyState === WebSocket.CONNECTING) {\n    this.readyState = WebSocket.CLOSED;\n    return;\n  }\n\n  if (this.readyState === WebSocket.CLOSING) {\n    if (this._closeReceived && this._isServer) {\n      this.terminate();\n    }\n    return;\n  }\n\n  var self = this;\n  try {\n    this.readyState = WebSocket.CLOSING;\n    this._closeCode = code;\n    this._closeMessage = data;\n    var mask = !this._isServer;\n    this._sender.close(code, data, mask, function(err) {\n      if (err) self.emit('error', err);\n\n      if (self._closeReceived && self._isServer) {\n        self.terminate();\n      } else {\n        // ensure that the connection is cleaned up even when no response of closing handshake.\n        clearTimeout(self._closeTimer);\n        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);\n      }\n    });\n  } catch (e) {\n    this.emit('error', e);\n  }\n};\n\n/**\n * Pause the client stream\n *\n * @api public\n */\nWebSocket.prototype.pause = function pauser() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n  return this._socket.pause();\n};\n\n/**\n * Sends a ping\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\nWebSocket.prototype.ping = function ping(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.ping(data, options);\n};\n\n/**\n * Sends a pong\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\nWebSocket.prototype.pong = function(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.pong(data, options);\n};\n\n/**\n * Resume the client stream\n *\n * @api public\n */\nWebSocket.prototype.resume = function resume() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n  return this._socket.resume();\n};\n\n/**\n * Sends a piece of data\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} Optional callback which is executed after the send completes\n * @api public\n */\n\nWebSocket.prototype.send = function send(data, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));\n    else throw new Error('not opened');\n    return;\n  }\n\n  if (!data) data = '';\n  if (this._queue) {\n    var self = this;\n    this._queue.push(function() { self.send(data, options, cb); });\n    return;\n  }\n\n  options = options || {};\n  options.fin = true;\n\n  if (typeof options.binary === 'undefined') {\n    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||\n      data instanceof Uint8Array ||\n      data instanceof Uint16Array ||\n      data instanceof Uint32Array ||\n      data instanceof Int8Array ||\n      data instanceof Int16Array ||\n      data instanceof Int32Array ||\n      data instanceof Float32Array ||\n      data instanceof Float64Array);\n  }\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  var readable = typeof stream.Readable === 'function'\n    ? stream.Readable\n    : stream.Stream;\n\n  if (data instanceof readable) {\n    startQueue(this);\n    var self = this;\n\n    sendStream(this, data, options, function send(error) {\n      process.nextTick(function tock() {\n        executeQueueSends(self);\n      });\n\n      if (typeof cb === 'function') cb(error);\n    });\n  } else {\n    this._sender.send(data, options, cb);\n  }\n};\n\n/**\n * Streams data through calls to a user supplied function\n *\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} 'function (error, send)' which is executed on successive ticks of which send is 'function (data, final)'.\n * @api public\n */\nWebSocket.prototype.stream = function stream(options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var self = this;\n\n  if (typeof cb !== 'function') throw new Error('callback must be provided');\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));\n    else throw new Error('not opened');\n    return;\n  }\n\n  if (this._queue) {\n    this._queue.push(function () { self.stream(options, cb); });\n    return;\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  startQueue(this);\n\n  function send(data, final) {\n    try {\n      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');\n      options.fin = final === true;\n      self._sender.send(data, options);\n      if (!final) process.nextTick(cb.bind(null, null, send));\n      else executeQueueSends(self);\n    } catch (e) {\n      if (typeof cb === 'function') cb(e);\n      else {\n        delete self._queue;\n        self.emit('error', e);\n      }\n    }\n  }\n\n  process.nextTick(cb.bind(null, null, send));\n};\n\n/**\n * Immediately shuts down the connection\n *\n * @api public\n */\nWebSocket.prototype.terminate = function terminate() {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this._socket) {\n    this.readyState = WebSocket.CLOSING;\n\n    // End the connection\n    try { this._socket.end(); }\n    catch (e) {\n      // Socket error during end() call, so just destroy it right now\n      cleanupWebsocketResources.call(this, true);\n      return;\n    }\n\n    // Add a timeout to ensure that the connection is completely\n    // cleaned up within 30 seconds, even if the clean close procedure\n    // fails for whatever reason\n    // First cleanup any pre-existing timeout from an earlier \"terminate\" call,\n    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts\n    // and hold the program open for `closeTimout` time.\n    if (this._closeTimer) { clearTimeout(this._closeTimer); }\n    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);\n  } else if (this.readyState === WebSocket.CONNECTING) {\n    cleanupWebsocketResources.call(this, true);\n  }\n};\n\n/**\n * Expose bufferedAmount\n *\n * @api public\n */\nObject.defineProperty(WebSocket.prototype, 'bufferedAmount', {\n  get: function get() {\n    var amount = 0;\n    if (this._socket) {\n      amount = this._socket.bufferSize || 0;\n    }\n    return amount;\n  }\n});\n\n/**\n * Emulates the W3C Browser based WebSocket interface using function members.\n *\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\n['open', 'error', 'close', 'message'].forEach(function(method) {\n  Object.defineProperty(WebSocket.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    get: function get() {\n      var listener = this.listeners(method)[0];\n      return listener ? (listener._listener ? listener._listener : listener) : undefined;\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    set: function set(listener) {\n      this.removeAllListeners(method);\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nWebSocket.prototype.addEventListener = function(method, listener) {\n  var target = this;\n\n  function onMessage (data, flags) {\n    listener.call(target, new MessageEvent(data, flags.binary ? 'Binary' : 'Text', target));\n  }\n\n  function onClose (code, message) {\n    listener.call(target, new CloseEvent(code, message, target));\n  }\n\n  function onError (event) {\n    event.target = target;\n    listener.call(target, event);\n  }\n\n  function onOpen () {\n    listener.call(target, new OpenEvent(target));\n  }\n\n  if (typeof listener === 'function') {\n    if (method === 'message') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  }\n};\n\nmodule.exports = WebSocket;\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction MessageEvent(dataArg, typeArg, target) {\n  this.data = dataArg;\n  this.type = typeArg;\n  this.target = target;\n}\n\n/**\n * W3C CloseEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction CloseEvent(code, reason, target) {\n  this.wasClean = (typeof code === 'undefined' || code === 1000);\n  this.code = code;\n  this.reason = reason;\n  this.target = target;\n}\n\n/**\n * W3C OpenEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction OpenEvent(target) {\n  this.target = target;\n}\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\nfunction initAsServerClient(req, socket, upgradeHead, options) {\n  options = new Options({\n    protocolVersion: protocolVersion,\n    protocol: null,\n    extensions: {}\n  }).merge(options);\n\n  // expose state properties\n  this.protocol = options.value.protocol;\n  this.protocolVersion = options.value.protocolVersion;\n  this.extensions = options.value.extensions;\n  this.supports.binary = (this.protocolVersion !== 'hixie-76');\n  this.upgradeReq = req;\n  this.readyState = WebSocket.CONNECTING;\n  this._isServer = true;\n\n  // establish connection\n  if (options.value.protocolVersion === 'hixie-76') {\n    establishConnection.call(this, ReceiverHixie, SenderHixie, socket, upgradeHead);\n  } else {\n    establishConnection.call(this, Receiver, Sender, socket, upgradeHead);\n  }\n}\n\nfunction initAsClient(address, protocols, options) {\n  options = new Options({\n    origin: null,\n    protocolVersion: protocolVersion,\n    host: null,\n    headers: null,\n    protocol: protocols.join(','),\n    agent: null,\n\n    // ssl-related options\n    pfx: null,\n    key: null,\n    passphrase: null,\n    cert: null,\n    ca: null,\n    ciphers: null,\n    rejectUnauthorized: null,\n    perMessageDeflate: true\n  }).merge(options);\n\n  if (options.value.protocolVersion !== 8 && options.value.protocolVersion !== 13) {\n    throw new Error('unsupported protocol version');\n  }\n\n  // verify URL and establish http class\n  var serverUrl = url.parse(address);\n  var isUnixSocket = serverUrl.protocol === 'ws+unix:';\n  if (!serverUrl.host && !isUnixSocket) throw new Error('invalid url');\n  var isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  var httpObj = isSecure ? https : http;\n  var port = serverUrl.port || (isSecure ? 443 : 80);\n  var auth = serverUrl.auth;\n\n  // prepare extensions\n  var extensionsOffer = {};\n  var perMessageDeflate;\n  if (options.value.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(typeof options.value.perMessageDeflate !== true ? options.value.perMessageDeflate : {}, false);\n    extensionsOffer[PerMessageDeflate.extensionName] = perMessageDeflate.offer();\n  }\n\n  // expose state properties\n  this._isServer = false;\n  this.url = address;\n  this.protocolVersion = options.value.protocolVersion;\n  this.supports.binary = (this.protocolVersion !== 'hixie-76');\n\n  // begin handshake\n  var key = new Buffer(options.value.protocolVersion + '-' + Date.now()).toString('base64');\n  var shasum = crypto.createHash('sha1');\n  shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  var expectedServerKey = shasum.digest('base64');\n\n  var agent = options.value.agent;\n\n  var headerHost = serverUrl.hostname;\n  // Append port number to Host header, only if specified in the url\n  // and non-default\n  if (serverUrl.port) {\n    if ((isSecure && (port !== 443)) || (!isSecure && (port !== 80))){\n      headerHost = headerHost + ':' + port;\n    }\n  }\n\n  var requestOptions = {\n    port: port,\n    host: serverUrl.hostname,\n    headers: {\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket',\n      'Host': headerHost,\n      'Sec-WebSocket-Version': options.value.protocolVersion,\n      'Sec-WebSocket-Key': key\n    }\n  };\n\n  // If we have basic auth.\n  if (auth) {\n    requestOptions.headers.Authorization = 'Basic ' + new Buffer(auth).toString('base64');\n  }\n\n  if (options.value.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.value.protocol;\n  }\n\n  if (options.value.host) {\n    requestOptions.headers.Host = options.value.host;\n  }\n\n  if (options.value.headers) {\n    for (var header in options.value.headers) {\n       if (options.value.headers.hasOwnProperty(header)) {\n        requestOptions.headers[header] = options.value.headers[header];\n       }\n    }\n  }\n\n  if (Object.keys(extensionsOffer).length) {\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format(extensionsOffer);\n  }\n\n  if (options.isDefinedAndNonNull('pfx')\n   || options.isDefinedAndNonNull('key')\n   || options.isDefinedAndNonNull('passphrase')\n   || options.isDefinedAndNonNull('cert')\n   || options.isDefinedAndNonNull('ca')\n   || options.isDefinedAndNonNull('ciphers')\n   || options.isDefinedAndNonNull('rejectUnauthorized')) {\n\n    if (options.isDefinedAndNonNull('pfx')) requestOptions.pfx = options.value.pfx;\n    if (options.isDefinedAndNonNull('key')) requestOptions.key = options.value.key;\n    if (options.isDefinedAndNonNull('passphrase')) requestOptions.passphrase = options.value.passphrase;\n    if (options.isDefinedAndNonNull('cert')) requestOptions.cert = options.value.cert;\n    if (options.isDefinedAndNonNull('ca')) requestOptions.ca = options.value.ca;\n    if (options.isDefinedAndNonNull('ciphers')) requestOptions.ciphers = options.value.ciphers;\n    if (options.isDefinedAndNonNull('rejectUnauthorized')) requestOptions.rejectUnauthorized = options.value.rejectUnauthorized;\n\n    if (!agent) {\n        // global agent ignores client side certificates\n        agent = new httpObj.Agent(requestOptions);\n    }\n  }\n\n  requestOptions.path = serverUrl.path || '/';\n\n  if (agent) {\n    requestOptions.agent = agent;\n  }\n\n  if (isUnixSocket) {\n    requestOptions.socketPath = serverUrl.pathname;\n  }\n  if (options.value.origin) {\n    if (options.value.protocolVersion < 13) requestOptions.headers['Sec-WebSocket-Origin'] = options.value.origin;\n    else requestOptions.headers.Origin = options.value.origin;\n  }\n\n  var self = this;\n  var req = httpObj.request(requestOptions);\n\n  req.on('error', function onerror(error) {\n    self.emit('error', error);\n    cleanupWebsocketResources.call(self, error);\n  });\n\n  req.once('response', function response(res) {\n    var error;\n\n    if (!self.emit('unexpected-response', req, res)) {\n      error = new Error('unexpected server response (' + res.statusCode + ')');\n      req.abort();\n      self.emit('error', error);\n    }\n\n    cleanupWebsocketResources.call(self, error);\n  });\n\n  req.once('upgrade', function upgrade(res, socket, upgradeHead) {\n    if (self.readyState === WebSocket.CLOSED) {\n      // client closed before server accepted connection\n      self.emit('close');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverKey = res.headers['sec-websocket-accept'];\n    if (typeof serverKey === 'undefined' || serverKey !== expectedServerKey) {\n      self.emit('error', 'invalid server key');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protList = (options.value.protocol || \"\").split(/, */);\n    var protError = null;\n\n    if (!options.value.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.value.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      self.emit('error', protError);\n      self.removeAllListeners();\n      socket.end();\n      return;\n    } else if (serverProt) {\n      self.protocol = serverProt;\n    }\n\n    var serverExtensions = Extensions.parse(res.headers['sec-websocket-extensions']);\n    if (perMessageDeflate && serverExtensions[PerMessageDeflate.extensionName]) {\n      try {\n        perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        self.emit('error', 'invalid extension parameter');\n        self.removeAllListeners();\n        socket.end();\n        return;\n      }\n      self.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    establishConnection.call(self, Receiver, Sender, socket, upgradeHead);\n\n    // perform cleanup on http resources\n    req.removeAllListeners();\n    req = null;\n    agent = null;\n  });\n\n  req.end();\n  this.readyState = WebSocket.CONNECTING;\n}\n\nfunction establishConnection(ReceiverClass, SenderClass, socket, upgradeHead) {\n  var ultron = this._ultron = new Ultron(socket);\n  this._socket = socket;\n\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  var self = this;\n  this._receiver = new ReceiverClass(this.extensions);\n\n  // socket cleanup handlers\n  ultron.on('end', cleanupWebsocketResources.bind(this));\n  ultron.on('close', cleanupWebsocketResources.bind(this));\n  ultron.on('error', cleanupWebsocketResources.bind(this));\n\n  // ensure that the upgradeHead is added to the receiver\n  function firstHandler(data) {\n    if (self.readyState !== WebSocket.OPEN && self.readyState !== WebSocket.CLOSING) return;\n\n    if (upgradeHead && upgradeHead.length > 0) {\n      self.bytesReceived += upgradeHead.length;\n      var head = upgradeHead;\n      upgradeHead = null;\n      self._receiver.add(head);\n    }\n\n    dataHandler = realHandler;\n\n    if (data) {\n      self.bytesReceived += data.length;\n      self._receiver.add(data);\n    }\n  }\n\n  // subsequent packets are pushed straight to the receiver\n  function realHandler(data) {\n    if (data) self.bytesReceived += data.length;\n    self._receiver.add(data);\n  }\n\n  var dataHandler = firstHandler;\n\n  // if data was passed along with the http upgrade,\n  // this will schedule a push of that on to the receiver.\n  // this has to be done on next tick, since the caller\n  // hasn't had a chance to set event handlers on this client\n  // object yet.\n  process.nextTick(firstHandler);\n\n  // receiver event handlers\n  self._receiver.ontext = function ontext(data, flags) {\n    flags = flags || {};\n\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onbinary = function onbinary(data, flags) {\n    flags = flags || {};\n\n    flags.binary = true;\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onping = function onping(data, flags) {\n    flags = flags || {};\n\n    self.pong(data, {\n      mask: !self._isServer,\n      binary: flags.binary === true\n    }, true);\n\n    self.emit('ping', data, flags);\n  };\n\n  self._receiver.onpong = function onpong(data, flags) {\n    self.emit('pong', data, flags || {});\n  };\n\n  self._receiver.onclose = function onclose(code, data, flags) {\n    flags = flags || {};\n\n    self._closeReceived = true;\n    self.close(code, data);\n  };\n\n  self._receiver.onerror = function onerror(reason, errorCode) {\n    // close the connection when the receiver reports a HyBi error code\n    self.close(typeof errorCode !== 'undefined' ? errorCode : 1002, '');\n    self.emit('error', reason, errorCode);\n  };\n\n  // finalize the client\n  this._sender = new SenderClass(socket, this.extensions);\n  this._sender.on('error', function onerror(error) {\n    self.close(1002, '');\n    self.emit('error', error);\n  });\n\n  this.readyState = WebSocket.OPEN;\n  this.emit('open');\n\n  ultron.on('data', dataHandler);\n}\n\nfunction startQueue(instance) {\n  instance._queue = instance._queue || [];\n}\n\nfunction executeQueueSends(instance) {\n  var queue = instance._queue;\n  if (typeof queue === 'undefined') return;\n\n  delete instance._queue;\n  for (var i = 0, l = queue.length; i < l; ++i) {\n    queue[i]();\n  }\n}\n\nfunction sendStream(instance, stream, options, cb) {\n  stream.on('data', function incoming(data) {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));\n      else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = false;\n    instance._sender.send(data, options);\n  });\n\n  stream.on('end', function end() {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));\n      else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = true;\n    instance._sender.send(null, options);\n\n    if (typeof cb === 'function') cb(null);\n  });\n}\n\nfunction cleanupWebsocketResources(error) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  var emitClose = this.readyState !== WebSocket.CONNECTING;\n  this.readyState = WebSocket.CLOSED;\n\n  clearTimeout(this._closeTimer);\n  this._closeTimer = null;\n\n  if (emitClose) {\n    this.emit('close', this._closeCode || 1000, this._closeMessage || '');\n  }\n\n  if (this._socket) {\n    if (this._ultron) this._ultron.destroy();\n    this._socket.on('error', function onerror() {\n      try { this.destroy(); }\n      catch (e) {}\n    });\n\n    try {\n      if (!error) this._socket.end();\n      else this._socket.destroy();\n    } catch (e) { /* Ignore termination errors */ }\n\n    this._socket = null;\n    this._ultron = null;\n  }\n\n  if (this._sender) {\n    this._sender.removeAllListeners();\n    this._sender = null;\n  }\n\n  if (this._receiver) {\n    this._receiver.cleanup();\n    this._receiver = null;\n  }\n\n  this.removeAllListeners();\n  this.on('error', function onerror() {}); // catch all errors after this\n  delete this._queue;\n}\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar ConnectionImpl = (function () {\r\n    function ConnectionImpl(settings) {\r\n        this.messageHandlers = {};\r\n        this.ids = 1;\r\n        this.registry = callback_registry_1.default();\r\n        this._connected = false;\r\n        this._settings = settings;\r\n        this._logger = settings.logger;\r\n    }\r\n    ConnectionImpl.prototype.init = function (transport, protocol) {\r\n        this._protocol = protocol;\r\n        this._transport = transport;\r\n        this._transport.onConnectedChanged(this.handleConnectionChanged.bind(this));\r\n        this._transport.onMessage(this.handleTransportMessage.bind(this));\r\n    };\r\n    ConnectionImpl.prototype.send = function (product, type, message, id, options) {\r\n        if (this._transport.isObjectBasedTransport) {\r\n            var msg = this._protocol.createObjectMessage(product, type, message, id);\r\n            return this._transport.sendObject(msg, product, type, options);\r\n        }\r\n        else {\r\n            var strMessage = this._protocol.createStringMessage(product, type, message, id);\r\n            return this._transport.send(strMessage, product, type, options);\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.on = function (product, type, messageHandler) {\r\n        type = type.toLowerCase();\r\n        if (this.messageHandlers[type] === undefined) {\r\n            this.messageHandlers[type] = {};\r\n        }\r\n        var id = this.ids++;\r\n        this.messageHandlers[type][id] = messageHandler;\r\n        return {\r\n            type: type,\r\n            id: id,\r\n        };\r\n    };\r\n    ConnectionImpl.prototype.off = function (info) {\r\n        delete this.messageHandlers[info.type.toLowerCase()][info.id];\r\n    };\r\n    Object.defineProperty(ConnectionImpl.prototype, \"isConnected\", {\r\n        get: function () {\r\n            return this._connected;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ConnectionImpl.prototype.connected = function (callback) {\r\n        if (this._connected) {\r\n            callback(this._settings.ws || this._settings.http);\r\n        }\r\n        return this.registry.add(\"connected\", callback);\r\n    };\r\n    ConnectionImpl.prototype.disconnected = function (callback) {\r\n        return this.registry.add(\"disconnected\", callback);\r\n    };\r\n    ConnectionImpl.prototype.login = function (authRequest) {\r\n        this._transport.open();\r\n        return this._protocol.login(authRequest);\r\n    };\r\n    ConnectionImpl.prototype.logout = function () {\r\n        this._protocol.logout();\r\n        this._transport.close();\r\n    };\r\n    ConnectionImpl.prototype.loggedIn = function (callback) {\r\n        return this._protocol.loggedIn(callback);\r\n    };\r\n    Object.defineProperty(ConnectionImpl.prototype, \"protocolVersion\", {\r\n        get: function () {\r\n            return this._settings.protocolVersion || 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ConnectionImpl.prototype.toAPI = function () {\r\n        var that = this;\r\n        return {\r\n            send: that.send.bind(that),\r\n            on: that.on.bind(that),\r\n            off: that.off.bind(that),\r\n            login: that.login.bind(that),\r\n            logout: that.logout.bind(that),\r\n            loggedIn: that.loggedIn.bind(that),\r\n            connected: that.connected.bind(that),\r\n            disconnected: that.disconnected.bind(that),\r\n            get protocolVersion() {\r\n                return that.protocolVersion;\r\n            }\r\n        };\r\n    };\r\n    ConnectionImpl.prototype.distributeMessage = function (message, type) {\r\n        var _this = this;\r\n        var handlers = this.messageHandlers[type.toLowerCase()];\r\n        if (handlers !== undefined) {\r\n            Object.keys(handlers).forEach(function (handlerId) {\r\n                var handler = handlers[handlerId];\r\n                if (handler !== undefined) {\r\n                    try {\r\n                        handler(message);\r\n                    }\r\n                    catch (error) {\r\n                        _this._logger.error(\"Message handler failed with \" + error.stack);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.handleConnectionChanged = function (connected) {\r\n        if (this._connected === connected) {\r\n            return;\r\n        }\r\n        this._connected = connected;\r\n        if (connected) {\r\n            this.registry.execute(\"connected\");\r\n        }\r\n        else {\r\n            this.registry.execute(\"disconnected\");\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.handleTransportMessage = function (msg) {\r\n        var msgObj;\r\n        if (typeof msg === \"string\") {\r\n            msgObj = this._protocol.processStringMessage(msg);\r\n        }\r\n        else {\r\n            msgObj = this._protocol.processObjectMessage(msg);\r\n        }\r\n        this.distributeMessage(msgObj.msg, msgObj.msgType);\r\n    };\r\n    return ConnectionImpl;\r\n}());\r\nexports.default = ConnectionImpl;\r\n//# sourceMappingURL=connection.js.map\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GW_MESSAGE_CREATE_CONTEXT = \"create-context\";\r\nexports.GW_MESSAGE_ACTIVITY_CREATED = \"created\";\r\nexports.GW_MESSAGE_ACTIVITY_DESTROYED = \"destroyed\";\r\nexports.GW_MESSAGE_CONTEXT_CREATED = \"context-created\";\r\nexports.GW_MESSAGE_CONTEXT_ADDED = \"context-added\";\r\nexports.GW_MESSAGE_SUBSCRIBE_CONTEXT = \"subscribe-context\";\r\nexports.GW_MESSAGE_SUBSCRIBED_CONTEXT = \"subscribed-context\";\r\nexports.GW_MESSAGE_UNSUBSCRIBE_CONTEXT = \"unsubscribe-context\";\r\nexports.GW_MESSAGE_DESTROY_CONTEXT = \"destroy-context\";\r\nexports.GW_MESSAGE_CONTEXT_DESTROYED = \"context-destroyed\";\r\nexports.GW_MESSAGE_UPDATE_CONTEXT = \"update-context\";\r\nexports.GW_MESSAGE_CONTEXT_UPDATED = \"context-updated\";\r\nexports.GW_MESSAGE_JOINED_ACTIVITY = \"joined\";\r\n//# sourceMappingURL=gw3Messages.js.map\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection = {\r\n    protocolVersion: -1,\r\n    send: function (product, type, message, id, options) {\r\n        return Promise.resolve(undefined);\r\n    },\r\n    on: function (product, type, messageHandler) {\r\n        return { type: \"1\", id: 1 };\r\n    },\r\n    off: function (info) {\r\n    },\r\n    login: function (message) {\r\n        return undefined;\r\n    },\r\n    logout: function () {\r\n    },\r\n    loggedIn: function (callback) {\r\n        return undefined;\r\n    },\r\n    connected: function (callback) {\r\n        return undefined;\r\n    },\r\n    disconnected: function (callback) {\r\n        return undefined;\r\n    },\r\n};\r\nexports.default = connection;\r\n//# sourceMappingURL=dummyConnection.js.map\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"http\");\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"url\");\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar main_1 = __webpack_require__(109);\r\nvar main_2 = __webpack_require__(77);\r\nvar main_3 = __webpack_require__(94);\r\nvar main_4 = __webpack_require__(55);\r\nvar main_5 = __webpack_require__(72);\r\nvar config_1 = __webpack_require__(75);\r\nvar dummyConnection_1 = __webpack_require__(25);\r\nvar timer_1 = __webpack_require__(112);\r\nvar utils_1 = __webpack_require__(13);\r\nvar dummyConnection_2 = __webpack_require__(25);\r\nvar main_6 = __webpack_require__(91);\r\nvar contextMessageReplaySpec_1 = __webpack_require__(12);\r\nvar GlueCore = function (userConfig, ext) {\r\n    var gdVersion = -1;\r\n    var hc;\r\n    var glue42gd;\r\n    if (typeof window !== \"undefined\") {\r\n        gdVersion = utils_1.default.getGDMajorVersion();\r\n        if (gdVersion === 2) {\r\n            hc = window.htmlContainer;\r\n        }\r\n        else if (gdVersion >= 3) {\r\n            glue42gd = window.glue42gd;\r\n        }\r\n    }\r\n    var glueInitTimer = timer_1.default();\r\n    userConfig = userConfig || {};\r\n    ext = ext || {};\r\n    var internalConfig = config_1.default(userConfig, ext, hc, glue42gd, gdVersion);\r\n    var _connection;\r\n    var _agm;\r\n    var _logger;\r\n    var _rootMetrics;\r\n    var _metrics;\r\n    var _contexts;\r\n    var _bus;\r\n    var libs = {};\r\n    function registerLib(name, inner, t) {\r\n        inner.initStartTime = t.startTime;\r\n        if (inner.ready) {\r\n            inner.ready().then(function () {\r\n                inner.initTime = t.stop();\r\n                inner.initEndTime = t.endTime;\r\n            });\r\n        }\r\n        else {\r\n            inner.initTime = t.stop();\r\n            inner.initEndTime = t.endTime;\r\n        }\r\n        libs[name] = inner;\r\n        GlueCore[name] = inner;\r\n    }\r\n    function setupConnection() {\r\n        var initTimer = timer_1.default();\r\n        internalConfig.connection.logger = _logger.subLogger(\"connection\");\r\n        _connection = main_2.default(internalConfig.connection);\r\n        var authPromise = Promise.resolve(internalConfig.auth);\r\n        if (internalConfig.connection && !internalConfig.auth) {\r\n            var protocolVersion = internalConfig.connection.protocolVersion;\r\n            if (!protocolVersion || protocolVersion === 1) {\r\n                registerLib(\"connection\", _connection, initTimer);\r\n                return Promise.resolve({});\r\n            }\r\n            if (protocolVersion === 2) {\r\n                return Promise.reject(\"You need to provide auth information\");\r\n            }\r\n            if (protocolVersion === 3) {\r\n                if (glue42gd) {\r\n                    authPromise = glue42gd.getGWToken().then(function (token) {\r\n                        return {\r\n                            gatewayToken: token\r\n                        };\r\n                    });\r\n                }\r\n                else {\r\n                    authPromise = Promise.reject(\"You need to provide auth information\");\r\n                }\r\n            }\r\n        }\r\n        return authPromise\r\n            .then(function (authConfig) {\r\n            var authRequest;\r\n            if (typeof authConfig === \"string\" || typeof authConfig === \"number\") {\r\n                authRequest = {\r\n                    token: authConfig\r\n                };\r\n            }\r\n            else if (Object.prototype.toString.call(authConfig) === \"[object Object]\") {\r\n                authRequest = authConfig;\r\n            }\r\n            else {\r\n                throw new Error(\"Invalid auth object - \" + JSON.stringify(authConfig));\r\n            }\r\n            return authRequest;\r\n        })\r\n            .then(function (authRequest) {\r\n            return _connection.login(authRequest);\r\n        })\r\n            .then(function (identity) {\r\n            if (identity) {\r\n                if (identity.machine) {\r\n                    internalConfig.agm.instance.machine = identity.machine;\r\n                }\r\n                if (identity.user) {\r\n                    internalConfig.agm.instance.user = identity.user;\r\n                }\r\n            }\r\n            registerLib(\"connection\", _connection, initTimer);\r\n            return internalConfig;\r\n        })\r\n            .catch(function (e) {\r\n            if (_connection) {\r\n                _connection.logout();\r\n            }\r\n            throw e;\r\n        });\r\n    }\r\n    function setupLogger() {\r\n        var initTimer = timer_1.default();\r\n        var loggerConfig = {\r\n            identity: internalConfig.identity,\r\n            getConnection: function () {\r\n                return _connection || dummyConnection_1.default;\r\n            },\r\n            publish: internalConfig.logger.publish || \"off\",\r\n            console: internalConfig.logger.console || \"info\",\r\n            metrics: (internalConfig.metrics && internalConfig.logger.metrics) || \"off\"\r\n        };\r\n        _logger = main_3.default(loggerConfig);\r\n        registerLib(\"logger\", _logger, initTimer);\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupMetrics() {\r\n        if (internalConfig.metrics) {\r\n            var initTimer = timer_1.default();\r\n            _rootMetrics = main_1.default({\r\n                identity: internalConfig.metrics.identity,\r\n                connection: internalConfig.metrics ? _connection : dummyConnection_1.default,\r\n                logger: _logger.subLogger(\"metrics\")\r\n            });\r\n            _metrics = _rootMetrics.subSystem(\"App\");\r\n            var reportingSystem_1 = _metrics.subSystem(\"reporting\");\r\n            var def_1 = {\r\n                name: \"features\",\r\n                conflation: 1,\r\n            };\r\n            var _featureMetric_1;\r\n            _metrics.featureMetric = function (name, action, payload) {\r\n                if (typeof name === \"undefined\" || name === \"\") {\r\n                    throw new Error(\"name is mandatory\");\r\n                }\r\n                else if (typeof action === \"undefined\" || action === \"\") {\r\n                    throw new Error(\"action is mandatory\");\r\n                }\r\n                else if (typeof payload === \"undefined\" || payload === \"\") {\r\n                    throw new Error(\"payload is mandatory\");\r\n                }\r\n                if (!_featureMetric_1) {\r\n                    _featureMetric_1 = reportingSystem_1.objectMetric(def_1, { name: name, action: action, payload: payload });\r\n                }\r\n                else {\r\n                    _featureMetric_1.update({\r\n                        name: name,\r\n                        action: action,\r\n                        payload: payload\r\n                    });\r\n                }\r\n            };\r\n            _logger.metricsLevel(\"warn\", _metrics.parent.subSystem(\"LogEvents\"));\r\n            registerLib(\"metrics\", _metrics, initTimer);\r\n        }\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupAGM() {\r\n        var initTimer = timer_1.default();\r\n        var agmConfig = {\r\n            instance: internalConfig.agm.instance,\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"agm\"),\r\n            forceGW: internalConfig.connection && internalConfig.connection.force,\r\n            gdVersion: gdVersion,\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            main_4.default(agmConfig)\r\n                .then(function (agmLib) {\r\n                _agm = agmLib;\r\n                registerLib(\"agm\", _agm, initTimer);\r\n                resolve(internalConfig);\r\n            })\r\n                .catch(function (err) {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    function setupContexts() {\r\n        var hasActivities = (internalConfig.activities && dummyConnection_2.default.protocolVersion === 3);\r\n        var needsContexts = internalConfig.contexts || hasActivities;\r\n        if (needsContexts) {\r\n            var initTimer = timer_1.default();\r\n            _contexts = new main_6.ContextsModule({\r\n                connection: _connection,\r\n                logger: _logger.subLogger(\"contexts\"),\r\n                gdMajorVersion: gdVersion\r\n            });\r\n            registerLib(\"contexts\", _contexts, initTimer);\r\n            return _contexts;\r\n        }\r\n        else {\r\n            var replayer = dummyConnection_2.default.replayer;\r\n            if (replayer) {\r\n                replayer.drain(contextMessageReplaySpec_1.ContextMessageReplaySpec.name, null);\r\n            }\r\n        }\r\n    }\r\n    function setupExternalLibs(externalLibs) {\r\n        try {\r\n            externalLibs.forEach(function (lib) {\r\n                setupExternalLib(lib.name, lib.create);\r\n            });\r\n            return Promise.resolve();\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    function setupExternalLib(name, createCallback) {\r\n        var initTimer = timer_1.default();\r\n        var lib = createCallback(libs);\r\n        if (lib) {\r\n            registerLib(name, lib, initTimer);\r\n        }\r\n    }\r\n    function waitForLibs() {\r\n        var libsReadyPromises = Object.keys(libs).map(function (key) {\r\n            var lib = libs[key];\r\n            return lib.ready ?\r\n                lib.ready() : Promise.resolve();\r\n        });\r\n        return Promise.all(libsReadyPromises);\r\n    }\r\n    function constructGlueObject() {\r\n        var feedbackFunc = function () {\r\n            if (!_agm) {\r\n                return;\r\n            }\r\n            _agm.invoke(\"T42.ACS.Feedback\", {}, \"best\");\r\n        };\r\n        var info = { glueVersion: internalConfig.version };\r\n        glueInitTimer.stop();\r\n        var glue = {\r\n            feedback: feedbackFunc,\r\n            info: info,\r\n            version: internalConfig.version,\r\n            userConfig: userConfig,\r\n            done: function () {\r\n                _connection.logout();\r\n                return Promise.resolve();\r\n            }\r\n        };\r\n        glue.performance = {\r\n            get browser() {\r\n                return window.performance.timing.toJSON();\r\n            },\r\n            get memory() {\r\n                return window.performance.memory;\r\n            },\r\n            get initTimes() {\r\n                var result = Object.keys(glue)\r\n                    .filter(function (key) {\r\n                    if (key === \"initTimes\") {\r\n                        return false;\r\n                    }\r\n                    return glue[key].initTime;\r\n                })\r\n                    .map(function (key) {\r\n                    return {\r\n                        name: key,\r\n                        time: glue[key].initTime,\r\n                        startTime: glue[key].initStartTime,\r\n                        endTime: glue[key].initEndTime\r\n                    };\r\n                });\r\n                result.push({\r\n                    name: \"glue\",\r\n                    startTime: glueInitTimer.startTime,\r\n                    endTime: glueInitTimer.endTime,\r\n                    time: glueInitTimer.period\r\n                });\r\n                return result;\r\n            }\r\n        };\r\n        Object.keys(libs).forEach(function (key) {\r\n            var lib = libs[key];\r\n            glue[key] = lib;\r\n            info[key] = lib.version;\r\n        });\r\n        if (hc && hc.perfDataNeeded && hc.updatePerfData) {\r\n            var delay = hc.perfDataDelay || 100;\r\n            setTimeout(function () {\r\n                hc.updatePerfData(glue.performance);\r\n            }, delay);\r\n        }\r\n        if (glue42gd && glue42gd.updatePerfData) {\r\n            glue42gd.updatePerfData(glue.performance);\r\n        }\r\n        glue.config = {};\r\n        if (ext.enrichGlue) {\r\n            ext.enrichGlue(glue);\r\n        }\r\n        Object.keys(internalConfig).forEach(function (k) {\r\n            glue.config[k] = internalConfig[k];\r\n        });\r\n        if (ext.extOptions) {\r\n            Object.keys(ext.extOptions).forEach(function (k) {\r\n                glue.config[k] = ext.extOptions[k];\r\n            });\r\n        }\r\n        return glue;\r\n    }\r\n    function setupBus() {\r\n        if (!internalConfig.bus) {\r\n            return Promise.resolve(undefined);\r\n        }\r\n        var initTimer = timer_1.default();\r\n        var busSettings = {\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"bus\")\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            main_5.default(busSettings)\r\n                .then(function (busLib) {\r\n                _bus = busLib;\r\n                registerLib(\"bus\", _bus, initTimer);\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    return setupLogger()\r\n        .then(setupConnection)\r\n        .then(function () { return Promise.all([setupMetrics(), setupAGM(), setupContexts(), setupBus()]); })\r\n        .then(function () {\r\n        return setupExternalLibs(internalConfig.libs || []);\r\n    })\r\n        .then(waitForLibs)\r\n        .then(constructGlueObject)\r\n        .catch(function (err) {\r\n        return Promise.reject({\r\n            err: err,\r\n            libs: libs\r\n        });\r\n    });\r\n};\r\nexports.default = GlueCore;\r\n//# sourceMappingURL=glue.js.map\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n/**\n * Secure random string generator with custom alphabet.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * @param {generator} random The random bytes generator.\n * @param {string} alphabet Symbols to be used in new random string.\n * @param {size} size The number of symbols in new random string.\n *\n * @return {string} Random string.\n *\n * @example\n * const format = require('nanoid/format')\n *\n * function random (size) {\n *   const result = []\n *   for (let i = 0; i < size; i++) {\n *     result.push(randomByte())\n *   }\n *   return result\n * }\n *\n * format(random, \"abcdef\", 5) //=> \"fbaef\"\n *\n * @name format\n * @function\n */\nmodule.exports = function (random, alphabet, size) {\n  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1\n  var step = Math.ceil(1.6 * mask * size / alphabet.length)\n\n  var id = ''\n  while (true) {\n    var bytes = random(step)\n    for (var i = 0; i < step; i++) {\n      var byte = bytes[i] & mask\n      if (alphabet[byte]) {\n        id += alphabet[byte]\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\n/**\n * @callback generator\n * @param {number} bytes The number of bytes to generate.\n * @return {number[]} Random bytes.\n */\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar crypto = __webpack_require__(14)\n\nif (crypto.randomFillSync) {\n  var buffers = { }\n  module.exports = function (bytes) {\n    var buffer = buffers[bytes]\n    if (!buffer) {\n      buffer = Buffer.allocUnsafe(bytes)\n      if (bytes <= 255) buffers[bytes] = buffer\n    }\n    return crypto.randomFillSync(buffer)\n  }\n} else {\n  module.exports = crypto.randomBytes\n}\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar generate = __webpack_require__(32);\nvar alphabet = __webpack_require__(5);\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction build(clusterWorkerId) {\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + generate(version);\n    str = str + generate(clusterWorkerId);\n    if (counter > 0) {\n        str = str + generate(counter);\n    }\n    str = str + generate(seconds);\n    return str;\n}\n\nmodule.exports = build;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar alphabet = __webpack_require__(5);\nvar random = __webpack_require__(35);\nvar format = __webpack_require__(29);\n\nfunction generate(number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + format(random, alphabet.get(), 1);\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = generate;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar alphabet = __webpack_require__(5);\nvar build = __webpack_require__(31);\nvar isValid = __webpack_require__(34);\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = __webpack_require__(37) || 0;\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n  return build(clusterWorkerId);\n}\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.isValid = isValid;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar alphabet = __webpack_require__(5);\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var nonAlphabetic = new RegExp('[^' +\n      alphabet.get().replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&') +\n    ']');\n    return !nonAlphabetic.test(id);\n}\n\nmodule.exports = isShortId;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(30);\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar cluster = __webpack_require__(113);\n\nvar clusterId = 0;\nif (!cluster.isMaster && cluster.worker) {\n    clusterId = cluster.worker.id;\n}\nmodule.exports = parseInt(__webpack_require__.i({\"NODE_ENV\":\"production\"}).NODE_UNIQUE_ID || clusterId, 10);\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments\n    , event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    args = [];\n\n    for (event in this.ee._events) {\n      if (has.call(this.ee._events, event)) args.push(event);\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = this.ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n        delete event.listener.__ultron;\n      } else {\n        if (event.__ultron !== this.id) continue;\n        delete event.__ultron;\n      }\n\n      this.ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n\n  this.remove();\n  this.ee = null;\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar WS = module.exports = __webpack_require__(22);\n\nWS.Server = __webpack_require__(46);\nWS.Sender = __webpack_require__(21);\nWS.Receiver = __webpack_require__(20);\n\n/**\n * Create a new WebSocket server.\n *\n * @param {Object} options Server options\n * @param {Function} fn Optional connection listener.\n * @returns {WS.Server}\n * @api public\n */\nWS.createServer = function createServer(options, fn) {\n  var server = new WS.Server(options);\n\n  if (typeof fn === 'function') {\n    server.on('connection', fn);\n  }\n\n  return server;\n};\n\n/**\n * Create a new WebSocket connection.\n *\n * @param {String} address The URL/address we need to connect to.\n * @param {Function} fn Open listener.\n * @returns {WS}\n * @api public\n */\nWS.connect = WS.createConnection = function connect(address, fn) {\n  var client = new WS(address);\n\n  if (typeof fn === 'function') {\n    client.on('open', fn);\n  }\n\n  return client;\n};\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = __webpack_require__(3);\n\nfunction BufferPool(initialSize, growStrategy, shrinkStrategy) {\n  if (typeof initialSize === 'function') {\n    shrinkStrategy = growStrategy;\n    growStrategy = initialSize;\n    initialSize = 0;\n  }\n  else if (typeof initialSize === 'undefined') {\n    initialSize = 0;\n  }\n  this._growStrategy = (growStrategy || function(db, size) {\n    return db.used + size;\n  }).bind(null, this);\n  this._shrinkStrategy = (shrinkStrategy || function(db) {\n    return initialSize;\n  }).bind(null, this);\n  this._buffer = initialSize ? new Buffer(initialSize) : null;\n  this._offset = 0;\n  this._used = 0;\n  this._changeFactor = 0;\n  this.__defineGetter__('size', function(){\n    return this._buffer == null ? 0 : this._buffer.length;\n  });\n  this.__defineGetter__('used', function(){\n    return this._used;\n  });\n}\n\nBufferPool.prototype.get = function(length) {\n  if (this._buffer == null || this._offset + length > this._buffer.length) {\n    var newBuf = new Buffer(this._growStrategy(length));\n    this._buffer = newBuf;\n    this._offset = 0;\n  }\n  this._used += length;\n  var buf = this._buffer.slice(this._offset, this._offset + length);\n  this._offset += length;\n  return buf;\n}\n\nBufferPool.prototype.reset = function(forceNewBuffer) {\n  var len = this._shrinkStrategy();\n  if (len < this.size) this._changeFactor -= 1;\n  if (forceNewBuffer || this._changeFactor < -2) {\n    this._changeFactor = 0;\n    this._buffer = len ? new Buffer(len) : null;\n  }\n  this._offset = 0;\n  this._used = 0;\n}\n\nmodule.exports = BufferPool;\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports.BufferUtil = {\n  merge: function(mergedBuffer, buffers) {\n    var offset = 0;\n    for (var i = 0, l = buffers.length; i < l; ++i) {\n      var buf = buffers[i];\n      buf.copy(mergedBuffer, offset);\n      offset += buf.length;\n    }\n  },\n  mask: function(source, mask, output, offset, length) {\n    var maskNum = mask.readUInt32LE(0, true);\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ source.readUInt32LE(i, true);\n      if (num < 0) num = 4294967296 + num;\n      output.writeUInt32LE(num, offset + i, true);\n    }\n    switch (length % 4) {\n      case 3: output[offset + i + 2] = source[i + 2] ^ mask[2];\n      case 2: output[offset + i + 1] = source[i + 1] ^ mask[1];\n      case 1: output[offset + i] = source[i] ^ mask[0];\n      case 0:;\n    }\n  },\n  unmask: function(data, mask) {\n    var maskNum = mask.readUInt32LE(0, true);\n    var length = data.length;\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ data.readUInt32LE(i, true);\n      if (num < 0) num = 4294967296 + num;\n      data.writeUInt32LE(num, i, true);\n    }\n    switch (length % 4) {\n      case 3: data[i + 2] = data[i + 2] ^ mask[2];\n      case 2: data[i + 1] = data[i + 1] ^ mask[1];\n      case 1: data[i] = data[i] ^ mask[0];\n      case 0:;\n    }\n  }\n}\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = __webpack_require__(3);\n\n/**\n * State constants\n */\n\nvar EMPTY = 0\n  , BODY = 1;\nvar BINARYLENGTH = 2\n  , BINARYBODY = 3;\n\n/**\n * Hixie Receiver implementation\n */\n\nfunction Receiver () {\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n  this.dead = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  var self = this;\n  function doAdd() {\n    if (self.state === EMPTY) {\n      if (data.length == 2 && data[0] == 0xFF && data[1] == 0x00) {\n        self.reset();\n        self.onclose();\n        return;\n      }\n      if (data[0] === 0x80) {\n        self.messageEnd = 0;\n        self.state = BINARYLENGTH;\n        data = data.slice(1);\n      } else {\n\n      if (data[0] !== 0x00) {\n        self.error('payload must start with 0x00 byte', true);\n        return;\n      }\n      data = data.slice(1);\n      self.state = BODY;\n\n      }\n    }\n    if (self.state === BINARYLENGTH) {\n      var i = 0;\n      while ((i < data.length) && (data[i] & 0x80)) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        ++i;\n      }\n      if (i < data.length) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        self.state = BINARYBODY;\n        ++i;\n      }\n      if (i > 0)\n        data = data.slice(i);\n    }\n    if (self.state === BINARYBODY) {\n      var dataleft = self.messageEnd - self.spanLength;\n      if (data.length >= dataleft) {\n        // consume the whole buffer to finish the frame\n        self.buffers.push(data);\n        self.spanLength += dataleft;\n        self.messageEnd = dataleft;\n        return self.parse();\n      }\n      // frame's not done even if we consume it all\n      self.buffers.push(data);\n      self.spanLength += data.length;\n      return;\n    }\n    self.buffers.push(data);\n    if ((self.messageEnd = bufferIndex(data, 0xFF)) != -1) {\n      self.spanLength += self.messageEnd;\n      return self.parse();\n    }\n    else self.spanLength += data.length;\n  }\n  while(data) data = doAdd();\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.state = EMPTY;\n  this.buffers = [];\n};\n\n/**\n * Process buffered data.\n *\n * @api public\n */\n\nReceiver.prototype.parse = function() {\n  var output = new Buffer(this.spanLength);\n  var outputIndex = 0;\n  for (var bi = 0, bl = this.buffers.length; bi < bl - 1; ++bi) {\n    var buffer = this.buffers[bi];\n    buffer.copy(output, outputIndex);\n    outputIndex += buffer.length;\n  }\n  var lastBuffer = this.buffers[this.buffers.length - 1];\n  if (this.messageEnd > 0) lastBuffer.copy(output, outputIndex, 0, this.messageEnd);\n  if (this.state !== BODY) --this.messageEnd;\n  var tail = null;\n  if (this.messageEnd < lastBuffer.length - 1) {\n    tail = lastBuffer.slice(this.messageEnd + 1);\n  }\n  this.reset();\n  this.ontext(output.toString('utf8'));\n  return tail;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, terminate) {\n  this.reset();\n  this.onerror(reason, terminate);\n  return this;\n};\n\n/**\n * Reset parser state\n *\n * @api private\n */\n\nReceiver.prototype.reset = function (reason) {\n  if (this.dead) return;\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n};\n\n/**\n * Internal api\n */\n\nfunction bufferIndex(buffer, byte) {\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    if (buffer[i] === byte) return i;\n  }\n  return -1;\n}\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = __webpack_require__(8)\n  , util = __webpack_require__(3)\n  , EventEmitter = events.EventEmitter;\n\n/**\n * Hixie Sender implementation\n */\n\nfunction Sender(socket) {\n  events.EventEmitter.call(this);\n\n  this.socket = socket;\n  this.continuationFrame = false;\n  this.isClosed = false;\n}\n\nmodule.exports = Sender;\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Frames and writes data.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  if (this.isClosed) return;\n\n  var isString = typeof data == 'string'\n    , length = isString ? Buffer.byteLength(data) : data.length\n    , lengthbytes = (length > 127) ? 2 : 1 // assume less than 2**14 bytes\n    , writeStartMarker = this.continuationFrame == false\n    , writeEndMarker = !options || !(typeof options.fin != 'undefined' && !options.fin)\n    , buffer = new Buffer((writeStartMarker ? ((options && options.binary) ? (1 + lengthbytes) : 1) : 0) + length + ((writeEndMarker && !(options && options.binary)) ? 1 : 0))\n    , offset = writeStartMarker ? 1 : 0;\n\n  if (writeStartMarker) {\n    if (options && options.binary) {\n      buffer.write('\\x80', 'binary');\n      // assume length less than 2**14 bytes\n      if (lengthbytes > 1)\n        buffer.write(String.fromCharCode(128+length/128), offset++, 'binary');\n      buffer.write(String.fromCharCode(length&0x7f), offset++, 'binary');\n    } else\n      buffer.write('\\x00', 'binary');\n  }\n\n  if (isString) buffer.write(data, offset, 'utf8');\n  else data.copy(buffer, offset, 0);\n\n  if (writeEndMarker) {\n    if (options && options.binary) {\n      // sending binary, not writing end marker\n    } else\n      buffer.write('\\xff', offset + length, 'binary');\n    this.continuationFrame = false;\n  }\n  else this.continuationFrame = true;\n\n  try {\n    this.socket.write(buffer, 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (this.isClosed) return;\n  this.isClosed = true;\n  try {\n    if (this.continuationFrame) this.socket.write(new Buffer([0xff], 'binary'));\n    this.socket.write(new Buffer([0xff, 0x00]), 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a ping message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {};\n\n/**\n * Sends a pong message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nSender.prototype.error = function (reason) {\n  this.emit('error', reason);\n  return this;\n};\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n \nmodule.exports.Validation = {\n  isValidUTF8: function(buffer) {\n    return true;\n  }\n};\n\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"utf-8-validate\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (e) {\n  module.exports = __webpack_require__(44);\n}\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = __webpack_require__(3)\n  , events = __webpack_require__(8)\n  , http = __webpack_require__(26)\n  , crypto = __webpack_require__(14)\n  , Options = __webpack_require__(16)\n  , WebSocket = __webpack_require__(22)\n  , Extensions = __webpack_require__(19)\n  , PerMessageDeflate = __webpack_require__(6)\n  , tls = __webpack_require__(117)\n  , url = __webpack_require__(27);\n\n/**\n * WebSocket Server implementation\n */\n\nfunction WebSocketServer(options, callback) {\n  events.EventEmitter.call(this);\n\n  options = new Options({\n    host: '0.0.0.0',\n    port: null,\n    server: null,\n    verifyClient: null,\n    handleProtocols: null,\n    path: null,\n    noServer: false,\n    disableHixie: false,\n    clientTracking: true,\n    perMessageDeflate: true\n  }).merge(options);\n\n  if (!options.isDefinedAndNonNull('port') && !options.isDefinedAndNonNull('server') && !options.value.noServer) {\n    throw new TypeError('`port` or a `server` must be provided');\n  }\n\n  var self = this;\n\n  if (options.isDefinedAndNonNull('port')) {\n    this._server = http.createServer(function (req, res) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Not implemented');\n    });\n    this._server.listen(options.value.port, options.value.host, callback);\n    this._closeServer = function() { if (self._server) self._server.close(); };\n  }\n  else if (options.value.server) {\n    this._server = options.value.server;\n    if (options.value.path) {\n      // take note of the path, to avoid collisions when multiple websocket servers are\n      // listening on the same http server\n      if (this._server._webSocketPaths && options.value.server._webSocketPaths[options.value.path]) {\n        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');\n      }\n      if (typeof this._server._webSocketPaths !== 'object') {\n        this._server._webSocketPaths = {};\n      }\n      this._server._webSocketPaths[options.value.path] = 1;\n    }\n  }\n  if (this._server) this._server.once('listening', function() { self.emit('listening'); });\n\n  if (typeof this._server != 'undefined') {\n    this._server.on('error', function(error) {\n      self.emit('error', error)\n    });\n    this._server.on('upgrade', function(req, socket, upgradeHead) {\n      //copy upgradeHead to avoid retention of large slab buffers used in node core\n      var head = new Buffer(upgradeHead.length);\n      upgradeHead.copy(head);\n\n      self.handleUpgrade(req, socket, head, function(client) {\n        self.emit('connection'+req.url, client);\n        self.emit('connection', client);\n      });\n    });\n  }\n\n  this.options = options.value;\n  this.path = options.value.path;\n  this.clients = [];\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(WebSocketServer, events.EventEmitter);\n\n/**\n * Immediately shuts down the connection.\n *\n * @api public\n */\n\nWebSocketServer.prototype.close = function() {\n  // terminate all associated clients\n  var error = null;\n  try {\n    for (var i = 0, l = this.clients.length; i < l; ++i) {\n      this.clients[i].terminate();\n    }\n  }\n  catch (e) {\n    error = e;\n  }\n\n  // remove path descriptor, if any\n  if (this.path && this._server._webSocketPaths) {\n    delete this._server._webSocketPaths[this.path];\n    if (Object.keys(this._server._webSocketPaths).length == 0) {\n      delete this._server._webSocketPaths;\n    }\n  }\n\n  // close the http server if it was internally created\n  try {\n    if (typeof this._closeServer !== 'undefined') {\n      this._closeServer();\n    }\n  }\n  finally {\n    delete this._server;\n  }\n  if (error) throw error;\n}\n\n/**\n * Handle a HTTP Upgrade request.\n *\n * @api public\n */\n\nWebSocketServer.prototype.handleUpgrade = function(req, socket, upgradeHead, cb) {\n  // check for wrong path\n  if (this.options.path) {\n    var u = url.parse(req.url);\n    if (u && u.pathname !== this.options.path) return;\n  }\n\n  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);\n  else handleHybiUpgrade.apply(this, arguments);\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\n\nfunction handleHybiUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify version\n  var version = parseInt(req.headers['sec-websocket-version']);\n  if ([8, 13].indexOf(version) === -1) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify protocol\n  var protocols = req.headers['sec-websocket-protocol'];\n\n  // verify client\n  var origin = version < 13 ?\n    req.headers['sec-websocket-origin'] :\n    req.headers['origin'];\n\n  // handle extensions offer\n  var extensionsOffer = Extensions.parse(req.headers['sec-websocket-extensions']);\n\n  // handler to call when the connection sequence completes\n  var self = this;\n  var completeHybiUpgrade2 = function(protocol) {\n\n    // calc key\n    var key = req.headers['sec-websocket-key'];\n    var shasum = crypto.createHash('sha1');\n    shasum.update(key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    key = shasum.digest('base64');\n\n    var headers = [\n        'HTTP/1.1 101 Switching Protocols'\n      , 'Upgrade: websocket'\n      , 'Connection: Upgrade'\n      , 'Sec-WebSocket-Accept: ' + key\n    ];\n\n    if (typeof protocol != 'undefined') {\n      headers.push('Sec-WebSocket-Protocol: ' + protocol);\n    }\n\n    var extensions = {};\n    try {\n      extensions = acceptExtensions.call(self, extensionsOffer);\n    } catch (err) {\n      abortConnection(socket, 400, 'Bad Request');\n      return;\n    }\n\n    if (Object.keys(extensions).length) {\n      var serverExtensions = {};\n      Object.keys(extensions).forEach(function(token) {\n        serverExtensions[token] = [extensions[token].params]\n      });\n      headers.push('Sec-WebSocket-Extensions: ' + Extensions.format(serverExtensions));\n    }\n\n    // allows external modification/inspection of handshake headers\n    self.emit('headers', headers);\n\n    socket.setTimeout(0);\n    socket.setNoDelay(true);\n    try {\n      socket.write(headers.concat('', '').join('\\r\\n'));\n    }\n    catch (e) {\n      // if the upgrade write fails, shut the connection down hard\n      try { socket.destroy(); } catch (e) {}\n      return;\n    }\n\n    var client = new WebSocket([req, socket, upgradeHead], {\n      protocolVersion: version,\n      protocol: protocol,\n      extensions: extensions\n    });\n\n    if (self.options.clientTracking) {\n      self.clients.push(client);\n      client.on('close', function() {\n        var index = self.clients.indexOf(client);\n        if (index != -1) {\n          self.clients.splice(index, 1);\n        }\n      });\n    }\n\n    // signal upgrade complete\n    socket.removeListener('error', errorHandler);\n    cb(client);\n  }\n\n  // optionally call external protocol selection handler before\n  // calling completeHybiUpgrade2\n  var completeHybiUpgrade1 = function() {\n    // choose from the sub-protocols\n    if (typeof self.options.handleProtocols == 'function') {\n        var protList = (protocols || \"\").split(/, */);\n        var callbackCalled = false;\n        var res = self.options.handleProtocols(protList, function(result, protocol) {\n          callbackCalled = true;\n          if (!result) abortConnection(socket, 401, 'Unauthorized');\n          else completeHybiUpgrade2(protocol);\n        });\n        if (!callbackCalled) {\n            // the handleProtocols handler never called our callback\n            abortConnection(socket, 501, 'Could not process protocols');\n        }\n        return;\n    } else {\n        if (typeof protocols !== 'undefined') {\n            completeHybiUpgrade2(protocols.split(/, */)[0]);\n        }\n        else {\n            completeHybiUpgrade2();\n        }\n    }\n  }\n\n  // optionally call external client verification handler\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else completeHybiUpgrade1();\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  completeHybiUpgrade1();\n}\n\nfunction handleHixieUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // bail if options prevent hixie\n  if (this.options.disableHixie) {\n    abortConnection(socket, 401, 'Hixie support disabled');\n    return;\n  }\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key2']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  var origin = req.headers['origin']\n    , self = this;\n\n  // setup handshake completion to run after client has been verified\n  var onClientVerified = function() {\n    var wshost;\n    if (!req.headers['x-forwarded-host'])\n        wshost = req.headers.host;\n    else\n        wshost = req.headers['x-forwarded-host'];\n    var location = ((req.headers['x-forwarded-proto'] === 'https' || socket.encrypted) ? 'wss' : 'ws') + '://' + wshost + req.url\n      , protocol = req.headers['sec-websocket-protocol'];\n\n    // handshake completion code to run once nonce has been successfully retrieved\n    var completeHandshake = function(nonce, rest) {\n      // calculate key\n      var k1 = req.headers['sec-websocket-key1']\n        , k2 = req.headers['sec-websocket-key2']\n        , md5 = crypto.createHash('md5');\n\n      [k1, k2].forEach(function (k) {\n        var n = parseInt(k.replace(/[^\\d]/g, ''))\n          , spaces = k.replace(/[^ ]/g, '').length;\n        if (spaces === 0 || n % spaces !== 0){\n          abortConnection(socket, 400, 'Bad Request');\n          return;\n        }\n        n /= spaces;\n        md5.update(String.fromCharCode(\n          n >> 24 & 0xFF,\n          n >> 16 & 0xFF,\n          n >> 8  & 0xFF,\n          n       & 0xFF));\n      });\n      md5.update(nonce.toString('binary'));\n\n      var headers = [\n          'HTTP/1.1 101 Switching Protocols'\n        , 'Upgrade: WebSocket'\n        , 'Connection: Upgrade'\n        , 'Sec-WebSocket-Location: ' + location\n      ];\n      if (typeof protocol != 'undefined') headers.push('Sec-WebSocket-Protocol: ' + protocol);\n      if (typeof origin != 'undefined') headers.push('Sec-WebSocket-Origin: ' + origin);\n\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n      try {\n        // merge header and hash buffer\n        var headerBuffer = new Buffer(headers.concat('', '').join('\\r\\n'));\n        var hashBuffer = new Buffer(md5.digest('binary'), 'binary');\n        var handshakeBuffer = new Buffer(headerBuffer.length + hashBuffer.length);\n        headerBuffer.copy(handshakeBuffer, 0);\n        hashBuffer.copy(handshakeBuffer, headerBuffer.length);\n\n        // do a single write, which - upon success - causes a new client websocket to be setup\n        socket.write(handshakeBuffer, 'binary', function(err) {\n          if (err) return; // do not create client if an error happens\n          var client = new WebSocket([req, socket, rest], {\n            protocolVersion: 'hixie-76',\n            protocol: protocol\n          });\n          if (self.options.clientTracking) {\n            self.clients.push(client);\n            client.on('close', function() {\n              var index = self.clients.indexOf(client);\n              if (index != -1) {\n                self.clients.splice(index, 1);\n              }\n            });\n          }\n\n          // signal upgrade complete\n          socket.removeListener('error', errorHandler);\n          cb(client);\n        });\n      }\n      catch (e) {\n        try { socket.destroy(); } catch (e) {}\n        return;\n      }\n    }\n\n    // retrieve nonce\n    var nonceLength = 8;\n    if (upgradeHead && upgradeHead.length >= nonceLength) {\n      var nonce = upgradeHead.slice(0, nonceLength);\n      var rest = upgradeHead.length > nonceLength ? upgradeHead.slice(nonceLength) : null;\n      completeHandshake.call(self, nonce, rest);\n    }\n    else {\n      // nonce not present in upgradeHead, so we must wait for enough data\n      // data to arrive before continuing\n      var nonce = new Buffer(nonceLength);\n      upgradeHead.copy(nonce, 0);\n      var received = upgradeHead.length;\n      var rest = null;\n      var handler = function (data) {\n        var toRead = Math.min(data.length, nonceLength - received);\n        if (toRead === 0) return;\n        data.copy(nonce, received, 0, toRead);\n        received += toRead;\n        if (received == nonceLength) {\n          socket.removeListener('data', handler);\n          if (toRead < data.length) rest = data.slice(toRead);\n          completeHandshake.call(self, nonce, rest);\n        }\n      }\n      socket.on('data', handler);\n    }\n  }\n\n  // verify client\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      var self = this;\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else onClientVerified.apply(self);\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  // no client verification required\n  onClientVerified();\n}\n\nfunction acceptExtensions(offer) {\n  var extensions = {};\n  var options = this.options.perMessageDeflate;\n  if (options && offer[PerMessageDeflate.extensionName]) {\n    var perMessageDeflate = new PerMessageDeflate(options !== true ? options : {}, true);\n    perMessageDeflate.accept(offer[PerMessageDeflate.extensionName]);\n    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n  }\n  return extensions;\n}\n\nfunction abortConnection(socket, code, name) {\n  try {\n    var response = [\n      'HTTP/1.1 ' + code + ' ' + name,\n      'Content-type: text/html'\n    ];\n    socket.write(response.concat('', '').join('\\r\\n'));\n  }\n  catch (e) { /* ignore errors - we've aborted this connection */ }\n  finally {\n    // ensure that an early aborted connection is shut down completely\n    try { socket.destroy(); } catch (e) {}\n  }\n}\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar client_1 = __webpack_require__(48);\r\nvar server_1 = __webpack_require__(69);\r\nvar AGMImpl = (function () {\r\n    function AGMImpl(protocol, clientRepository, serverRepository, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.client = new client_1.default(protocol, clientRepository, instance, configuration);\r\n        this.server = new server_1.default(protocol, serverRepository, instance, configuration);\r\n    }\r\n    AGMImpl.prototype.serverRemoved = function (callback) {\r\n        return this.client.serverRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.serverAdded = function (callback) {\r\n        return this.client.serverAdded(callback);\r\n    };\r\n    AGMImpl.prototype.serverMethodRemoved = function (callback) {\r\n        return this.client.serverMethodRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.serverMethodAdded = function (callback) {\r\n        return this.client.serverMethodAdded(callback);\r\n    };\r\n    AGMImpl.prototype.methodRemoved = function (callback) {\r\n        return this.client.methodRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.methodAdded = function (callback) {\r\n        return this.client.methodAdded(callback);\r\n    };\r\n    AGMImpl.prototype.methodsForInstance = function (instance) {\r\n        return this.client.methodsForInstance(instance);\r\n    };\r\n    AGMImpl.prototype.methods = function (methodFilter) {\r\n        return this.client.methods(methodFilter);\r\n    };\r\n    AGMImpl.prototype.servers = function (methodFilter) {\r\n        return this.client.servers(methodFilter);\r\n    };\r\n    AGMImpl.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        return this.client.subscribe(method, options, successCallback, errorCallback);\r\n    };\r\n    AGMImpl.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);\r\n    };\r\n    AGMImpl.prototype.unregister = function (methodFilter) {\r\n        return this.server.unregister(methodFilter);\r\n    };\r\n    AGMImpl.prototype.registerAsync = function (methodDefinition, callback) {\r\n        return this.server.registerAsync(methodDefinition, callback);\r\n    };\r\n    AGMImpl.prototype.register = function (methodDefinition, callback) {\r\n        return this.server.register(methodDefinition, callback);\r\n    };\r\n    AGMImpl.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n    };\r\n    AGMImpl.prototype.updateInstance = function (newInstance) {\r\n        if (this.instance.machine === undefined) {\r\n            this.instance.machine = newInstance.MachineName || newInstance.machine;\r\n        }\r\n        if (this.instance.user === undefined) {\r\n            this.instance.user = newInstance.UserName || newInstance.user;\r\n        }\r\n        if (this.instance.environment === undefined) {\r\n            this.instance.environment = newInstance.Environment || newInstance.environment;\r\n        }\r\n        if (this.instance.region === undefined) {\r\n            this.instance.region = newInstance.Region || newInstance.region;\r\n        }\r\n    };\r\n    return AGMImpl;\r\n}());\r\nexports.default = AGMImpl;\r\n//# sourceMappingURL=agm.js.map\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar invoke_1 = __webpack_require__(49);\r\nvar promisify_1 = __webpack_require__(10);\r\nvar Client = (function () {\r\n    function Client(protocol, repo, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.repo = repo;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.clientInvocations = new invoke_1.default(protocol);\r\n    }\r\n    Client.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var callProtocolSubscribe = function (targetServers, stream, successProxy, errorProxy) {\r\n            _this.protocol.client.subscribe(stream, options.arguments, targetServers, { methodResponseTimeout: options.waitTimeoutMs }, successProxy, errorProxy);\r\n        };\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (sub) {\r\n                resolve(sub);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            var methodDef;\r\n            if (typeof method === \"string\") {\r\n                methodDef = { name: method };\r\n            }\r\n            else {\r\n                methodDef = method;\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            var target = options.target;\r\n            if (target === undefined) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject({ message: '\"' + target + '\" is not a valid target. Valid targets are \"all\", \"best\", or an instance.' });\r\n            }\r\n            if (options.methodResponseTimeout === undefined) {\r\n                options.methodResponseTimeout = options.method_response_timeout;\r\n                if (options.methodResponseTimeout === undefined) {\r\n                    options.methodResponseTimeout = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (options.waitTimeoutMs === undefined) {\r\n                options.waitTimeoutMs = options.wait_for_method_timeout;\r\n                if (options.waitTimeoutMs === undefined) {\r\n                    options.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            var delayStep = 500;\r\n            var delayTillNow = 0;\r\n            var currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n            if (currentServers.length > 0) {\r\n                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);\r\n            }\r\n            else {\r\n                var retry_1 = function () {\r\n                    delayTillNow += delayStep;\r\n                    currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n                    if (currentServers.length > 0) {\r\n                        var streamInfo = currentServers[0].methods[0];\r\n                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);\r\n                    }\r\n                    else if (delayTillNow >= options.waitTimeoutMs) {\r\n                        var def = typeof method === \"string\" ? { name: method } : method;\r\n                        var info = {\r\n                            id: undefined,\r\n                            info: def,\r\n                            getInfoForUser: function () {\r\n                                return methodDef;\r\n                            },\r\n                            protocolState: undefined,\r\n                        };\r\n                        callProtocolSubscribe(currentServers, info, successProxy, errorProxy);\r\n                    }\r\n                    else {\r\n                        setTimeout(retry_1, delayStep);\r\n                    }\r\n                };\r\n                setTimeout(retry_1, delayStep);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    Client.prototype.servers = function (methodFilter) {\r\n        return this.getServers(methodFilter).map(function (serverMethodMap) {\r\n            return serverMethodMap.server.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methods = function (methodFilter) {\r\n        return this.getMethods(methodFilter).map(function (m) {\r\n            return m.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methodsForInstance = function (instance) {\r\n        return this.getMethodsForInstance(instance).map(function (m) {\r\n            return m.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methodAdded = function (callback) {\r\n        return this.repo.onMethodAdded(function (method) {\r\n            callback(method.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.methodRemoved = function (callback) {\r\n        return this.repo.onMethodRemoved(function (method) {\r\n            callback(method.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.serverAdded = function (callback) {\r\n        return this.repo.onServerAdded(function (server) {\r\n            callback(server.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.serverRemoved = function (callback) {\r\n        return this.repo.onServerRemoved(function (server, reason) {\r\n            callback(server.getInfoForUser(), reason);\r\n        });\r\n    };\r\n    Client.prototype.serverMethodAdded = function (callback) {\r\n        return this.repo.onServerMethodAdded(function (server, method) {\r\n            callback({ server: server.getInfoForUser(), method: method.getInfoForUser() });\r\n        });\r\n    };\r\n    Client.prototype.serverMethodRemoved = function (callback) {\r\n        return this.repo.onServerMethodRemoved(function (server, method) {\r\n            callback({ server: server.getInfoForUser(), method: method.getInfoForUser() });\r\n        });\r\n    };\r\n    Client.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (args) {\r\n                resolve(args);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            if (!argumentObj) {\r\n                argumentObj = {};\r\n            }\r\n            if (!target) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject({ message: '\"' + target + '\" is not a valid target. Valid targets are \"all\" and \"best\".' });\r\n            }\r\n            if (!additionalOptions) {\r\n                additionalOptions = {};\r\n            }\r\n            if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                additionalOptions.methodResponseTimeoutMs = additionalOptions.method_response_timeout;\r\n                if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                    additionalOptions.methodResponseTimeoutMs = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (additionalOptions.waitTimeoutMs === undefined) {\r\n                additionalOptions.waitTimeoutMs = additionalOptions.wait_for_method_timeout;\r\n                if (additionalOptions.waitTimeoutMs === undefined) {\r\n                    additionalOptions.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== \"number\") {\r\n                reject({ message: '\"' + additionalOptions.waitTimeoutMs + '\" is not a valid number for \\'waitTimeoutMs\\'' });\r\n                return;\r\n            }\r\n            if (typeof argumentObj !== \"object\") {\r\n                reject({ message: \"The method arguments must be an object.\" });\r\n                return;\r\n            }\r\n            if (typeof methodFilter === \"string\") {\r\n                methodFilter = { name: methodFilter };\r\n            }\r\n            var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodFilter, target);\r\n            if (serversMethodMap.length === 0) {\r\n                _this.invokeUnExisting(methodFilter, argumentObj, target, additionalOptions, successProxy, errorProxy);\r\n            }\r\n            else if (serversMethodMap.length === 1) {\r\n                var serverMethodPair = serversMethodMap[0];\r\n                _this.clientInvocations.invoke(serverMethodPair.methods[0], argumentObj, serverMethodPair.server, additionalOptions, successProxy, errorProxy);\r\n            }\r\n            else {\r\n                _this.invokeOnAll(serversMethodMap, argumentObj, additionalOptions, successProxy, errorProxy);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, success, error);\r\n    };\r\n    Client.prototype.invokeUnExisting = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var callError = function () {\r\n            error({\r\n                method: methodFilter,\r\n                called_with: argumentObj,\r\n                message: \"Can not find a method matching \" + JSON.stringify(methodFilter) + \" with server filter \" + JSON.stringify(target),\r\n                executed_by: undefined,\r\n                returned: undefined,\r\n                status: undefined,\r\n            });\r\n        };\r\n        if (additionalOptions.waitTimeoutMs === 0) {\r\n            callError();\r\n        }\r\n        else {\r\n            var delayStep_1 = 500;\r\n            var delayTillNow_1 = 0;\r\n            var retry_2 = function () {\r\n                delayTillNow_1 += delayStep_1;\r\n                var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodFilter, target);\r\n                if (serversMethodMap.length > 0) {\r\n                    _this.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n                }\r\n                else if (delayTillNow_1 >= additionalOptions.waitTimeoutMs) {\r\n                    callError();\r\n                }\r\n                else {\r\n                    setTimeout(retry_2, delayStep_1);\r\n                }\r\n            };\r\n            setTimeout(retry_2, delayStep_1);\r\n        }\r\n    };\r\n    Client.prototype.invokeOnAll = function (serverMethodsMap, argumentObj, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var successes = [];\r\n        var errors = [];\r\n        var successCallback = function (result) {\r\n            successes.push(result);\r\n            sendResponse();\r\n        };\r\n        var errorCallback = function (err) {\r\n            errors.push(err);\r\n            sendResponse();\r\n        };\r\n        var sendResponse = function () {\r\n            if (successes.length + errors.length < serverMethodsMap.length) {\r\n                return;\r\n            }\r\n            if (successes.length !== 0) {\r\n                var result_1 = successes.reduce(function (obj, invResult) {\r\n                    obj.method = invResult.method;\r\n                    obj.called_with = invResult.called_with;\r\n                    obj.returned = invResult.returned;\r\n                    obj.all_return_values.push({\r\n                        executed_by: invResult.executed_by,\r\n                        returned: invResult.returned,\r\n                        called_with: invResult.called_with,\r\n                        method: invResult.method,\r\n                        message: undefined,\r\n                        status: undefined,\r\n                    });\r\n                    obj.executed_by = invResult.executed_by;\r\n                    return obj;\r\n                }, { all_return_values: [] });\r\n                if (errors.length !== 0) {\r\n                    result_1.all_errors = [];\r\n                    errors.forEach(function (obj) {\r\n                        result_1.all_errors.push({\r\n                            executed_by: obj.executed_by,\r\n                            called_with: obj.called_with,\r\n                            name: obj.method.name,\r\n                            message: obj.message,\r\n                        });\r\n                    });\r\n                }\r\n                success(result_1);\r\n            }\r\n            else if (errors.length !== 0) {\r\n                error(errors.reduce(function (obj, currentError) {\r\n                    obj.method = currentError.method;\r\n                    obj.called_with = currentError.called_with;\r\n                    obj.message = currentError.message;\r\n                    obj.all_errors.push({\r\n                        executed_by: currentError.executed_by,\r\n                        message: currentError.message,\r\n                    });\r\n                    return obj;\r\n                }, { all_errors: [] }));\r\n            }\r\n        };\r\n        serverMethodsMap.forEach(function (serverMethodsPair) {\r\n            _this.clientInvocations.invoke(serverMethodsPair.methods[0], argumentObj, serverMethodsPair.server, additionalOptions, successCallback, errorCallback);\r\n        });\r\n    };\r\n    Client.prototype.filterByTarget = function (target, serverMethodMap) {\r\n        var _this = this;\r\n        var targetServerMethod = [];\r\n        if (typeof target === \"string\") {\r\n            if (target === \"all\") {\r\n                targetServerMethod = serverMethodMap;\r\n            }\r\n            else if (target === \"best\") {\r\n                var matchingMachine = serverMethodMap.filter(function (serverMethodPair) {\r\n                    var serverInfo = serverMethodPair.server.info;\r\n                    return serverInfo.machine === _this.instance.machine;\r\n                })[0];\r\n                if (matchingMachine) {\r\n                    return [matchingMachine];\r\n                }\r\n                targetServerMethod = serverMethodMap[0] !== undefined ? [serverMethodMap[0]] : [];\r\n            }\r\n        }\r\n        else {\r\n            if (!Array.isArray(target)) {\r\n                target = [target];\r\n            }\r\n            if (Array.isArray(target)) {\r\n                targetServerMethod = target.reduce(function (matches, filter) {\r\n                    var myMatches = serverMethodMap.filter(function (serverMethodPair) {\r\n                        return _this.instanceMatch(filter, serverMethodPair.server.info);\r\n                    });\r\n                    return matches.concat(myMatches);\r\n                }, []);\r\n            }\r\n        }\r\n        return targetServerMethod;\r\n    };\r\n    Client.prototype.instanceMatch = function (instanceFilter, instanceDefinition) {\r\n        return this.containsProps(instanceFilter, instanceDefinition);\r\n    };\r\n    Client.prototype.methodMatch = function (methodFilter, methodDefinition) {\r\n        return this.containsProps(methodFilter, methodDefinition);\r\n    };\r\n    Client.prototype.containsProps = function (filter, object) {\r\n        return Object.keys(filter).reduce(function (match, prop) {\r\n            if (!filter[prop] || typeof filter[prop] === \"function\") {\r\n                return match;\r\n            }\r\n            if (filter[prop].constructor === RegExp) {\r\n                if (!filter[prop].test(object[prop])) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    return match;\r\n                }\r\n            }\r\n            else {\r\n                if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    return match;\r\n                }\r\n            }\r\n        }, true);\r\n    };\r\n    Client.prototype.getMethods = function (methodFilter) {\r\n        var _this = this;\r\n        if (methodFilter === undefined) {\r\n            return this.repo.getMethods();\r\n        }\r\n        if (typeof methodFilter === \"string\") {\r\n            methodFilter = { name: methodFilter };\r\n        }\r\n        return this.repo.getMethods().filter(function (method) {\r\n            return _this.methodMatch(methodFilter, method.info);\r\n        });\r\n    };\r\n    Client.prototype.getMethodsForInstance = function (instanceFilter) {\r\n        var _this = this;\r\n        var allServers = this.repo.getServers();\r\n        var matchingServers = allServers.filter(function (server) {\r\n            return _this.instanceMatch(instanceFilter, server.info);\r\n        });\r\n        if (matchingServers.length === 0) {\r\n            return [];\r\n        }\r\n        var resultMethodsObject = {};\r\n        if (matchingServers.length === 1) {\r\n            resultMethodsObject = matchingServers[0].methods;\r\n        }\r\n        else {\r\n            matchingServers.forEach(function (server) {\r\n                Object.keys(server.methods).forEach(function (methodKey) {\r\n                    var method = server.methods[methodKey];\r\n                    resultMethodsObject[method.id] = method;\r\n                });\r\n            });\r\n        }\r\n        return Object.keys(resultMethodsObject)\r\n            .map(function (key) {\r\n            return resultMethodsObject[key];\r\n        });\r\n    };\r\n    Client.prototype.getServers = function (methodFilter) {\r\n        var _this = this;\r\n        var servers = this.repo.getServers();\r\n        if (methodFilter === undefined) {\r\n            return servers.map(function (server) {\r\n                return { server: server };\r\n            });\r\n        }\r\n        var methods = this.getMethods(methodFilter);\r\n        if (methods === undefined) {\r\n            return [];\r\n        }\r\n        return servers.reduce(function (prev, current) {\r\n            var methodsForServer = _this.repo.getServerMethodsById(current.id);\r\n            var matchingMethods = methodsForServer.filter(function (method) {\r\n                return _this.methodMatch(methodFilter, method.info);\r\n            });\r\n            if (matchingMethods.length > 0) {\r\n                prev.push({ server: current, methods: matchingMethods });\r\n            }\r\n            return prev;\r\n        }, []);\r\n    };\r\n    Client.prototype.getServerMethodsByFilterAndTarget = function (methodFilter, target) {\r\n        var serversMethodMap = this.getServers(methodFilter);\r\n        return this.filterByTarget(target, serversMethodMap);\r\n    };\r\n    return Client;\r\n}());\r\nexports.default = Client;\r\n//# sourceMappingURL=client.js.map\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = __webpack_require__(4);\r\nvar ClientInvocations = (function () {\r\n    function ClientInvocations(_protocol) {\r\n        var _this = this;\r\n        this._protocol = _protocol;\r\n        this._pendingCallbacks = {};\r\n        _protocol.client.onInvocationResult(function (invocationId, executedBy, status, result, resultMessage) {\r\n            return _this.processInvocationResult(invocationId, executedBy, status, result, resultMessage);\r\n        });\r\n    }\r\n    ClientInvocations.prototype.invoke = function (method, argumentsObj, target, stuff, success, error) {\r\n        var invocationId = random_1.default();\r\n        this.registerInvocation(invocationId, {\r\n            method: method,\r\n            calledWith: argumentsObj,\r\n        }, success, error, stuff.methodResponseTimeoutMs);\r\n        this._protocol.client.invoke(invocationId, method, argumentsObj, target, stuff);\r\n    };\r\n    ClientInvocations.prototype.registerInvocation = function (invocationId, invocationInfo, success, error, timeout) {\r\n        var _this = this;\r\n        this._pendingCallbacks[invocationId] = { invocationInfo: invocationInfo, success: success, error: error };\r\n        setTimeout(function () {\r\n            if (_this._pendingCallbacks[invocationId] === undefined) {\r\n                return;\r\n            }\r\n            error({\r\n                method: invocationInfo.method.getInfoForUser(),\r\n                called_with: invocationInfo.calledWith,\r\n                executed_by: undefined,\r\n                status: undefined,\r\n                returned: undefined,\r\n                message: \"Invocation timeout (\" + timeout + \" ms) reached\",\r\n            });\r\n            delete _this._pendingCallbacks[invocationId];\r\n        }, timeout);\r\n    };\r\n    ClientInvocations.prototype.processInvocationResult = function (invocationId, executedBy, status, result, resultMessage) {\r\n        var callback = this._pendingCallbacks[invocationId];\r\n        if (callback === undefined) {\r\n            return;\r\n        }\r\n        if (status === 0 && typeof callback.success === \"function\") {\r\n            callback.success({\r\n                method: callback.invocationInfo.method.getInfoForUser(),\r\n                called_with: callback.invocationInfo.calledWith,\r\n                executed_by: executedBy,\r\n                returned: result,\r\n                message: resultMessage,\r\n                status: status,\r\n            });\r\n        }\r\n        else if (typeof callback.error === \"function\") {\r\n            callback.error({\r\n                method: callback.invocationInfo.method.getInfoForUser(),\r\n                called_with: callback.invocationInfo.calledWith,\r\n                executed_by: executedBy,\r\n                message: resultMessage,\r\n                status: status,\r\n                returned: result,\r\n            });\r\n        }\r\n        delete this._pendingCallbacks[invocationId];\r\n    };\r\n    return ClientInvocations;\r\n}());\r\nexports.default = ClientInvocations;\r\n//# sourceMappingURL=invoke.js.map\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar ClientRepository = (function () {\r\n    function ClientRepository() {\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n        this.callbacks = callback_registry_1.default();\r\n    }\r\n    ClientRepository.prototype.addServer = function (info, serverId) {\r\n        var _this = this;\r\n        var current = this.servers[serverId];\r\n        if (current) {\r\n            return current.id;\r\n        }\r\n        var serverEntry = {\r\n            id: serverId,\r\n            info: info,\r\n            methods: {},\r\n            getInfoForUser: function () {\r\n                var serverInfo = _this.createUserServerInfo(serverEntry.info);\r\n                serverInfo.getMethods = function () {\r\n                    return _this.getServerMethodsById(serverEntry.id).map(function (m) {\r\n                        return m.getInfoForUser();\r\n                    });\r\n                };\r\n                serverInfo.getStreams = function () {\r\n                    return _this.getServerMethodsById(serverEntry.id)\r\n                        .filter(function (method) {\r\n                        return method.info.supportsStreaming;\r\n                    })\r\n                        .map(function (m) {\r\n                        return m.getInfoForUser();\r\n                    });\r\n                };\r\n                return serverInfo;\r\n            },\r\n        };\r\n        this.servers[serverId] = serverEntry;\r\n        this.callbacks.execute(\"onServerAdded\", serverEntry);\r\n        return serverId;\r\n    };\r\n    ClientRepository.prototype.removeServerById = function (id, reason) {\r\n        var _this = this;\r\n        var server = this.servers[id];\r\n        Object.keys(server.methods).forEach(function (methodId) {\r\n            _this.removeServerMethod(id, methodId);\r\n        });\r\n        delete this.servers[id];\r\n        this.callbacks.execute(\"onServerRemoved\", server, reason);\r\n    };\r\n    ClientRepository.prototype.addServerMethod = function (serverId, method, protocolState) {\r\n        if (!protocolState) {\r\n            protocolState = {};\r\n        }\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var methodId = this.createMethodId(method);\r\n        if (server.methods[methodId]) {\r\n            return;\r\n        }\r\n        var that = this;\r\n        var methodEntity = {\r\n            id: methodId,\r\n            info: method,\r\n            getInfoForUser: function () {\r\n                var result = that.createUserMethodInfo(methodEntity.info);\r\n                result.getServers = function () {\r\n                    return that.getServersByMethod(methodId);\r\n                };\r\n                return result;\r\n            },\r\n            protocolState: protocolState,\r\n        };\r\n        server.methods[methodId] = methodEntity;\r\n        if (!this.methodsCount[methodId]) {\r\n            this.methodsCount[methodId] = 0;\r\n            this.callbacks.execute(\"onMethodAdded\", methodEntity);\r\n        }\r\n        this.methodsCount[methodId] = this.methodsCount[methodId] + 1;\r\n        this.callbacks.execute(\"onServerMethodAdded\", server, methodEntity);\r\n    };\r\n    ClientRepository.prototype.createMethodId = function (methodInfo) {\r\n        var accepts = methodInfo.accepts !== undefined ? methodInfo.accepts : \"\";\r\n        var returns = methodInfo.returns !== undefined ? methodInfo.returns : \"\";\r\n        return (methodInfo.name + accepts + returns).toLowerCase();\r\n    };\r\n    ClientRepository.prototype.removeServerMethod = function (serverId, methodId) {\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var method = server.methods[methodId];\r\n        delete server.methods[methodId];\r\n        this.methodsCount[methodId] = this.methodsCount[methodId] - 1;\r\n        if (this.methodsCount[methodId] === 0) {\r\n            this.callbacks.execute(\"onMethodRemoved\", method);\r\n        }\r\n        this.callbacks.execute(\"onServerMethodRemoved\", server, method);\r\n    };\r\n    ClientRepository.prototype.getMethods = function () {\r\n        var _this = this;\r\n        var allMethods = {};\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            Object.keys(server.methods).forEach(function (methodId) {\r\n                var method = server.methods[methodId];\r\n                allMethods[method.id] = method;\r\n            });\r\n        });\r\n        var methodsAsArray = Object.keys(allMethods).map(function (id) {\r\n            return allMethods[id];\r\n        });\r\n        return methodsAsArray;\r\n    };\r\n    ClientRepository.prototype.getServers = function () {\r\n        var _this = this;\r\n        var allServers = [];\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            allServers.push(server);\r\n        });\r\n        return allServers;\r\n    };\r\n    ClientRepository.prototype.getServerMethodsById = function (serverId) {\r\n        var server = this.servers[serverId];\r\n        return Object.keys(server.methods).map(function (id) {\r\n            return server.methods[id];\r\n        });\r\n    };\r\n    ClientRepository.prototype.onServerAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerAdded\", callback);\r\n        this.getServers().forEach(function (server) {\r\n            callback(server);\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodAdded\", callback);\r\n        this.getMethods().forEach(function (method) {\r\n            callback(method);\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodAdded\", callback);\r\n        this.getServers().forEach(function (server) {\r\n            var methods = server.methods;\r\n            Object.keys(methods).forEach(function (methodId) {\r\n                callback(server, methods[methodId]);\r\n            });\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.getServerById = function (id) {\r\n        return this.servers[id];\r\n    };\r\n    ClientRepository.prototype.reset = function () {\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n    };\r\n    ClientRepository.prototype.createUserServerInfo = function (serverInfo) {\r\n        return {\r\n            machine: serverInfo.machine,\r\n            pid: serverInfo.pid,\r\n            user: serverInfo.user,\r\n            application: serverInfo.application,\r\n            environment: serverInfo.environment,\r\n            region: serverInfo.region,\r\n            instance: serverInfo.instance,\r\n            windowId: serverInfo.windowId,\r\n            peerId: serverInfo.peerId,\r\n        };\r\n    };\r\n    ClientRepository.prototype.createUserMethodInfo = function (methodInfo) {\r\n        var result = {\r\n            name: methodInfo.name,\r\n            accepts: methodInfo.accepts,\r\n            returns: methodInfo.returns,\r\n            description: methodInfo.description,\r\n            displayName: methodInfo.displayName,\r\n            objectTypes: methodInfo.objectTypes,\r\n            supportsStreaming: methodInfo.supportsStreaming,\r\n        };\r\n        result.object_types = methodInfo.objectTypes;\r\n        result.display_name = methodInfo.displayName;\r\n        result.version = methodInfo.version;\r\n        return result;\r\n    };\r\n    ClientRepository.prototype.getServersByMethod = function (id) {\r\n        var _this = this;\r\n        var allServers = [];\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            Object.keys(server.methods).forEach(function (methodId) {\r\n                if (methodId === id) {\r\n                    allServers.push(server.getInfoForUser());\r\n                }\r\n            });\r\n        });\r\n        return allServers;\r\n    };\r\n    return ClientRepository;\r\n}());\r\nexports.default = ClientRepository;\r\n//# sourceMappingURL=repository.js.map\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar promisify_1 = __webpack_require__(10);\r\nvar NativeAGM = (function () {\r\n    function NativeAGM(instance, helpers, agmFacade) {\r\n        this.instance = instance;\r\n        this.helpers = helpers;\r\n        this.agmFacade = agmFacade;\r\n        this.protocolVersion = this.agmFacade.protocolVersion;\r\n    }\r\n    NativeAGM.prototype.register = function (name, handler) {\r\n        var methodInfoAsObject = this.helpers.stringToObject(name, \"name\");\r\n        this.helpers.validateMethodInfo(methodInfoAsObject);\r\n        if (this.protocolVersion && this.protocolVersion >= 3) {\r\n            this.agmFacade.register(JSON.stringify(methodInfoAsObject), handler, true);\r\n        }\r\n        else {\r\n            this.agmFacade.register(JSON.stringify(methodInfoAsObject), function (arg, caller) {\r\n                var methodResult = handler(JSON.parse(arg), caller);\r\n                return JSON.stringify(methodResult);\r\n            });\r\n        }\r\n    };\r\n    NativeAGM.prototype.registerAsync = function (name, handler) {\r\n        if (!this.agmFacade.registerAsync) {\r\n            throw new Error(\"not supported in that version of HtmlContainer\");\r\n        }\r\n        var methodInfoAsObject = this.helpers.stringToObject(name, \"name\");\r\n        this.helpers.validateMethodInfo(methodInfoAsObject);\r\n        this.agmFacade.registerAsync(methodInfoAsObject, function (args, instance, tracker) {\r\n            handler(args, instance, function (successArgs) {\r\n                tracker.success(successArgs);\r\n            }, function (error) {\r\n                tracker.error(error);\r\n            });\r\n        });\r\n    };\r\n    NativeAGM.prototype.unregister = function (definition) {\r\n        this.agmFacade.unregister(JSON.stringify(this.helpers.stringToObject(definition, \"name\")));\r\n    };\r\n    NativeAGM.prototype.invoke = function (method, argumentObj, target, options, success, error) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (argumentObj === undefined) {\r\n                argumentObj = {};\r\n            }\r\n            if (typeof argumentObj !== \"object\") {\r\n                reject({ message: \"The method arguments must be an object.\" });\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            target = _this.helpers.targetArgToObject(target);\r\n            if (_this.agmFacade.invoke2) {\r\n                _this.agmFacade.invoke2(JSON.stringify(_this.helpers.stringToObject(method, \"name\")), argumentObj, JSON.stringify(target), JSON.stringify(options), function (a) {\r\n                    resolve(a);\r\n                }, function (err) {\r\n                    reject(err);\r\n                });\r\n            }\r\n            else {\r\n                var successProxy = void 0;\r\n                var errorProxy = void 0;\r\n                successProxy = function (args) {\r\n                    var parsed = JSON.parse(args);\r\n                    resolve(parsed);\r\n                };\r\n                errorProxy = function (args) {\r\n                    var parsed = JSON.parse(args);\r\n                    reject(parsed);\r\n                };\r\n                _this.agmFacade.invoke(JSON.stringify(_this.helpers.stringToObject(method, \"name\")), JSON.stringify(argumentObj), JSON.stringify(target), JSON.stringify(options), successProxy, errorProxy);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, success, error);\r\n    };\r\n    NativeAGM.prototype.createStream = function (methodDefinition, options, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof methodDefinition === \"string\") {\r\n                methodDefinition = {\r\n                    name: methodDefinition,\r\n                    getServers: function () { return []; },\r\n                };\r\n            }\r\n            if (!options) {\r\n                options = {\r\n                    subscriptionRequestHandler: undefined,\r\n                    subscriptionAddedHandler: undefined,\r\n                    subscriptionRemovedHandler: undefined,\r\n                };\r\n            }\r\n            _this.agmFacade.createStream2(JSON.stringify(methodDefinition), options.subscriptionRequestHandler, options.subscriptionAddedHandler, options.subscriptionRemovedHandler, function (stream) {\r\n                resolve(stream);\r\n            }, function (error) {\r\n                reject(error);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    NativeAGM.prototype.subscribe = function (methodDefinition, parameters, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof methodDefinition === \"undefined\") {\r\n                reject(\"method definition param is required\");\r\n            }\r\n            if (parameters === undefined) {\r\n                parameters = {};\r\n            }\r\n            parameters.args = JSON.stringify(parameters.arguments || {});\r\n            parameters.target = _this.helpers.targetArgToObject(parameters.target);\r\n            var name;\r\n            if (typeof methodDefinition === \"string\") {\r\n                name = methodDefinition;\r\n            }\r\n            else {\r\n                name = methodDefinition.name;\r\n            }\r\n            _this.agmFacade.subscribe2(name, JSON.stringify(parameters), function (sub) {\r\n                resolve(sub);\r\n            }, function (error) {\r\n                reject(error);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    NativeAGM.prototype.servers = function (filter) {\r\n        var _this = this;\r\n        var jsonResult = this.agmFacade.servers(JSON.stringify(this.helpers.stringToObject(filter, \"name\")));\r\n        var parsedResult = this.helpers.agmParse(jsonResult);\r\n        return parsedResult.map(function (server) {\r\n            return _this.transformServerObject(server);\r\n        });\r\n    };\r\n    NativeAGM.prototype.methods = function (filter) {\r\n        var _this = this;\r\n        var jsonResult = this.agmFacade.methods(JSON.stringify(this.helpers.stringToObject(filter, \"name\")));\r\n        var parsedResult = this.helpers.agmParse(jsonResult);\r\n        return parsedResult.map(function (method) {\r\n            return _this.transformMethodObject(method);\r\n        });\r\n    };\r\n    NativeAGM.prototype.methodAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.methodAdded(function (method) {\r\n            if (subscribed) {\r\n                callback(_this.transformMethodObject(method));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.methodRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.methodRemoved(function (method) {\r\n            if (subscribed) {\r\n                callback(_this.transformMethodObject(method));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverAdded(function (server) {\r\n            if (subscribed) {\r\n                callback(_this.transformServerObject(server));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverRemoved(function (server) {\r\n            if (subscribed) {\r\n                callback(_this.transformServerObject(server));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverMethodAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverMethodAdded(function (info) {\r\n            if (subscribed) {\r\n                callback({\r\n                    server: _this.transformServerObject(info.server),\r\n                    method: _this.transformMethodObject(info.method),\r\n                });\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverMethodRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverMethodRemoved(function (info) {\r\n            if (subscribed) {\r\n                callback({\r\n                    server: _this.transformServerObject(info.server),\r\n                    method: _this.transformMethodObject(info.method),\r\n                });\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.methodsForInstance = function (server) {\r\n        var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(server));\r\n        var methods = this.helpers.agmParse(jsonResult);\r\n        return methods.map(this.transformMethodObject);\r\n    };\r\n    NativeAGM.prototype.transformMethodObject = function (method) {\r\n        var _this = this;\r\n        if (!method) {\r\n            return undefined;\r\n        }\r\n        if (!method.displayName) {\r\n            method.displayName = method.display_name;\r\n        }\r\n        if (!method.objectTypes) {\r\n            method.objectTypes = method.object_types;\r\n        }\r\n        method.getServers = function () {\r\n            return _this.servers(method.name);\r\n        };\r\n        return method;\r\n    };\r\n    NativeAGM.prototype.transformServerObject = function (server) {\r\n        var _this = this;\r\n        if (!server) {\r\n            return undefined;\r\n        }\r\n        server.getMethods = function () {\r\n            return _this.methodsForInstance(server);\r\n        };\r\n        server.getStreams = function () {\r\n            return _this.methodsForInstance(server).filter(function (method) {\r\n                return method.supportsStreaming;\r\n            });\r\n        };\r\n        return server;\r\n    };\r\n    return NativeAGM;\r\n}());\r\nexports.NativeAGM = NativeAGM;\r\n//# sourceMappingURL=agm.js.map\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Helpers = (function () {\r\n    function Helpers(facade) {\r\n        this.facade = facade;\r\n        this.dateTimeIdentifier = facade.jsonValueDatePrefix;\r\n        this.lenOfIdentifier = this.dateTimeIdentifier.length;\r\n    }\r\n    Helpers.prototype.agmParse = function (str) {\r\n        var _this = this;\r\n        return JSON.parse(str, function (k, v) {\r\n            if (typeof v !== \"string\") {\r\n                return v;\r\n            }\r\n            if (v[0] !== _this.dateTimeIdentifier[0]) {\r\n                return v;\r\n            }\r\n            if (v.indexOf(_this.dateTimeIdentifier) !== 0) {\r\n                return v;\r\n            }\r\n            var unixTimestampMs = v.substr(_this.lenOfIdentifier);\r\n            return new Date(parseFloat(unixTimestampMs));\r\n        });\r\n    };\r\n    Helpers.prototype.targetArgToObject = function (target) {\r\n        var _this = this;\r\n        target = target || \"best\";\r\n        if (typeof target === \"string\") {\r\n            if (target !== \"all\" && target !== \"best\") {\r\n                throw new Error(target + \" is not a valid target. Valid targets are 'all' and 'best'\");\r\n            }\r\n            return { target: target };\r\n        }\r\n        else {\r\n            if (!Array.isArray(target)) {\r\n                target = [target];\r\n            }\r\n            target = target.map(function (e) {\r\n                return _this.convertInstanceToRegex(e);\r\n            });\r\n            return { serverFilter: target };\r\n        }\r\n    };\r\n    Helpers.prototype.convertInstanceToRegex = function (instance) {\r\n        var instanceConverted = {};\r\n        Object.keys(instance).forEach(function (key) {\r\n            var propValue = instance[key];\r\n            instanceConverted[key] = propValue;\r\n            if (typeof propValue === \"undefined\" || propValue === null) {\r\n                return;\r\n            }\r\n            if (typeof propValue === \"string\" && propValue !== \"\") {\r\n                instanceConverted[key] = \"^\" + instance[key] + \"$\";\r\n            }\r\n            else if (instance[key].constructor === RegExp) {\r\n                instanceConverted[key] = instance[key].source;\r\n            }\r\n            else {\r\n                instanceConverted[key] = instance[key];\r\n            }\r\n        });\r\n        return instanceConverted;\r\n    };\r\n    Helpers.prototype.validateMethodInfo = function (methodInfo) {\r\n        if (typeof methodInfo === \"undefined\") {\r\n            throw Error(\"methodInfo is required argument\");\r\n        }\r\n        if (!methodInfo.name) {\r\n            throw Error(\"methodInfo object must contain name property\");\r\n        }\r\n        if (methodInfo.objectTypes) {\r\n            methodInfo.object_types = methodInfo.objectTypes;\r\n        }\r\n        if (methodInfo.displayName) {\r\n            methodInfo.display_name = methodInfo.displayName;\r\n        }\r\n    };\r\n    Helpers.prototype.stringToObject = function (param, stringPropName) {\r\n        if (typeof param === \"string\") {\r\n            var obj = {};\r\n            obj[stringPropName] = param;\r\n            return obj;\r\n        }\r\n        return param;\r\n    };\r\n    return Helpers;\r\n}());\r\nexports.Helpers = Helpers;\r\n//# sourceMappingURL=helpers.js.map\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar agm_1 = __webpack_require__(51);\r\nvar helpers_1 = __webpack_require__(52);\r\nfunction default_1(configuration) {\r\n    var facade = window.htmlContainer.jsAgmFacade;\r\n    var cfgAsString = createConfig(configuration);\r\n    return new Promise(function (resolve, reject) {\r\n        var successInit = function (instance) {\r\n            var nativeAGM = new agm_1.NativeAGM(instance, new helpers_1.Helpers(facade), facade);\r\n            nativeAGM.create_stream = nativeAGM.createStream;\r\n            nativeAGM.methods_for_instance = nativeAGM.methodsForInstance;\r\n            nativeAGM.method_added = nativeAGM.methodAdded;\r\n            nativeAGM.method_removed = nativeAGM.methodRemoved;\r\n            nativeAGM.server_added = nativeAGM.serverAdded;\r\n            nativeAGM.server_removed = nativeAGM.serverRemoved;\r\n            nativeAGM.server_method_added = nativeAGM.serverMethodAdded;\r\n            nativeAGM.server_method_removed = nativeAGM.serverMethodRemoved;\r\n            resolve(nativeAGM);\r\n        };\r\n        if (facade.protocolVersion && facade.protocolVersion >= 5 && facade.initAsync) {\r\n            facade.initAsync(cfgAsString, successInit, function (err) {\r\n                reject(err);\r\n            });\r\n        }\r\n        else {\r\n            var instance = facade.init(cfgAsString);\r\n            successInit(instance);\r\n        }\r\n    });\r\n}\r\nexports.default = default_1;\r\nvar createConfig = function (configuration) {\r\n    if (configuration !== undefined && configuration.metrics !== undefined) {\r\n        configuration.metrics.metricsIdentity = configuration.metrics.identity;\r\n        var metricsConfig = {\r\n            metricsIdentity: configuration.metrics.metricsIdentity,\r\n            path: configuration.metrics.path,\r\n        };\r\n        configuration.metrics = metricsConfig;\r\n    }\r\n    delete configuration.logger;\r\n    return JSON.stringify(configuration);\r\n};\r\n//# sourceMappingURL=native.js.map\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = __webpack_require__(4);\r\nfunction createOwnInstance(userSubmittedProperties, resolvedIdentity, peerId) {\r\n    var document = global.document || global.process;\r\n    var instance = {\r\n        application: document.title + random_1.default(),\r\n        pid: Math.floor(Math.random() * 10000000000),\r\n    };\r\n    instance.peerId = peerId;\r\n    if (typeof userSubmittedProperties === \"object\") {\r\n        if (userSubmittedProperties.application !== undefined) {\r\n            instance.application = userSubmittedProperties.application;\r\n        }\r\n        instance.machine = userSubmittedProperties.machine;\r\n        instance.user = userSubmittedProperties.user;\r\n        instance.environment = userSubmittedProperties.environment;\r\n        instance.region = userSubmittedProperties.region;\r\n    }\r\n    if (typeof resolvedIdentity !== \"undefined\") {\r\n        instance.user = resolvedIdentity.user;\r\n        instance.instance = resolvedIdentity.instance;\r\n        instance.application = resolvedIdentity.application;\r\n        instance.pid = resolvedIdentity.process;\r\n        instance.machine = resolvedIdentity.machine;\r\n        instance.environment = resolvedIdentity.environment;\r\n        instance.region = resolvedIdentity.region;\r\n        instance.windowId = resolvedIdentity.windowId;\r\n    }\r\n    return instance;\r\n}\r\nexports.createOwnInstance = createOwnInstance;\r\n//# sourceMappingURL=instance.js.map\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar instance_1 = __webpack_require__(54);\r\nvar native_1 = __webpack_require__(53);\r\nvar factory_1 = __webpack_require__(58);\r\nvar factory_2 = __webpack_require__(63);\r\nvar agm_1 = __webpack_require__(47);\r\nvar repository_1 = __webpack_require__(50);\r\nvar repository_2 = __webpack_require__(67);\r\nexports.default = (function (configuration) {\r\n    if (!configuration.forceGW && configuration.gdVersion === 2) {\r\n        return native_1.default(configuration);\r\n    }\r\n    if (typeof configuration === \"undefined\") {\r\n        throw new Error(\"configuration is required\");\r\n    }\r\n    if (typeof configuration.connection === \"undefined\") {\r\n        throw new Error(\"configuration.connections is required\");\r\n    }\r\n    var connection = configuration.connection;\r\n    if (typeof configuration.methodResponseTimeout !== \"number\") {\r\n        configuration.methodResponseTimeout = 3000;\r\n    }\r\n    if (typeof configuration.waitTimeoutMs !== \"number\") {\r\n        configuration.waitTimeoutMs = 3000;\r\n    }\r\n    var myIdentity = connection.resolvedIdentity;\r\n    var myInstance = instance_1.createOwnInstance(configuration.instance, myIdentity, connection.peerId);\r\n    var clientRepository = new repository_1.default();\r\n    var serverRepository = new repository_2.default();\r\n    var protocolPromise;\r\n    var agmImpl;\r\n    if (connection.protocolVersion === 3) {\r\n        protocolPromise = factory_2.default(myInstance, connection, clientRepository, serverRepository, configuration, function () { return agmImpl; });\r\n    }\r\n    else {\r\n        protocolPromise = factory_1.default(myInstance, connection, clientRepository, serverRepository, configuration, function () { return agmImpl; });\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n        protocolPromise.then(function (protocol) {\r\n            agmImpl = new agm_1.default(protocol, clientRepository, serverRepository, myInstance, configuration);\r\n            resolve(agmImpl);\r\n        }).catch(function (err) {\r\n            reject(err);\r\n        });\r\n    });\r\n});\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = __webpack_require__(4);\r\nvar helpers_1 = __webpack_require__(7);\r\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(configuration, instance, sendRequest, nextResponseSubject) {\r\n        this.configuration = configuration;\r\n        this.instance = instance;\r\n        this.sendRequest = sendRequest;\r\n        this.nextResponseSubject = nextResponseSubject;\r\n        this.subscriptionsList = {};\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: stream.getInfoForUser(),\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n                called_with: args,\r\n            });\r\n            return;\r\n        }\r\n        var subscriptionId = \"subscriptionId_\" + random_1.default();\r\n        var pendingSub = this.registerSubscription(subscriptionId, stream, args, success, error, options.methodResponseTimeout);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: stream.getInfoForUser(),\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n                called_with: args,\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var responseSubject = _this.nextResponseSubject();\r\n            var requestSubject = stream.info.requestSubject;\r\n            pendingSub.trackedServers.push({\r\n                server: undefined,\r\n                streamId: undefined,\r\n                streamSubjects: {\r\n                    global: undefined,\r\n                    private: undefined,\r\n                },\r\n                methodRequestSubject: requestSubject,\r\n                methodResponseSubject: responseSubject,\r\n            });\r\n            var message = {\r\n                EventStreamAction: 1,\r\n                MethodRequestSubject: requestSubject,\r\n                MethodResponseSubject: responseSubject,\r\n                Client: helpers_1.convertInstance(_this.instance),\r\n                Context: {\r\n                    ArgumentsJson: args,\r\n                    InvocationId: subscriptionId,\r\n                    MethodName: stream.info.name,\r\n                    ExecutionServer: target.server.info,\r\n                    Timeout: options.methodResponseTimeout,\r\n                },\r\n            };\r\n            _this.sendRequest(message);\r\n        });\r\n    };\r\n    ClientStreaming.prototype.processPublisherMsg = function (msg) {\r\n        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {\r\n            return;\r\n        }\r\n        if (msg.EventStreamAction === 2) {\r\n            this.serverIsKickingASubscriber(msg);\r\n        }\r\n        else if (msg.EventStreamAction === 3) {\r\n            this.serverAcknowledgesGoodSubscription(msg);\r\n        }\r\n        else if (msg.EventStreamAction === 5) {\r\n            this.serverHasPushedSomeDataIntoTheStream(msg);\r\n        }\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subscriptionId, method, args, success, error, timeout) {\r\n        var _this = this;\r\n        this.subscriptionsList[subscriptionId] = {\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            arguments: args,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: [],\r\n                onClosed: [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n        };\r\n        this.subscriptionsList[subscriptionId].timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subscriptionId] === undefined) {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subscriptionId];\r\n            if (subscription.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method,\r\n                    called_with: args,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \"ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subscriptionId];\r\n            }\r\n            else if (subscription.status === STATUS_SUBSCRIBED &&\r\n                subscription.trackedServers.length > 0) {\r\n                subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                    return (typeof server.streamId === \"string\" && server.streamId !== \"\");\r\n                });\r\n                subscription.timeoutId = undefined;\r\n                if (subscription.trackedServers.length === 0) {\r\n                    var closersCount = subscription.queued.closers.length;\r\n                    var closingServer_1 = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n                    subscription.handlers.onClosed.forEach(function (callback) {\r\n                        if (typeof callback === \"function\") {\r\n                            callback({\r\n                                message: ON_CLOSE_MSG_SERVER_INIT,\r\n                                requestArguments: subscription.arguments,\r\n                                server: closingServer_1,\r\n                                stream: subscription.method,\r\n                            });\r\n                        }\r\n                    });\r\n                    delete _this.subscriptionsList[subscriptionId];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return this.subscriptionsList[subscriptionId];\r\n    };\r\n    ClientStreaming.prototype.serverIsKickingASubscriber = function (msg) {\r\n        var _this = this;\r\n        var keys = Object.keys(this.subscriptionsList);\r\n        if (typeof msg.InvocationId === \"string\" && msg.InvocationId !== \"\") {\r\n            keys = keys.filter(function (k) { return k === msg.InvocationId; });\r\n        }\r\n        var deletionsList = [];\r\n        keys.forEach(function (key) {\r\n            if (typeof _this.subscriptionsList[key] !== \"object\") {\r\n                return;\r\n            }\r\n            _this.subscriptionsList[key].trackedServers = _this.subscriptionsList[key].trackedServers.filter(function (server) {\r\n                var isRejecting = (server.methodRequestSubject === msg.MethodRequestSubject && server.methodResponseSubject === msg.MethodResponseSubject);\r\n                var isKicking = (server.streamId === msg.StreamId &&\r\n                    (server.streamSubjects.global === msg.EventStreamSubject || server.streamSubjects.private === msg.EventStreamSubject));\r\n                var isRejectingOrKicking = isRejecting || isKicking;\r\n                return !isRejectingOrKicking;\r\n            });\r\n            if (_this.subscriptionsList[key].trackedServers.length === 0) {\r\n                deletionsList.push(key);\r\n            }\r\n        });\r\n        deletionsList.forEach(function (key) {\r\n            if (typeof _this.subscriptionsList[key] !== \"object\") {\r\n                return;\r\n            }\r\n            if (_this.subscriptionsList[key].status === STATUS_AWAITING_ACCEPT &&\r\n                typeof _this.subscriptionsList[key].timeoutId === \"number\") {\r\n                var reason = (typeof msg.ResultMessage === \"string\" && msg.ResultMessage !== \"\") ?\r\n                    ' Publisher said \"' + msg.ResultMessage + '\".' :\r\n                    \" No reason given.\";\r\n                var callArgs = typeof _this.subscriptionsList[key].arguments === \"object\" ?\r\n                    JSON.stringify(_this.subscriptionsList[key].arguments) :\r\n                    \"{}\";\r\n                _this.subscriptionsList[key].error(ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs);\r\n                clearTimeout(_this.subscriptionsList[key].timeoutId);\r\n            }\r\n            else {\r\n                _this.subscriptionsList[key].handlers.onClosed.forEach(function (callback) {\r\n                    if (typeof callback !== \"function\") {\r\n                        return;\r\n                    }\r\n                    callback({\r\n                        message: ON_CLOSE_MSG_SERVER_INIT,\r\n                        requestArguments: _this.subscriptionsList[key].arguments,\r\n                        server: helpers_1.convertInfoToInstance(msg.Server),\r\n                        stream: _this.subscriptionsList[key].method,\r\n                    });\r\n                });\r\n            }\r\n            delete _this.subscriptionsList[key];\r\n        });\r\n    };\r\n    ClientStreaming.prototype.serverAcknowledgesGoodSubscription = function (msg) {\r\n        var _this = this;\r\n        var subscriptionId = msg.InvocationId;\r\n        var subscription = this.subscriptionsList[subscriptionId];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        var acceptingServer = subscription.trackedServers.filter(function (server) {\r\n            return (server.methodRequestSubject === msg.MethodRequestSubject &&\r\n                server.methodResponseSubject === msg.MethodResponseSubject);\r\n        })[0];\r\n        if (typeof acceptingServer !== \"object\") {\r\n            return;\r\n        }\r\n        var isFirstResponse = (subscription.status === STATUS_AWAITING_ACCEPT);\r\n        subscription.status = STATUS_SUBSCRIBED;\r\n        var privateStreamSubject = this.generatePrivateStreamSubject(subscription.method.name);\r\n        if (typeof acceptingServer.streamId === \"string\" && acceptingServer.streamId !== \"\") {\r\n            return;\r\n        }\r\n        acceptingServer.server = helpers_1.convertInfoToInstance(msg.Server);\r\n        acceptingServer.streamId = msg.StreamId;\r\n        acceptingServer.streamSubjects.global = msg.EventStreamSubject;\r\n        acceptingServer.streamSubjects.private = privateStreamSubject;\r\n        var confirmatoryRequest = {\r\n            EventStreamAction: 3,\r\n            EventStreamSubject: privateStreamSubject,\r\n            StreamId: msg.StreamId,\r\n            MethodRequestSubject: msg.MethodRequestSubject,\r\n            MethodResponseSubject: acceptingServer.methodResponseSubject,\r\n            Client: helpers_1.convertInstance(this.instance),\r\n            Context: {\r\n                ArgumentsJson: subscription.arguments,\r\n                MethodName: subscription.method.name,\r\n            },\r\n        };\r\n        this.sendRequest(confirmatoryRequest);\r\n        if (isFirstResponse) {\r\n            subscription.success({\r\n                onData: function (dataCallback) {\r\n                    if (typeof dataCallback !== \"function\") {\r\n                        throw new TypeError(\"The data callback must be a function.\");\r\n                    }\r\n                    this.handlers.onData.push(dataCallback);\r\n                    if (this.handlers.onData.length === 1 && this.queued.data.length > 0) {\r\n                        this.queued.data.forEach(function (dataItem) {\r\n                            dataCallback(dataItem);\r\n                        });\r\n                    }\r\n                }.bind(subscription),\r\n                onClosed: function (closedCallback) {\r\n                    if (typeof closedCallback !== \"function\") {\r\n                        throw new TypeError(\"The callback must be a function.\");\r\n                    }\r\n                    this.handlers.onClosed.push(closedCallback);\r\n                }.bind(subscription),\r\n                onFailed: function () { },\r\n                close: function () { return _this.closeSubscription(subscription, subscriptionId); },\r\n                requestArguments: subscription.arguments,\r\n                serverInstance: helpers_1.convertInfoToInstance(msg.Server),\r\n                stream: subscription.method,\r\n            });\r\n        }\r\n    };\r\n    ClientStreaming.prototype.serverHasPushedSomeDataIntoTheStream = function (msg) {\r\n        var _loop_1 = function (key) {\r\n            if (this_1.subscriptionsList.hasOwnProperty(key) && typeof this_1.subscriptionsList[key] === \"object\") {\r\n                var isPrivateData = void 0;\r\n                var trackedServersFound = this_1.subscriptionsList[key].trackedServers.filter(function (ls) {\r\n                    return (ls.streamId === msg.StreamId &&\r\n                        (ls.streamSubjects.global === msg.EventStreamSubject ||\r\n                            ls.streamSubjects.private === msg.EventStreamSubject));\r\n                });\r\n                if (trackedServersFound.length === 0) {\r\n                    isPrivateData = undefined;\r\n                }\r\n                else if (trackedServersFound[0].streamSubjects.global === msg.EventStreamSubject) {\r\n                    isPrivateData = false;\r\n                }\r\n                else if (trackedServersFound[0].streamSubjects.private === msg.EventStreamSubject) {\r\n                    isPrivateData = true;\r\n                }\r\n                if (isPrivateData !== undefined) {\r\n                    var receivedStreamData_1 = {\r\n                        data: msg.ResultContextJson,\r\n                        server: helpers_1.convertInfoToInstance(msg.Server),\r\n                        requestArguments: this_1.subscriptionsList[key].arguments || {},\r\n                        message: msg.ResultMessage,\r\n                        private: isPrivateData,\r\n                    };\r\n                    var onDataHandlers = this_1.subscriptionsList[key].handlers.onData;\r\n                    var queuedData = this_1.subscriptionsList[key].queued.data;\r\n                    if (Array.isArray(onDataHandlers)) {\r\n                        if (onDataHandlers.length > 0) {\r\n                            onDataHandlers.forEach(function (callback) {\r\n                                if (typeof callback === \"function\") {\r\n                                    callback(receivedStreamData_1);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            queuedData.push(receivedStreamData_1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var key in this.subscriptionsList) {\r\n            _loop_1(key);\r\n        }\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (sub, subId) {\r\n        var _this = this;\r\n        var responseSubject = this.nextResponseSubject();\r\n        sub.trackedServers.forEach(function (server) {\r\n            _this.sendRequest({\r\n                EventStreamAction: 2,\r\n                Client: helpers_1.convertInstance(_this.instance),\r\n                MethodRequestSubject: server.methodRequestSubject,\r\n                MethodResponseSubject: responseSubject,\r\n                StreamId: server.streamId,\r\n                EventStreamSubject: server.streamSubjects.private,\r\n            });\r\n        });\r\n        sub.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback === \"function\") {\r\n                callback({\r\n                    message: ON_CLOSE_MSG_CLIENT_INIT,\r\n                    requestArguments: sub.arguments || {},\r\n                    server: sub.trackedServers[sub.trackedServers.length - 1].server,\r\n                    stream: sub.method,\r\n                });\r\n            }\r\n        });\r\n        delete this.subscriptionsList[subId];\r\n    };\r\n    ClientStreaming.prototype.generatePrivateStreamSubject = function (methodName) {\r\n        var appInfo = helpers_1.convertInstance(this.instance);\r\n        return \"ESSpriv-jsb_\" +\r\n            appInfo.ApplicationName +\r\n            \"_on_\" +\r\n            methodName +\r\n            \"_\" +\r\n            random_1.default();\r\n    };\r\n    return ClientStreaming;\r\n}());\r\nexports.default = ClientStreaming;\r\n//# sourceMappingURL=client-streaming.js.map\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = __webpack_require__(4);\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar client_streaming_1 = __webpack_require__(56);\r\nvar helpers_1 = __webpack_require__(7);\r\nvar numberMissingHeartbeatsToRemove = 3;\r\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(connection, instance, configuration, repository) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.repository = repository;\r\n        this.respCounter = 0;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.timers = {};\r\n        this.timers = {};\r\n        this.streaming = new client_streaming_1.default(configuration, instance, function (msg) {\r\n            connection.send(\"agm\", \"MethodInvocationRequestMessage\", msg);\r\n        }, function () { return _this.nextResponseSubject(); });\r\n        this.listenForEvents();\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        this.streaming.subscribe(stream, args, targetServers, options, success, error);\r\n    };\r\n    ClientProtocol.prototype.onInvocationResult = function (callback) {\r\n        this.callbacks.add(\"onResult\", callback);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target, stuff) {\r\n        var methodInfo = method.info;\r\n        var message = {\r\n            MethodRequestSubject: methodInfo.requestSubject,\r\n            MethodResponseSubject: this.nextResponseSubject(),\r\n            Client: helpers_1.convertInstance(this.instance),\r\n            Context: {\r\n                ArgumentsJson: args,\r\n                InvocationId: id,\r\n                MethodName: methodInfo.name,\r\n                ExecutionServer: target.info,\r\n                Timeout: stuff.methodResponseTimeoutMs,\r\n            },\r\n        };\r\n        this.connection.send(\"agm\", \"MethodInvocationRequestMessage\", message);\r\n    };\r\n    ClientProtocol.prototype.nextResponseSubject = function () {\r\n        return \"resp_\" + (this.respCounter++) + \"_\" + random_1.default();\r\n    };\r\n    ClientProtocol.prototype.createServerInfo = function (instance) {\r\n        return {\r\n            machine: instance.MachineName,\r\n            pid: instance.ProcessId,\r\n            user: instance.UserName,\r\n            application: instance.ApplicationName,\r\n            environment: instance.Environment,\r\n            region: instance.Region,\r\n        };\r\n    };\r\n    ClientProtocol.prototype.createMethod = function (methodInfo) {\r\n        var method = methodInfo.Method;\r\n        return {\r\n            name: method.Name,\r\n            accepts: method.InputSignature,\r\n            returns: method.ResultSignature,\r\n            requestSubject: methodInfo.MethodRequestSubject,\r\n            description: method.Description,\r\n            displayName: method.DisplayName,\r\n            version: method.Version,\r\n            objectTypes: method.ObjectTypeRestrictions,\r\n            supportsStreaming: helpers_1.isStreamingFlagSet(method.Flags),\r\n        };\r\n    };\r\n    ClientProtocol.prototype.createServerId = function (serverInfo) {\r\n        if (serverInfo === undefined) {\r\n            return undefined;\r\n        }\r\n        return [serverInfo.application,\r\n            serverInfo.user,\r\n            serverInfo.machine,\r\n            serverInfo.started,\r\n            serverInfo.pid].join(\"/\").toLowerCase();\r\n    };\r\n    ClientProtocol.prototype.processServerPresence = function (presence, isPresence) {\r\n        var instance = presence.Instance;\r\n        var serverInfo = this.createServerInfo(instance);\r\n        var serverId = this.createServerId(serverInfo);\r\n        if (isPresence) {\r\n            serverId = this.repository.addServer(serverInfo, serverId);\r\n            if (presence.PublishingInterval) {\r\n                this.scheduleTimeout(serverId, presence.PublishingInterval);\r\n            }\r\n        }\r\n        else if (presence.PublishingInterval === 0) {\r\n            var server = this.repository.getServerById(serverId);\r\n            if (typeof server !== \"undefined\") {\r\n                this.repository.removeServerById(serverId);\r\n            }\r\n        }\r\n        if (presence.MethodDefinitions !== undefined) {\r\n            this.updateServerMethods(serverId, presence.MethodDefinitions);\r\n        }\r\n    };\r\n    ClientProtocol.prototype.scheduleTimeout = function (serverId, duration) {\r\n        var _this = this;\r\n        if (duration === -1) {\r\n            return;\r\n        }\r\n        var timer = this.timers[serverId];\r\n        if (timer !== undefined) {\r\n            clearTimeout(timer);\r\n        }\r\n        this.timers[serverId] = setTimeout(function () {\r\n            _this.repository.removeServerById(serverId);\r\n        }, duration * (numberMissingHeartbeatsToRemove + 1));\r\n    };\r\n    ClientProtocol.prototype.updateServerMethods = function (serverId, newMethods) {\r\n        var _this = this;\r\n        var oldMethods = this.repository.getServerMethodsById(serverId);\r\n        var newMethodsReduced = newMethods\r\n            .map(function (nm) { return _this.createMethod(nm); })\r\n            .reduce(function (obj, method) {\r\n            var methodId = _this.repository.createMethodId(method);\r\n            obj[methodId] = method;\r\n            return obj;\r\n        }, {});\r\n        oldMethods.forEach(function (method) {\r\n            if (newMethodsReduced[method.id] === undefined) {\r\n                _this.repository.removeServerMethod(serverId, method.id);\r\n            }\r\n            else {\r\n                delete newMethodsReduced[method.id];\r\n            }\r\n        });\r\n        Object.keys(newMethodsReduced).forEach(function (key) {\r\n            var method = newMethodsReduced[key];\r\n            _this.repository.addServerMethod(serverId, method);\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleInvokeResultMessage = function (message) {\r\n        if (message && message.EventStreamAction && message.EventStreamAction !== 0) {\r\n            this.streaming.processPublisherMsg(message);\r\n            return;\r\n        }\r\n        var server = message.Server ? this.createServerInfo(message.Server) : undefined;\r\n        var result = message.ResultContextJson;\r\n        if (result && Object.keys(result).length === 0) {\r\n            result = undefined;\r\n        }\r\n        this.callbacks.execute(\"onResult\", message.InvocationId, server, message.Status, result, message.ResultMessage);\r\n    };\r\n    ClientProtocol.prototype.listenForEvents = function () {\r\n        var _this = this;\r\n        this.connection.on(\"agm\", \"ServerPresenceMessage\", function (msg) {\r\n            _this.processServerPresence(msg, true);\r\n        });\r\n        this.connection.on(\"agm\", \"ServerHeartbeatMessage\", function (msg) {\r\n            _this.processServerPresence(msg, false);\r\n        });\r\n        this.connection.on(\"agm\", \"MethodInvocationResultMessage\", function (msg) {\r\n            _this.handleInvokeResultMessage(msg);\r\n        });\r\n    };\r\n    return ClientProtocol;\r\n}());\r\nexports.default = ClientProtocol;\r\n//# sourceMappingURL=client.js.map\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar server_1 = __webpack_require__(60);\r\nvar client_1 = __webpack_require__(57);\r\nfunction default_1(instance, connection, clientRepository, serverRepository, configuration, getAGM) {\r\n    var unsubscribe = connection.on(\"agm\", \"Instance\", function (newInstance) {\r\n        getAGM().updateInstance(newInstance);\r\n        connection.off(unsubscribe);\r\n    });\r\n    var server = new server_1.default(connection, instance, configuration, serverRepository);\r\n    var client = new client_1.default(connection, instance, configuration, clientRepository);\r\n    return new Promise(function (resolve) {\r\n        resolve({\r\n            server: server,\r\n            client: client,\r\n        });\r\n    });\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=factory.js.map\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = __webpack_require__(4);\r\nvar helpers_1 = __webpack_require__(7);\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(connection, instance) {\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n    }\r\n    ServerStreaming.prototype.isStreamMsg = function (msg, method) {\r\n        return (msg &&\r\n            msg.EventStreamAction &&\r\n            msg.EventStreamAction !== 0 &&\r\n            typeof method === \"object\" &&\r\n            method.definition.supportsStreaming === true);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = null;\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            return (branches === null || (Boolean(br) && typeof br.key === \"string\" && branches.indexOf(br.key) >= 0));\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        var server = helpers_1.convertInstance(this.instance);\r\n        streamIdList.forEach(function (streamId) {\r\n            _this.sendResult({\r\n                EventStreamAction: 5,\r\n                EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                ResultContextJson: data,\r\n                Server: server,\r\n                StreamId: streamId,\r\n            });\r\n        });\r\n    };\r\n    ServerStreaming.prototype.closeAllSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        var streamList = streamingMethod.protocolState.branchKeyToStreamIdMap;\r\n        if (typeof branchKey === \"string\") {\r\n            streamList = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (br) {\r\n                return (typeof br === \"object\" && br.key === branchKey);\r\n            });\r\n        }\r\n        streamList.forEach(function (br) {\r\n            var streamId = br.streamId;\r\n            _this.sendResult({\r\n                EventStreamAction: 2,\r\n                EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                Server: helpers_1.convertInstance(_this.instance),\r\n                StreamId: streamId,\r\n                Status: 0,\r\n            });\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        return this.getUniqueBranchNames(streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = streamingMethod.protocolState.subscriptions;\r\n        }\r\n        else {\r\n            subscriptions = streamingMethod.protocolState.subscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.subAddedHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.subRemovedHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.requestHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.generateNewStreamId = function (streamingMethodName) {\r\n        var appInfo = helpers_1.convertInstance(this.instance);\r\n        return \"streamId-jsb_of_\" +\r\n            streamingMethodName +\r\n            \"__by_\" +\r\n            appInfo.ApplicationName +\r\n            \"_\" +\r\n            random_1.default();\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        var msg = requestContext.msg;\r\n        this.sendResult({\r\n            EventStreamAction: 2,\r\n            EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            MethodResponseSubject: msg.MethodResponseSubject,\r\n            MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n            ResultMessage: reason,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: \"default_rejection_streamId\",\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (streamingMethod, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this.sendResult({\r\n            EventStreamAction: 5,\r\n            EventStreamSubject: subscription.privateEventStreamSubject,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            ResultContextJson: data,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: subscription.streamId,\r\n        });\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        this.closeIndividualSubscription(streamingMethod, subscription.streamId, subscription.privateEventStreamSubject, true);\r\n    };\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var msg = requestContext.msg;\r\n        this.sendResult({\r\n            EventStreamAction: 3,\r\n            EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n            InvocationId: msg.Context.InvocationId,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            MethodResponseSubject: msg.MethodResponseSubject,\r\n            MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n            ResultMessage: \"Accepted\",\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: streamId,\r\n        });\r\n    };\r\n    ServerStreaming.prototype.processSubscriberMsg = function (msg, streamingMethod) {\r\n        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {\r\n            return;\r\n        }\r\n        if (msg.EventStreamAction === 1) {\r\n            this.clientWishesToSubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 2) {\r\n            this.clientWishesToUnsubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 3) {\r\n            this.clientAcknowledgesItDidSubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 4) {\r\n            this.clientPerSubHeartbeat(msg);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.sendResult = function (message) {\r\n        if (typeof message !== \"object\") {\r\n            throw new Error(\"Invalid message.\");\r\n        }\r\n        if (typeof message.Status !== \"number\") {\r\n            message.Status = 0;\r\n        }\r\n        this.connection.send(\"agm\", \"MethodInvocationResultMessage\", message);\r\n    };\r\n    ServerStreaming.prototype.clientWishesToSubscribe = function (msg, streamingMethod) {\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.Context.ArgumentsJson || {},\r\n            instance: helpers_1.convertInfoToInstance(msg.Client),\r\n        };\r\n        if (typeof this.requestHandler === \"function\") {\r\n            this.requestHandler(requestContext, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.clientWishesToUnsubscribe = function (msg, streamingMethod) {\r\n        if (!(streamingMethod &&\r\n            Array.isArray(streamingMethod.protocolState.subscriptions) &&\r\n            streamingMethod.protocolState.subscriptions.length > 0)) {\r\n            return;\r\n        }\r\n        this.closeIndividualSubscription(streamingMethod, msg.StreamId, msg.EventStreamSubject, false);\r\n    };\r\n    ServerStreaming.prototype.clientAcknowledgesItDidSubscribe = function (msg, streamingMethod) {\r\n        if (typeof msg.StreamId !== \"string\" || msg.StreamId === \"\") {\r\n            return;\r\n        }\r\n        var branchKey = this.getBranchKey(streamingMethod, msg.StreamId);\r\n        if (typeof branchKey !== \"string\") {\r\n            return;\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.subscriptions)) {\r\n            return;\r\n        }\r\n        var subscription = {\r\n            branchKey: branchKey,\r\n            instance: helpers_1.convertInfoToInstance(msg.Client),\r\n            arguments: msg.Context.ArgumentsJson,\r\n            streamId: msg.StreamId,\r\n            privateEventStreamSubject: msg.EventStreamSubject,\r\n            methodResponseSubject: msg.MethodResponseSubject,\r\n        };\r\n        streamingMethod.protocolState.subscriptions.push(subscription);\r\n        if (typeof this.subAddedHandler === \"function\") {\r\n            this.subAddedHandler(subscription, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.clientPerSubHeartbeat = function (msg) {\r\n    };\r\n    ServerStreaming.prototype.getBranchKey = function (streamingMethod, streamId) {\r\n        if (typeof streamId !== \"string\" || typeof streamingMethod !== \"object\") {\r\n            return;\r\n        }\r\n        var needle = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.streamId === streamId;\r\n        })[0];\r\n        if (typeof needle !== \"object\" || typeof needle.key !== \"string\") {\r\n            return;\r\n        }\r\n        return needle.key;\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.generateNewStreamId(streamingMethod.protocolState.method.Method.Name);\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    ServerStreaming.prototype.closeIndividualSubscription = function (streamingMethod, streamId, privateEventStreamSubject, sendKickMessage) {\r\n        var subscription = streamingMethod.protocolState.subscriptions.filter(function (subItem) {\r\n            return (subItem.privateEventStreamSubject === privateEventStreamSubject &&\r\n                subItem.streamId === streamId);\r\n        })[0];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        var initialLength = streamingMethod.protocolState.subscriptions.length;\r\n        streamingMethod.protocolState.subscriptions = streamingMethod.protocolState.subscriptions.filter(function (subItem) {\r\n            return !(subItem.privateEventStreamSubject === subscription.privateEventStreamSubject &&\r\n                subItem.streamId === subscription.streamId);\r\n        });\r\n        var filteredLength = streamingMethod.protocolState.subscriptions.length;\r\n        if (filteredLength !== (initialLength - 1)) {\r\n            return;\r\n        }\r\n        if (sendKickMessage === true) {\r\n            this.sendResult({\r\n                EventStreamAction: 2,\r\n                EventStreamSubject: privateEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                MethodResponseSubject: subscription.methodResponseSubject,\r\n                MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n                ResponseContextJson: {},\r\n                Server: helpers_1.convertInstance(this.instance),\r\n                StreamId: subscription.streamId,\r\n                Status: 0,\r\n            });\r\n        }\r\n        if (typeof this.subRemovedHandler === \"function\") {\r\n            this.subRemovedHandler(subscription, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.getUniqueBranchNames = function (streamingMethod) {\r\n        var keysWithDuplicates = streamingMethod.protocolState.subscriptions.map(function (sub) {\r\n            var result = null;\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                result = sub.branchKey;\r\n            }\r\n            return result;\r\n        });\r\n        var seen = [];\r\n        var branchArray = keysWithDuplicates.filter(function (bKey) {\r\n            if (bKey === null || seen.indexOf(bKey) >= 0) {\r\n                return false;\r\n            }\r\n            seen.push(bKey);\r\n            return true;\r\n        });\r\n        return branchArray;\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=server-streaming.js.map\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = __webpack_require__(4);\r\nvar server_streaming_1 = __webpack_require__(59);\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar helpers_1 = __webpack_require__(7);\r\nvar HeartbeatInterval = 5000;\r\nvar PresenceInterval = 10000;\r\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(connection, instance, configuration, serverRepository) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n        this.serverRepository = serverRepository;\r\n        this.invocationMessagesMap = {};\r\n        this.reqCounter = 0;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.streaming = new server_streaming_1.default(connection, instance);\r\n        connection.on(\"agm\", \"MethodInvocationRequestMessage\", function (msg) { return _this.handleMethodInvocationMessage(msg); });\r\n        connection.disconnected(this.stopTimers.bind(this));\r\n        this.sendHeartbeat();\r\n        if (this.heartbeatTimer === undefined) {\r\n            this.heartbeatTimer = setInterval(function () { return _this.sendHeartbeat(); }, HeartbeatInterval);\r\n        }\r\n        this.getBranchList = this.streaming.getBranchList;\r\n        this.getSubscriptionList = this.streaming.getSubscriptionList;\r\n        this.closeAllSubscriptions = this.streaming.closeAllSubscriptions;\r\n        this.closeSingleSubscription = this.streaming.closeSingleSubscription;\r\n        this.pushDataToSingle = this.streaming.pushDataToSingle;\r\n        this.pushData = this.streaming.pushData;\r\n        this.onSubRequest = this.streaming.onSubRequest;\r\n        this.acceptRequestOnBranch = this.streaming.acceptRequestOnBranch;\r\n        this.rejectRequest = this.streaming.rejectRequest;\r\n        this.onSubAdded = this.streaming.onSubAdded;\r\n        this.onSubRemoved = this.streaming.onSubRemoved;\r\n    }\r\n    ServerProtocol.prototype.stopTimers = function () {\r\n        clearInterval(this.presenceTimer);\r\n        clearInterval(this.heartbeatTimer);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (info) {\r\n        this.sendPresence();\r\n        return Promise.resolve();\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, success, error) {\r\n        var reqSubj = this.nextRequestSubject();\r\n        repoMethod.protocolState.method = this.createNewMethodMessage(repoMethod.definition, reqSubj, false);\r\n        this.announceNewMethod();\r\n        success();\r\n        return Promise.resolve();\r\n    };\r\n    ServerProtocol.prototype.createStream = function (repoMethod, success, error) {\r\n        var reqSubj = this.nextRequestSubject();\r\n        var streamConverted = this.createNewMethodMessage(repoMethod.definition, reqSubj, true);\r\n        repoMethod.protocolState.method = streamConverted;\r\n        repoMethod.protocolState.globalEventStreamSubject = repoMethod.definition.name + \".jsStream.\" + random_1.default();\r\n        repoMethod.protocolState.subscriptions = [];\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        this.announceNewMethod();\r\n        success();\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (executedMethod, invocationId, err, result) {\r\n        var message = this.invocationMessagesMap[invocationId];\r\n        if (!message) {\r\n            return;\r\n        }\r\n        if (message.MethodResponseSubject === \"null\") {\r\n            return;\r\n        }\r\n        if (executedMethod === undefined) {\r\n            return;\r\n        }\r\n        var resultMessage = {\r\n            MethodRequestSubject: message.MethodRequestSubject,\r\n            MethodResponseSubject: message.MethodResponseSubject,\r\n            MethodName: executedMethod.protocolState.method.Method.Name,\r\n            InvocationId: invocationId,\r\n            ResultContextJson: result,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            ResultMessage: err,\r\n            Status: err ? 1 : 0,\r\n        };\r\n        this.connection.send(\"agm\", \"MethodInvocationResultMessage\", resultMessage);\r\n        delete this.invocationMessagesMap[invocationId];\r\n    };\r\n    ServerProtocol.prototype.nextRequestSubject = function () {\r\n        return \"req_\" + (this.reqCounter++) + \"_\" + random_1.default();\r\n    };\r\n    ServerProtocol.prototype.sendHeartbeat = function () {\r\n        this.connection.send(\"agm\", \"ServerHeartbeatMessage\", this.constructHeartbeat());\r\n    };\r\n    ServerProtocol.prototype.constructHeartbeat = function () {\r\n        return {\r\n            PublishingInterval: HeartbeatInterval,\r\n            Instance: helpers_1.convertInstance(this.instance),\r\n        };\r\n    };\r\n    ServerProtocol.prototype.constructPresence = function () {\r\n        var methods = this.serverRepository.getList();\r\n        return {\r\n            PublishingInterval: PresenceInterval,\r\n            Instance: helpers_1.convertInstance(this.instance),\r\n            MethodDefinitions: methods.map(function (m) { return m.protocolState.method; }),\r\n        };\r\n    };\r\n    ServerProtocol.prototype.sendPresence = function () {\r\n        this.connection.send(\"agm\", \"ServerPresenceMessage\", this.constructPresence());\r\n    };\r\n    ServerProtocol.prototype.announceNewMethod = function () {\r\n        var _this = this;\r\n        this.sendPresence();\r\n        if (this.presenceTimer === undefined) {\r\n            this.presenceTimer = setInterval(function () { return _this.sendPresence(); }, PresenceInterval);\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleMethodInvocationMessage = function (message) {\r\n        var subject = message.MethodRequestSubject;\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.protocolState.method.MethodRequestSubject === subject;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        if (this.streaming.isStreamMsg(message, method)) {\r\n            this.streaming.processSubscriberMsg(message, method);\r\n            return;\r\n        }\r\n        var invocationId = message.Context.InvocationId;\r\n        this.invocationMessagesMap[invocationId] = message;\r\n        var invocationArgs = {\r\n            args: message.Context.ArgumentsJson,\r\n            instance: helpers_1.convertInfoToInstance(message.Client),\r\n        };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    ServerProtocol.prototype.createNewMethodMessage = function (methodIdentifier, subject, stream) {\r\n        if (typeof methodIdentifier === \"string\") {\r\n            methodIdentifier = { name: methodIdentifier };\r\n        }\r\n        if (typeof methodIdentifier.version !== \"number\") {\r\n            methodIdentifier.version = 0;\r\n        }\r\n        return {\r\n            Method: {\r\n                Name: methodIdentifier.name,\r\n                InputSignature: methodIdentifier.accepts,\r\n                ResultSignature: methodIdentifier.returns,\r\n                Description: methodIdentifier.description,\r\n                DisplayName: methodIdentifier.displayName,\r\n                Version: methodIdentifier.version,\r\n                ObjectTypeRestrictions: methodIdentifier.objectTypes,\r\n                Flags: stream ? 32 : undefined,\r\n            },\r\n            MethodRequestSubject: subject,\r\n        };\r\n    };\r\n    return ServerProtocol;\r\n}());\r\nexports.default = ServerProtocol;\r\n//# sourceMappingURL=server.js.map\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(instance, session, repository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        this.nextSubLocalKey = 0;\r\n        this.handleErrorSubscribing = function (errorResponse) {\r\n            var tag = errorResponse._tag;\r\n            var subLocalKey = tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                return server.serverId !== tag.serverId;\r\n            });\r\n            if (pendingSub.trackedServers.length <= 0) {\r\n                clearTimeout(pendingSub.timeoutId);\r\n                if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                    var reason = (typeof errorResponse.reason === \"string\" && errorResponse.reason !== \"\") ?\r\n                        ' Publisher said \"' + errorResponse.reason + '\".' :\r\n                        \" No reason given.\";\r\n                    var callArgs = typeof pendingSub.arguments === \"object\" ?\r\n                        JSON.stringify(pendingSub.arguments) :\r\n                        \"{}\";\r\n                    pendingSub.error({\r\n                        message: ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs,\r\n                        called_with: pendingSub.arguments,\r\n                        method: pendingSub.method.getInfoForUser(),\r\n                    });\r\n                }\r\n                else if (pendingSub.status === STATUS_SUBSCRIBED) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                }\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n        };\r\n        this.handleSubscribed = function (msg) {\r\n            var subLocalKey = msg._tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            var serverId = msg._tag.serverId;\r\n            var acceptingServer = pendingSub.trackedServers\r\n                .filter(function (server) {\r\n                return server.serverId === serverId;\r\n            })[0];\r\n            if (typeof acceptingServer !== \"object\") {\r\n                return;\r\n            }\r\n            acceptingServer.subscriptionId = msg.subscription_id;\r\n            _this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;\r\n            var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);\r\n            pendingSub.status = STATUS_SUBSCRIBED;\r\n            var that = _this;\r\n            if (isFirstResponse) {\r\n                pendingSub.success({\r\n                    onData: function (dataCallback) {\r\n                        if (typeof dataCallback !== \"function\") {\r\n                            throw new TypeError(\"The data callback must be a function.\");\r\n                        }\r\n                        pendingSub.handlers.onData.push(dataCallback);\r\n                        if (pendingSub.handlers.onData.length === 1 && pendingSub.queued.data.length > 0) {\r\n                            pendingSub.queued.data.forEach(function (dataItem) {\r\n                                dataCallback(dataItem);\r\n                            });\r\n                        }\r\n                    },\r\n                    onClosed: function (closedCallback) {\r\n                        if (typeof closedCallback !== \"function\") {\r\n                            throw new TypeError(\"The callback must be a function.\");\r\n                        }\r\n                        pendingSub.handlers.onClosed.push(closedCallback);\r\n                    },\r\n                    onFailed: function () {\r\n                    },\r\n                    close: function () { return that.closeSubscription(subLocalKey); },\r\n                    requestArguments: pendingSub.arguments,\r\n                    serverInstance: that.repository.getServerById(serverId).getInfoForUser(),\r\n                    stream: pendingSub.method.info,\r\n                });\r\n            }\r\n        };\r\n        this.handleEventData = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var trackedServersFound = subscription.trackedServers.filter(function (server) {\r\n                return server.subscriptionId === msg.subscription_id;\r\n            });\r\n            if (trackedServersFound.length !== 1) {\r\n                return;\r\n            }\r\n            var isPrivateData = msg.oob && msg.snapshot;\r\n            var sendingServerId = trackedServersFound[0].serverId;\r\n            var receivedStreamData = function () {\r\n                return {\r\n                    data: msg.data,\r\n                    server: _this.repository.getServerById(sendingServerId).getInfoForUser(),\r\n                    requestArguments: subscription.arguments || {},\r\n                    message: null,\r\n                    private: isPrivateData,\r\n                };\r\n            };\r\n            var onDataHandlers = subscription.handlers.onData;\r\n            var queuedData = subscription.queued.data;\r\n            if (onDataHandlers.length > 0) {\r\n                onDataHandlers.forEach(function (callback) {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(receivedStreamData());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                queuedData.push(receivedStreamData());\r\n            }\r\n        };\r\n        this.handleSubscriptionCancelled = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var expectedNewLength = subscription.trackedServers.length - 1;\r\n            subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                if (server.subscriptionId === msg.subscription_id) {\r\n                    subscription.queued.closers.push(server.serverId);\r\n                    return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            });\r\n            if (subscription.trackedServers.length !== expectedNewLength) {\r\n                return;\r\n            }\r\n            if (subscription.trackedServers.length <= 0) {\r\n                clearTimeout(subscription.timeoutId);\r\n                _this.callOnClosedHandlers(subscription);\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            delete _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n        };\r\n        session.on(\"subscribed\", this.handleSubscribed);\r\n        session.on(\"event\", this.handleEventData);\r\n        session.on(\"subscription-cancelled\", this.handleSubscriptionCancelled);\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (streamingMethod, argumentObj, targetServers, stuff, success, error) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: streamingMethod.getInfoForUser(),\r\n                called_with: argumentObj,\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n            });\r\n            return;\r\n        }\r\n        var subLocalKey = this.getNextSubscriptionLocalKey();\r\n        var pendingSub = this.registerSubscription(subLocalKey, streamingMethod, argumentObj, success, error, stuff.methodResponseTimeout);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: streamingMethod.getInfoForUser(),\r\n                called_with: argumentObj,\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var serverId = target.server.id;\r\n            pendingSub.trackedServers.push({\r\n                serverId: serverId,\r\n                subscriptionId: undefined,\r\n            });\r\n            var msg = {\r\n                type: \"subscribe\",\r\n                server_id: serverId,\r\n                method_id: streamingMethod.protocolState.id,\r\n                arguments_kv: argumentObj,\r\n            };\r\n            _this.session.send(msg, { serverId: serverId, subLocalKey: subLocalKey })\r\n                .then(function (m) { return _this.handleSubscribed(m); })\r\n                .catch(function (err) { return _this.handleErrorSubscribing(err); });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.getNextSubscriptionLocalKey = function () {\r\n        var current = this.nextSubLocalKey;\r\n        this.nextSubLocalKey += 1;\r\n        return current;\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subLocalKey, method, args, success, error, timeout) {\r\n        var _this = this;\r\n        this.subscriptionsList[subLocalKey] = {\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            arguments: args,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: [],\r\n                onClosed: [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n        };\r\n        this.subscriptionsList[subLocalKey].timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subLocalKey] === undefined) {\r\n                return;\r\n            }\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method.getInfoForUser(),\r\n                    called_with: args,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \" ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {\r\n                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                    return (typeof server.subscriptionId !== \"undefined\");\r\n                });\r\n                delete pendingSub.timeoutId;\r\n                if (pendingSub.trackedServers.length <= 0) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                    delete _this.subscriptionsList[subLocalKey];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return this.subscriptionsList[subLocalKey];\r\n    };\r\n    ClientStreaming.prototype.callOnClosedHandlers = function (subscription, reason) {\r\n        var closersCount = subscription.queued.closers.length;\r\n        var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n        var closingServer = null;\r\n        if (typeof closingServerId === \"number\") {\r\n            closingServer = this.repository.getServerById(closingServerId).getInfoForUser();\r\n        }\r\n        subscription.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback !== \"function\") {\r\n                return;\r\n            }\r\n            callback({\r\n                message: reason || ON_CLOSE_MSG_SERVER_INIT,\r\n                requestArguments: subscription.arguments,\r\n                server: closingServer,\r\n                stream: subscription.method,\r\n            });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (subLocalKey) {\r\n        var _this = this;\r\n        var subscription = this.subscriptionsList[subLocalKey];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        subscription.trackedServers.forEach(function (server) {\r\n            if (typeof server.subscriptionId === \"undefined\") {\r\n                return;\r\n            }\r\n            _this.session.sendFireAndForget({\r\n                type: \"unsubscribe\",\r\n                subscription_id: server.subscriptionId,\r\n                reason_uri: \"\",\r\n                reason: ON_CLOSE_MSG_CLIENT_INIT,\r\n            });\r\n            delete _this.subscriptionIdToLocalKeyMap[server.subscriptionId];\r\n        });\r\n        subscription.trackedServers = [];\r\n        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);\r\n        delete this.subscriptionsList[subLocalKey];\r\n    };\r\n    return ClientStreaming;\r\n}());\r\nexports.default = ClientStreaming;\r\n//# sourceMappingURL=client-streaming.js.map\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar client_streaming_1 = __webpack_require__(61);\r\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(instance, session, repository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.callbacks = callback_registry_1.default();\r\n        session.on(\"peer-added\", function (msg) { return _this.handlePeerAdded(msg); });\r\n        session.on(\"peer-removed\", function (msg) { return _this.handlePeerRemoved(msg); });\r\n        session.on(\"methods-added\", function (msg) { return _this.handleMethodsAddedMessage(msg); });\r\n        session.on(\"methods-removed\", function (msg) { return _this.handleMethodsRemovedMessage(msg); });\r\n        this.streaming = new client_streaming_1.default(instance, session, repository, logger);\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        this.streaming.subscribe(stream, args, targetServers, options, success, error);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target) {\r\n        var _this = this;\r\n        var serverId = target.id;\r\n        var methodId = method.protocolState.id;\r\n        var msg = {\r\n            type: \"call\",\r\n            server_id: serverId,\r\n            method_id: methodId,\r\n            arguments_kv: args,\r\n        };\r\n        this.session.send(msg, { invocationId: id, serverId: serverId })\r\n            .then(function (m) { return _this.handleResultMessage(m); })\r\n            .catch(function (err) { return _this.handleInvocationError(err); });\r\n    };\r\n    ClientProtocol.prototype.onInvocationResult = function (callback) {\r\n        this.callbacks.add(\"onResult\", callback);\r\n    };\r\n    ClientProtocol.prototype.handlePeerAdded = function (msg) {\r\n        var newPeerId = msg.new_peer_id;\r\n        var remoteId = msg.identity;\r\n        var pid = Number(remoteId.process);\r\n        var serverInfo = {\r\n            machine: remoteId.machine,\r\n            pid: isNaN(pid) ? remoteId.process : pid,\r\n            instance: remoteId.instance,\r\n            application: remoteId.application,\r\n            environment: remoteId.environment,\r\n            region: remoteId.region,\r\n            user: remoteId.user,\r\n            windowId: remoteId.windowId,\r\n            peerId: newPeerId,\r\n        };\r\n        this.repository.addServer(serverInfo, newPeerId);\r\n    };\r\n    ClientProtocol.prototype.handlePeerRemoved = function (msg) {\r\n        var removedPeerId = msg.removed_id;\r\n        var reason = msg.reason;\r\n        this.repository.removeServerById(removedPeerId, reason);\r\n    };\r\n    ClientProtocol.prototype.handleMethodsAddedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methods = msg.methods;\r\n        methods.forEach(function (method) {\r\n            var methodInfo = {\r\n                name: method.name,\r\n                displayName: method.display_name,\r\n                description: method.description,\r\n                version: method.version,\r\n                objectTypes: method.object_types || [],\r\n                accepts: method.input_signature,\r\n                returns: method.result_signature,\r\n                supportsStreaming: typeof method.flags !== \"undefined\" ? method.flags.streaming : false,\r\n            };\r\n            _this.repository.addServerMethod(serverId, methodInfo, { id: method.id });\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleMethodsRemovedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methodIdList = msg.methods;\r\n        var server = this.repository.getServerById(serverId);\r\n        var serverMethodKeys = Object.keys(server.methods);\r\n        serverMethodKeys.forEach(function (methodKey) {\r\n            var method = server.methods[methodKey];\r\n            if (methodIdList.indexOf(method.protocolState.id) > -1) {\r\n                _this.repository.removeServerMethod(serverId, methodKey);\r\n            }\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleResultMessage = function (msg) {\r\n        var invocationId = msg._tag.invocationId;\r\n        var result = msg.result;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        this.callbacks.execute(\"onResult\", invocationId, server.getInfoForUser(), 0, result, \"\");\r\n    };\r\n    ClientProtocol.prototype.handleInvocationError = function (msg) {\r\n        this.logger.debug(\"handle invocation error \" + JSON.stringify(msg));\r\n        var invocationId = msg._tag.invocationId;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        var message = msg.reason;\r\n        var context = msg.context;\r\n        this.callbacks.execute(\"onResult\", invocationId, server.getInfoForUser(), 1, context, message);\r\n    };\r\n    return ClientProtocol;\r\n}());\r\nexports.default = ClientProtocol;\r\n//# sourceMappingURL=client.js.map\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar server_1 = __webpack_require__(65);\r\nvar client_1 = __webpack_require__(62);\r\nfunction default_1(instance, connection, clientRepository, serverRepository, libConfig, getAGM) {\r\n    var logger = libConfig.logger.subLogger(\"gw3-protocol\");\r\n    var resolveReadyPromise;\r\n    var readyPromise = new Promise(function (resolve) {\r\n        resolveReadyPromise = resolve;\r\n    });\r\n    var session = connection.domain(\"agm\", logger.subLogger(\"domain\"), [\"subscribed\"]);\r\n    var server = new server_1.default(instance, session, clientRepository, serverRepository, logger.subLogger(\"server\"));\r\n    var client = new client_1.default(instance, session, clientRepository, logger.subLogger(\"client\"));\r\n    function handleReconnect() {\r\n        logger.info(\"reconnected - will replay registered methods and subscriptions\");\r\n        clientRepository.reset();\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        var registeredMethods = serverRepository.getList();\r\n        serverRepository.reset();\r\n        registeredMethods.forEach(function (method) {\r\n            var def = method.definition;\r\n            if (method.theFunction.userCallback) {\r\n                getAGM().register(def, method.theFunction.userCallback);\r\n            }\r\n            else if (method.theFunction.userCallbackAsync) {\r\n                getAGM().registerAsync(def, method.theFunction.userCallbackAsync);\r\n            }\r\n        });\r\n    }\r\n    function handleInitialJoin() {\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        resolveReadyPromise({\r\n            client: client,\r\n            server: server,\r\n        });\r\n        resolveReadyPromise = undefined;\r\n    }\r\n    session.onJoined(function (reconnect) {\r\n        if (reconnect) {\r\n            handleReconnect();\r\n        }\r\n        else {\r\n            handleInitialJoin();\r\n        }\r\n    });\r\n    session.join();\r\n    return readyPromise;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=factory.js.map\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar SUBSCRIPTION_REQUEST = \"onSubscriptionRequest\";\r\nvar SUBSCRIPTION_ADDED = \"onSubscriptionAdded\";\r\nvar SUBSCRIPTION_REMOVED = \"onSubscriptionRemoved\";\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(instance, session, repository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.ERR_URI_SUBSCRIPTION_FAILED = \"com.tick42.agm.errors.subscription.failure\";\r\n        this.callbacks = callback_registry_1.default();\r\n        this.nextStreamId = 0;\r\n        session.on(\"add-interest\", function (msg) { _this.handleAddInterest(msg); });\r\n        session.on(\"remove-interest\", function (msg) { _this.handleRemoveInterest(msg); });\r\n    }\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            throw new TypeError(\"The streaming method is missing its subscriptions.\");\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            throw new TypeError(\"The streaming method is missing its branches.\");\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var key = requestContext.msg.subscription_id;\r\n        var subscription = {\r\n            id: key,\r\n            arguments: requestContext.arguments,\r\n            instance: requestContext.instance,\r\n            branchKey: branch,\r\n            streamId: streamId,\r\n            subscribeMsg: requestContext.msg,\r\n        };\r\n        streamingMethod.protocolState.subscriptionsMap[key] = subscription;\r\n        this.session.sendFireAndForget({\r\n            type: \"accepted\",\r\n            subscription_id: key,\r\n            stream_id: streamId,\r\n        });\r\n        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        this.sendSubscriptionFailed(\"Subscription rejected by user. \" + reason, requestContext.msg.subscription_id);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = null;\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            return (branches === null || (Boolean(br) && typeof br.key === \"string\" && branches.indexOf(br.key) >= 0));\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        streamIdList.forEach(function (streamId) {\r\n            var publishMessage = {\r\n                type: \"publish\",\r\n                stream_id: streamId,\r\n                data: data,\r\n            };\r\n            _this.session.sendFireAndForget(publishMessage);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        var postMessage = {\r\n            type: \"post\",\r\n            subscription_id: subscription.id,\r\n            data: data,\r\n        };\r\n        this.session.sendFireAndForget(postMessage);\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n        var dropSubscriptionMessage = {\r\n            type: \"drop-subscription\",\r\n            subscription_id: subscription.id,\r\n            reason: \"Server dropping a single subscription\",\r\n        };\r\n        this.session.sendFireAndForget(dropSubscriptionMessage);\r\n        var subscriber = subscription.instance;\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.closeMultipleSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            return;\r\n        }\r\n        var subscriptionsToClose = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey === \"string\") {\r\n            subscriptionsToClose = subscriptionsToClose.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        subscriptionsToClose.forEach(function (subscription) {\r\n            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n            var drop = {\r\n                type: \"drop-subscription\",\r\n                subscription_id: subscription.id,\r\n                reason: \"Server dropping all subscriptions on stream_id: \" + subscription.streamId,\r\n            };\r\n            _this.session.sendFireAndForget(drop);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        var allSubscriptions = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = allSubscriptions;\r\n        }\r\n        else {\r\n            subscriptions = allSubscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var allSubscriptions = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        var keysWithDuplicates = allSubscriptions.map(function (sub) {\r\n            var result = null;\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                result = sub.branchKey;\r\n            }\r\n            return result;\r\n        });\r\n        var seen = [];\r\n        var branchArray = keysWithDuplicates.filter(function (bKey) {\r\n            if (bKey === null || seen.indexOf(bKey) >= 0) {\r\n                return false;\r\n            }\r\n            seen.push(bKey);\r\n            return true;\r\n        });\r\n        return branchArray;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);\r\n    };\r\n    ServerStreaming.prototype.handleRemoveInterest = function (msg) {\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (typeof msg.subscription_id !== \"string\" ||\r\n            typeof streamingMethod !== \"object\" ||\r\n            typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== \"object\") {\r\n            return;\r\n        }\r\n        var subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.onSubscriptionLifetimeEvent = function (eventName, handlerFunc) {\r\n        this.callbacks.add(eventName, handlerFunc);\r\n    };\r\n    ServerStreaming.prototype.getNextStreamId = function () {\r\n        return this.nextStreamId++ + \"\";\r\n    };\r\n    ServerStreaming.prototype.handleAddInterest = function (msg) {\r\n        var caller = this.repository.getServerById(msg.caller_id);\r\n        var instance = (typeof caller.getInfoForUser === \"function\") ? caller.getInfoForUser() : null;\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.arguments_kv || {},\r\n            instance: instance,\r\n        };\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (streamingMethod === undefined) {\r\n            var errorMsg = \"No method with id \" + msg.method_id + \" on this server.\";\r\n            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);\r\n            return;\r\n        }\r\n        if (streamingMethod.protocolState.subscriptionsMap &&\r\n            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {\r\n            this.sendSubscriptionFailed(\"A subscription with id \" + msg.subscription_id + \" already exists.\", msg.subscription_id);\r\n            return;\r\n        }\r\n        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.sendSubscriptionFailed = function (reason, subscriptionId) {\r\n        var errorMessage = {\r\n            type: \"error\",\r\n            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,\r\n            reason: reason,\r\n            request_id: subscriptionId,\r\n        };\r\n        this.session.sendFireAndForget(errorMessage);\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.getNextStreamId();\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=server-streaming.js.map\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar server_streaming_1 = __webpack_require__(64);\r\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(instance, session, clientRepository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.streaming = new server_streaming_1.default(instance, session, clientRepository, serverRepository, logger);\r\n        this.session.on(\"invoke\", function (msg) { return _this.handleInvokeMessage(msg); });\r\n    }\r\n    ServerProtocol.prototype.createStream = function (repoMethod, success, error) {\r\n        var isStreaming = true;\r\n        repoMethod.protocolState.subscriptionsMap = {};\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        this.register(repoMethod, success, error, isStreaming);\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, success, error, isStreaming) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDef, flags, registerMsg;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodDef = repoMethod.definition;\r\n                        repoMethod.protocolState.registrationCallbacks = {\r\n                            success: success,\r\n                            fail: error,\r\n                        };\r\n                        flags = { streaming: isStreaming || false };\r\n                        this.logger.debug('registering method \"' + methodDef.name + '\"');\r\n                        registerMsg = {\r\n                            type: \"register\",\r\n                            methods: [{\r\n                                    id: repoMethod.repoId,\r\n                                    name: methodDef.name,\r\n                                    display_name: methodDef.displayName,\r\n                                    description: methodDef.description,\r\n                                    version: methodDef.version,\r\n                                    flags: flags,\r\n                                    object_types: methodDef.objectTypes || methodDef.object_types,\r\n                                    input_signature: methodDef.accepts,\r\n                                    result_signature: methodDef.returns,\r\n                                    restrictions: undefined,\r\n                                }],\r\n                        };\r\n                        return [4, this.session.send(registerMsg, { methodId: repoMethod.repoId })\r\n                                .then(function (msg) { return _this.handleRegisteredMessage(msg); })\r\n                                .catch(function (err) { return _this.handleErrorRegister(err); })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (method, invocationId, err, result) {\r\n        var msg;\r\n        if (err) {\r\n            msg = {\r\n                type: \"error\",\r\n                request_id: invocationId,\r\n                reason_uri: \"agm.errors.client_error\",\r\n                reason: err,\r\n                context: result,\r\n                peer_id: undefined,\r\n            };\r\n        }\r\n        else {\r\n            msg = {\r\n                type: \"yield\",\r\n                invocation_id: invocationId,\r\n                peer_id: this.session.peerId,\r\n                result: result,\r\n                request_id: undefined,\r\n            };\r\n        }\r\n        this.session.sendFireAndForget(msg);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (method) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var msg;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        msg = {\r\n                            type: \"unregister\",\r\n                            methods: [method.repoId],\r\n                        };\r\n                        return [4, this.session.send(msg)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.getBranchList = function (method) {\r\n        return this.streaming.getBranchList(method);\r\n    };\r\n    ServerProtocol.prototype.getSubscriptionList = function (method, branchKey) {\r\n        return this.streaming.getSubscriptionList(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.closeAllSubscriptions = function (method, branchKey) {\r\n        this.streaming.closeMultipleSubscriptions(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.pushData = function (method, data, branches) {\r\n        this.streaming.pushData(method, data, branches);\r\n    };\r\n    ServerProtocol.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        this.streaming.pushDataToSingle(method, subscription, data);\r\n    };\r\n    ServerProtocol.prototype.closeSingleSubscription = function (method, subscription) {\r\n        this.streaming.closeSingleSubscription(method, subscription);\r\n    };\r\n    ServerProtocol.prototype.acceptRequestOnBranch = function (requestContext, method, branch) {\r\n        this.streaming.acceptRequestOnBranch(requestContext, method, branch);\r\n    };\r\n    ServerProtocol.prototype.rejectRequest = function (requestContext, method, reason) {\r\n        this.streaming.rejectRequest(requestContext, method, reason);\r\n    };\r\n    ServerProtocol.prototype.onSubRequest = function (callback) {\r\n        this.streaming.onSubRequest(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubAdded = function (callback) {\r\n        this.streaming.onSubAdded(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubRemoved = function (callback) {\r\n        this.streaming.onSubRemoved(callback);\r\n    };\r\n    ServerProtocol.prototype.handleRegisteredMessage = function (msg) {\r\n        var methodId = msg._tag.methodId;\r\n        var repoMethod = this.serverRepository.getById(methodId);\r\n        if (repoMethod && repoMethod.protocolState.registrationCallbacks) {\r\n            this.logger.debug(\"registered method \" + repoMethod.definition.name + \" with id \" + methodId);\r\n            repoMethod.protocolState.registrationCallbacks.success();\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleErrorRegister = function (msg) {\r\n        this.logger.warn(JSON.stringify(msg));\r\n        var methodId = msg._tag.methodId;\r\n        var repoMethod = this.serverRepository.getById(methodId);\r\n        if (repoMethod && repoMethod.protocolState.registrationCallbacks) {\r\n            this.logger.debug(\"failed to register method \" + repoMethod.definition.name + \" with id \" + methodId);\r\n            repoMethod.protocolState.registrationCallbacks.fail();\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleInvokeMessage = function (msg) {\r\n        var invocationId = msg.invocation_id;\r\n        var callerId = msg.caller_id;\r\n        var methodId = msg.method_id;\r\n        var args = msg.arguments_kv;\r\n        this.logger.debug('received invocation for method id \"' + methodId + '\" from peer ' + callerId);\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.repoId === methodId;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        var client = this.clientRepository.getServerById(callerId);\r\n        var invocationArgs = { args: args, instance: client.getInfoForUser() };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    return ServerProtocol;\r\n}());\r\nexports.default = ServerProtocol;\r\n//# sourceMappingURL=server.js.map\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = __webpack_require__(11);\r\nvar ServerBranch = (function () {\r\n    function ServerBranch(key, protocol, repoMethod) {\r\n        this.key = key;\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n    }\r\n    ServerBranch.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);\r\n        return subList.map(function (sub) {\r\n            return new subscription_1.default(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    ServerBranch.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);\r\n    };\r\n    ServerBranch.prototype.push = function (data) {\r\n        this.protocol.server.pushData(this.repoMethod, data, [this.key]);\r\n    };\r\n    return ServerBranch;\r\n}());\r\nexports.default = ServerBranch;\r\n//# sourceMappingURL=branch.js.map\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerRepository = (function () {\r\n    function ServerRepository() {\r\n        this.nextId = 0;\r\n        this.methods = [];\r\n    }\r\n    ServerRepository.prototype.add = function (method) {\r\n        if (typeof method !== \"object\") {\r\n            return;\r\n        }\r\n        if (method.repoId !== undefined) {\r\n            return;\r\n        }\r\n        method.repoId = String(this.nextId);\r\n        this.nextId += 1;\r\n        this.methods.push(method);\r\n        return method;\r\n    };\r\n    ServerRepository.prototype.remove = function (repoId) {\r\n        if (typeof repoId !== \"string\") {\r\n            return new TypeError(\"Expecting a string\");\r\n        }\r\n        this.methods = this.methods.filter(function (m) {\r\n            return m.repoId !== repoId;\r\n        });\r\n    };\r\n    ServerRepository.prototype.getById = function (id) {\r\n        if (typeof id !== \"string\") {\r\n            return undefined;\r\n        }\r\n        return this.methods.filter(function (m) {\r\n            return m.repoId === id;\r\n        })[0];\r\n    };\r\n    ServerRepository.prototype.getList = function () {\r\n        return this.methods.map(function (m) { return m; });\r\n    };\r\n    ServerRepository.prototype.length = function () {\r\n        return this.methods.length;\r\n    };\r\n    ServerRepository.prototype.reset = function () {\r\n        this.methods = [];\r\n    };\r\n    return ServerRepository;\r\n}());\r\nexports.default = ServerRepository;\r\n//# sourceMappingURL=repository.js.map\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Request = (function () {\r\n    function Request(protocol, repoMethod, requestContext) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.requestContext = requestContext;\r\n        this.arguments = requestContext.arguments;\r\n        this.instance = requestContext.instance;\r\n    }\r\n    Request.prototype.accept = function () {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, \"\");\r\n    };\r\n    Request.prototype.acceptOnBranch = function (branch) {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);\r\n    };\r\n    Request.prototype.reject = function (reason) {\r\n        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);\r\n    };\r\n    return Request;\r\n}());\r\nexports.default = Request;\r\n//# sourceMappingURL=request.js.map\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar promisify_1 = __webpack_require__(10);\r\nvar streaming_1 = __webpack_require__(71);\r\nvar stream_1 = __webpack_require__(70);\r\nvar Server = (function () {\r\n    function Server(protocol, serverRepository, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.serverRepository = serverRepository;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.invocations = 0;\r\n        this.streaming = new streaming_1.default(protocol, this);\r\n        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));\r\n    }\r\n    Server.prototype.register = function (methodDefinition, callback) {\r\n        if (methodDefinition === undefined) {\r\n            return Promise.reject(\"Please supply either a string of the Unique name or an object with property name\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be the callback function\");\r\n        }\r\n        var wrappedCallbackFunction = function (context, resultCallback) {\r\n            try {\r\n                var result = callback(context.args, context.instance);\r\n                resultCallback(null, result);\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, e);\r\n            }\r\n        };\r\n        wrappedCallbackFunction.userCallback = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallbackFunction);\r\n    };\r\n    Server.prototype.registerAsync = function (methodDefinition, callback) {\r\n        if (methodDefinition === undefined) {\r\n            return Promise.reject(\"Please supply either a string of the Unique name or an object with property name\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be the callback function\");\r\n        }\r\n        var wrappedCallback = function (context, resultCallback) {\r\n            try {\r\n                callback(context.args, context.instance, function (result) {\r\n                    resultCallback(null, result);\r\n                }, function (e) {\r\n                    resultCallback(e, e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, null);\r\n            }\r\n        };\r\n        wrappedCallback.userCallbackAsync = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallback);\r\n    };\r\n    Server.prototype.registerCore = function (method, theFunction) {\r\n        var _this = this;\r\n        var methodDefinition;\r\n        if (typeof method === \"string\") {\r\n            methodDefinition = { name: \"\" + method };\r\n        }\r\n        else {\r\n            methodDefinition = __assign({}, method);\r\n        }\r\n        var nameAlreadyExists = this.serverRepository.getList()\r\n            .some(function (serverMethod) { return serverMethod.definition.name === methodDefinition.name; });\r\n        if (nameAlreadyExists) {\r\n            return Promise.reject(\"Name already exists !\");\r\n        }\r\n        if (methodDefinition.supportsStreaming) {\r\n            return Promise.reject(\"supportsStreaming can not be true ! If you want to create a stream please use glue.agm.createStream\");\r\n        }\r\n        var repoMethod = this.serverRepository.add({\r\n            definition: methodDefinition,\r\n            theFunction: theFunction,\r\n            protocolState: {},\r\n        });\r\n        return this.protocol.server.register(repoMethod, function () {\r\n        }, function () {\r\n            _this.serverRepository.remove(repoMethod.repoId);\r\n        });\r\n    };\r\n    Server.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof streamDef === \"string\") {\r\n                if (streamDef === \"\") {\r\n                    reject(\"Invalid stream name - can not be empty\");\r\n                }\r\n                streamDef = { name: streamDef };\r\n            }\r\n            streamDef.supportsStreaming = true;\r\n            if (!callbacks) {\r\n                callbacks = {};\r\n            }\r\n            if (typeof callbacks.subscriptionRequestHandler !== \"function\") {\r\n                callbacks.subscriptionRequestHandler = function (request) {\r\n                    request.accept();\r\n                };\r\n            }\r\n            var repoMethod = {\r\n                definition: streamDef,\r\n                streamCallbacks: callbacks,\r\n                protocolState: {},\r\n            };\r\n            _this.serverRepository.add(repoMethod);\r\n            _this.protocol.server.createStream(repoMethod, function () {\r\n                var streamFrontObject = new stream_1.default(_this.protocol, repoMethod, _this);\r\n                repoMethod.stream = streamFrontObject;\r\n                resolve(streamFrontObject);\r\n            }, function (err) {\r\n                _this.serverRepository.remove(repoMethod.repoId);\r\n                reject(err);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    Server.prototype.unregister = function (methodFilter, forStream) {\r\n        if (forStream === void 0) { forStream = false; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDefinition, methodToBeRemoved;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (methodFilter === undefined) {\r\n                            return [2, Promise.reject(\"Please supply either a string of the Unique name or an object with property name\")];\r\n                        }\r\n                        if (!(typeof methodFilter === \"function\")) return [3, 2];\r\n                        return [4, this.unregisterWithPredicate(methodFilter, forStream)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                    case 2:\r\n                        if (typeof methodFilter === \"string\") {\r\n                            methodDefinition = { name: methodFilter };\r\n                        }\r\n                        else {\r\n                            methodDefinition = methodFilter;\r\n                        }\r\n                        if (methodDefinition.name === undefined) {\r\n                            return [2, Promise.reject(\"Method with undefined name does not exist !\")];\r\n                        }\r\n                        methodToBeRemoved = this.serverRepository.getList().find(function (serverMethod) {\r\n                            return serverMethod.definition.name === methodDefinition.name\r\n                                && (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodToBeRemoved) {\r\n                            return [2, Promise.reject(\"Method does not exist or it is not registered by your application !\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams([methodToBeRemoved])];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.unregisterWithPredicate = function (filterPredicate, forStream) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodsOrStreamsToRemove;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodsOrStreamsToRemove = this.serverRepository.getList()\r\n                            .filter(function (sm) { return filterPredicate(sm.definition); })\r\n                            .filter(function (serverMethod) {\r\n                            return (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {\r\n                            return [2, Promise.reject(\"No \" + (forStream ? \"stream\" : \"method\") + \" matches the condition !\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams(methodsOrStreamsToRemove)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.removeMethodsOrStreams = function (methodsToRemove) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, Promise.all(methodsToRemove.map(function (method) { return __awaiter(_this, void 0, void 0, function () {\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0: return [4, this.protocol.server.unregister(method)];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        this.serverRepository.remove(method.repoId);\r\n                                        return [2];\r\n                                }\r\n                            });\r\n                        }); }))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.containsProps = function (filter, methodDefinition) {\r\n        var filterProps = Object.keys(filter)\r\n            .filter(function (prop) {\r\n            return typeof filter[prop] !== \"function\"\r\n                && prop !== \"object_types\"\r\n                && prop !== \"display_name\";\r\n        });\r\n        var methodDefProps = Object.keys(methodDefinition);\r\n        var uniqProps = Array.from(new Set(filterProps.concat(methodDefProps)));\r\n        return uniqProps.reduce(function (isMatch, prop) {\r\n            var filterValue = filter[prop];\r\n            var methodDefValue = methodDefinition[prop];\r\n            if (prop === \"supportsStreaming\") {\r\n                methodDefValue = methodDefValue || false;\r\n                filterValue = filterValue || false;\r\n            }\r\n            if (prop === \"objectTypes\" && filterValue !== undefined && methodDefValue !== undefined) {\r\n                if (filterValue.length !== methodDefValue.length) {\r\n                    isMatch = false;\r\n                }\r\n                else {\r\n                    var firstObjType = filterValue.sort();\r\n                    var secondObjTypes_1 = methodDefValue.sort();\r\n                    var hasADifference = firstObjType.some(function (objType, index) { return objType !== secondObjTypes_1[index]; });\r\n                    if (hasADifference) {\r\n                        isMatch = false;\r\n                    }\r\n                }\r\n            }\r\n            else if (filterValue !== methodDefValue) {\r\n                isMatch = false;\r\n            }\r\n            return isMatch;\r\n        }, true);\r\n    };\r\n    Server.prototype.onMethodInvoked = function (methodToExecute, invocationId, invocationArgs) {\r\n        var _this = this;\r\n        if (!methodToExecute) {\r\n            return;\r\n        }\r\n        methodToExecute.theFunction(invocationArgs, function (err, result) {\r\n            if (err) {\r\n                if (typeof err.message === \"string\") {\r\n                    err = err.message;\r\n                }\r\n                else if (typeof err !== \"string\") {\r\n                    try {\r\n                        err = JSON.stringify(err);\r\n                    }\r\n                    catch (unStrException) {\r\n                        err = \"un-stringifyable error in onMethodInvoked ! Top level prop names: \" + Object.keys(err);\r\n                    }\r\n                }\r\n            }\r\n            if (!result || typeof result !== \"object\" || result.constructor === Array) {\r\n                result = { _result: result };\r\n            }\r\n            _this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);\r\n        });\r\n    };\r\n    return Server;\r\n}());\r\nexports.default = Server;\r\n//# sourceMappingURL=server.js.map\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = __webpack_require__(11);\r\nvar branch_1 = __webpack_require__(66);\r\nvar ServerStream = (function () {\r\n    function ServerStream(protocol, repoMethod, server) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.server = server;\r\n        this.def = repoMethod.definition;\r\n    }\r\n    Object.defineProperty(ServerStream.prototype, \"name\", {\r\n        get: function () { return this.def.name; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.branches = function (key) {\r\n        var _this = this;\r\n        var bList = this.protocol.server.getBranchList(this.repoMethod);\r\n        if (key) {\r\n            if (bList.indexOf(key) > -1) {\r\n                return new branch_1.default(key, this.protocol, this.repoMethod);\r\n            }\r\n            return undefined;\r\n        }\r\n        else {\r\n            return bList.map(function (branchKey) {\r\n                return new branch_1.default(branchKey, _this.protocol, _this.repoMethod);\r\n            });\r\n        }\r\n    };\r\n    ServerStream.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod);\r\n        return subList.map(function (sub) {\r\n            return new subscription_1.default(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    Object.defineProperty(ServerStream.prototype, \"definition\", {\r\n        get: function () {\r\n            var def2 = this.def;\r\n            return {\r\n                accepts: def2.accepts,\r\n                description: def2.description,\r\n                displayName: def2.displayName,\r\n                name: def2.name,\r\n                objectTypes: def2.objectTypes,\r\n                returns: def2.returns,\r\n                supportsStreaming: def2.supportsStreaming,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod);\r\n        this.server.unregister(this.repoMethod.definition, true);\r\n    };\r\n    ServerStream.prototype.push = function (data, branches) {\r\n        if (typeof branches !== \"string\" && !Array.isArray(branches) && branches !== undefined) {\r\n            throw new Error(\"invalid branches should be string or string array\");\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this.protocol.server.pushData(this.repoMethod, data, branches);\r\n    };\r\n    return ServerStream;\r\n}());\r\nexports.default = ServerStream;\r\n//# sourceMappingURL=stream.js.map\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = __webpack_require__(11);\r\nvar request_1 = __webpack_require__(68);\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(protocol, server) {\r\n        var _this = this;\r\n        this.protocol = protocol;\r\n        this.server = server;\r\n        protocol.server.onSubRequest(function (rc, rm) { return _this.handleSubRequest(rc, rm); });\r\n        protocol.server.onSubAdded(function (sub, rm) { return _this.handleSubAdded(sub, rm); });\r\n        protocol.server.onSubRemoved(function (sub, rm) { return _this.handleSubRemoved(sub, rm); });\r\n    }\r\n    ServerStreaming.prototype.handleSubRequest = function (requestContext, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var request = new request_1.default(this.protocol, repoMethod, requestContext);\r\n        repoMethod.streamCallbacks.subscriptionRequestHandler(request);\r\n    };\r\n    ServerStreaming.prototype.handleSubAdded = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new subscription_1.default(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);\r\n    };\r\n    ServerStreaming.prototype.handleSubRemoved = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new subscription_1.default(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=streaming.js.map\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar protocol_1 = __webpack_require__(73);\r\nvar successMessages = ['subscribed', 'success'];\r\nexports.default = (function (configuration) {\r\n    var connection = configuration.connection, logger = configuration.logger;\r\n    var session = connection.domain('bus', logger, successMessages);\r\n    return new Promise(function (resolve, reject) {\r\n        session.join()\r\n            .then(function () {\r\n            var protocol = protocol_1.default(connection, logger, session);\r\n            resolve(protocol);\r\n        })\r\n            .catch(reject);\r\n    });\r\n});\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(74);\r\n;\r\nvar Protocol = (function () {\r\n    function Protocol(connection, logger, session) {\r\n        var _this = this;\r\n        this.publish = function (topic, data, options) {\r\n            var _a = options || {}, _b = _a.routingKey, routingKey = _b === void 0 ? undefined : _b, _c = _a.target, target = _c === void 0 ? undefined : _c;\r\n            var args = utils_1.removeEmptyValues({\r\n                type: 'publish',\r\n                topic: topic,\r\n                data: data,\r\n                peer_id: _this.peerId,\r\n                routing_key: routingKey,\r\n                target_identity: target\r\n            });\r\n            _this.session.send(args);\r\n        };\r\n        this.subscribe = function (topic, callback, options) {\r\n            return new Promise(function (resolve, reject) {\r\n                var _a = options || {}, _b = _a.routingKey, routingKey = _b === void 0 ? undefined : _b, _c = _a.target, target = _c === void 0 ? undefined : _c;\r\n                var args = utils_1.removeEmptyValues({\r\n                    type: 'subscribe',\r\n                    topic: topic,\r\n                    peer_id: _this.peerId,\r\n                    routing_key: routingKey,\r\n                    source: target\r\n                });\r\n                _this.session.send(args)\r\n                    .then(function (response) {\r\n                    var subscription_id = response.subscription_id;\r\n                    _this.subscriptions.push({ subscription_id: subscription_id, topic: topic, callback: callback, source: target });\r\n                    resolve({\r\n                        unsubscribe: function () {\r\n                            _this.session.send({ type: 'unsubscribe', subscription_id: subscription_id, peer_id: _this.peerId });\r\n                            _this.subscriptions = _this.subscriptions.filter(function (s) { return s.subscription_id !== subscription_id; });\r\n                            return Promise.resolve();\r\n                        }\r\n                    });\r\n                })\r\n                    .catch(function (error) { return reject(error); });\r\n            });\r\n        };\r\n        this.watchOnEvent = function () {\r\n            _this.session.on('event', function (args) {\r\n                var data = args.data, subscription_id = args.subscription_id;\r\n                var source = args['publisher-identity'];\r\n                var subscription = _this.subscriptions.find(function (s) { return s.subscription_id === subscription_id; });\r\n                if (subscription) {\r\n                    if (!subscription.source) {\r\n                        subscription.callback(data, subscription.topic, source);\r\n                    }\r\n                    else {\r\n                        if (utils_1.keysMatch(subscription.source, source)) {\r\n                            subscription.callback(data, subscription.topic, source);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        this.connection = connection;\r\n        this.logger = logger;\r\n        this.session = session;\r\n        this.peerId = connection.peerId;\r\n        this.subscriptions = [];\r\n    }\r\n    return Protocol;\r\n}());\r\nfunction default_1(connection, logger, session) {\r\n    var protocol = new Protocol(connection, logger, session);\r\n    protocol.watchOnEvent();\r\n    return protocol;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction removeEmptyValues(obj) {\r\n    var cleaned = {};\r\n    Object.keys(obj).forEach(function (key) {\r\n        if (obj[key] !== undefined && obj[key] !== null) {\r\n            cleaned[key] = obj[key];\r\n        }\r\n    });\r\n    return cleaned;\r\n}\r\nexports.removeEmptyValues = removeEmptyValues;\r\nfunction keysMatch(obj1, obj2) {\r\n    var keysObj1 = Object.keys(obj1);\r\n    var allMatch = true;\r\n    keysObj1.forEach(function (key) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            allMatch = false;\r\n        }\r\n    });\r\n    return allMatch;\r\n}\r\nexports.keysMatch = keysMatch;\r\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar shortid_1 = __webpack_require__(9);\r\nvar utils_1 = __webpack_require__(13);\r\nvar contextMessageReplaySpec_1 = __webpack_require__(12);\r\nvar pjson = __webpack_require__(15);\r\nfunction default_1(configuration, ext, hc, glue42gd, gdVersion) {\r\n    if (typeof window !== \"undefined\") {\r\n        global = global || window;\r\n    }\r\n    global = global || {};\r\n    var uid = shortid_1.generate();\r\n    var masterConfig = global.GLUE_CONFIG || {};\r\n    var dynamicDefaults = global.GLUE_DEFAULT_CONFIG || {};\r\n    var hardDefaults = getHardDefaults();\r\n    var metricsIdentity = {\r\n        system: getConfigProp(\"metrics\", \"system\"),\r\n        service: getConfigProp(\"metrics\", \"service\"),\r\n        instance: getConfigProp(\"metrics\", \"instance\")\r\n    };\r\n    function getMetrics() {\r\n        return ifNotFalse(getConfigProp(\"metrics\"), {\r\n            identity: metricsIdentity\r\n        });\r\n    }\r\n    function getGateway() {\r\n        var force = getConfigProp(\"gateway\", \"force\");\r\n        var gw = hc === undefined || force;\r\n        if (gw) {\r\n            var gwConfig = getConfigProp(\"gateway\");\r\n            var protocolVersion = getConfigProp(\"gateway\", \"protocolVersion\");\r\n            var reconnectInterval = getConfigProp(\"gateway\", \"reconnectInterval\");\r\n            var reconnectAttempts = getConfigProp(\"gateway\", \"reconnectAttempts\");\r\n            var ws = gwConfig.ws;\r\n            var http = gwConfig.http;\r\n            var inproc = gwConfig.inproc;\r\n            if (!ws && !http && !inproc) {\r\n                if (utils_1.default.isNode() || (\"WebSocket\" in window && window.WebSocket.CLOSING === 2)) {\r\n                    ws = getConfigProp(\"gateway\", \"ws\");\r\n                }\r\n                else {\r\n                    http = getConfigProp(\"gateway\", \"http\");\r\n                }\r\n            }\r\n            var windowId = void 0;\r\n            var pid = void 0;\r\n            if (hc) {\r\n                windowId = hc.windowId;\r\n            }\r\n            else if (typeof glue42gd !== \"undefined\") {\r\n                windowId = glue42gd.windowId;\r\n                pid = glue42gd.pid;\r\n            }\r\n            else if (utils_1.default.isNode()) {\r\n                pid = process.pid;\r\n            }\r\n            var replaySpecs = getConfigProp(\"gateway\", \"replaySpecs\") || [];\r\n            replaySpecs.push(contextMessageReplaySpec_1.ContextMessageReplaySpec);\r\n            return {\r\n                identity: {\r\n                    application: getApplication(),\r\n                    windowId: windowId,\r\n                    process: pid,\r\n                },\r\n                reconnectInterval: reconnectInterval,\r\n                ws: ws,\r\n                http: http,\r\n                gw: inproc,\r\n                protocolVersion: protocolVersion,\r\n                reconnectAttempts: reconnectAttempts,\r\n                force: true,\r\n                replaySpecs: replaySpecs,\r\n                gdVersion: gdVersion,\r\n            };\r\n        }\r\n        return { gdVersion: gdVersion };\r\n    }\r\n    function getLogger() {\r\n        return getConfigProp(\"logger\");\r\n    }\r\n    function getAgm() {\r\n        return ifNotFalse(configuration.agm, {\r\n            instance: {\r\n                application: getApplication()\r\n            }\r\n        });\r\n    }\r\n    function getContexts(connectionConfig) {\r\n        if (connectionConfig.protocolVersion < 3) {\r\n            return false;\r\n        }\r\n        var contextConfig = getConfigProp(\"contexts\");\r\n        if (typeof contextConfig === \"boolean\" && !contextConfig) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function getChannels(contextsEnabled) {\r\n        if (!contextsEnabled) {\r\n            return false;\r\n        }\r\n        var channelsConfig = getConfigProp(\"channels\");\r\n        if (typeof channelsConfig === \"boolean\" && !channelsConfig) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function getBus(connectionConfig) {\r\n        var contextConfig = getConfigProp(\"bus\");\r\n        if (typeof contextConfig === \"boolean\" && contextConfig) {\r\n            if (connectionConfig.protocolVersion && connectionConfig.protocolVersion < 3) {\r\n                return false;\r\n            }\r\n            if (gdVersion === 2) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getApplication() {\r\n        return getConfigProp(\"application\");\r\n    }\r\n    function getAuth() {\r\n        return getConfigProp(\"auth\");\r\n    }\r\n    function getHardDefaults() {\r\n        function getMetricsDefaults() {\r\n            var documentTitle = typeof document !== \"undefined\" ? document.title : \"unknown\";\r\n            documentTitle = documentTitle || \"none\";\r\n            if (typeof hc === \"undefined\") {\r\n                return {\r\n                    system: \"Connect.Browser\",\r\n                    service: configuration.application || documentTitle,\r\n                    instance: \"~\" + uid\r\n                };\r\n            }\r\n            if (typeof hc.metricsFacade.getIdentity !== \"undefined\") {\r\n                var identity = hc.metricsFacade.getIdentity();\r\n                return {\r\n                    system: identity.system,\r\n                    service: identity.service,\r\n                    instance: identity.instance\r\n                };\r\n            }\r\n            return {\r\n                system: \"HtmlContainer.\" + hc.containerName,\r\n                service: \"JS.\" + hc.browserWindowName,\r\n                instance: \"~\" + hc.machineName\r\n            };\r\n        }\r\n        function getGatewayDefaults() {\r\n            var defaultProtocol = 3;\r\n            var gatewayURL = \"localhost:8385\";\r\n            var defaultWs = \"ws://\" + gatewayURL;\r\n            var defaultHttp = \"http://\" + gatewayURL;\r\n            if (glue42gd) {\r\n                defaultProtocol = 3;\r\n                defaultWs = glue42gd.gwURL;\r\n            }\r\n            return {\r\n                ws: defaultWs,\r\n                http: defaultHttp,\r\n                protocolVersion: defaultProtocol,\r\n                reconnectInterval: 1000\r\n            };\r\n        }\r\n        function getDefaultApplicationName() {\r\n            if (hc) {\r\n                return hc.containerName + \".\" + hc.browserWindowName;\r\n            }\r\n            if (glue42gd) {\r\n                return glue42gd.appName;\r\n            }\r\n            if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n                return (window.agm_application || document.title) + uid;\r\n            }\r\n            else {\r\n                return \"NodeJS\" + uid;\r\n            }\r\n        }\r\n        function getDefaultLogger() {\r\n            return {\r\n                publish: \"off\",\r\n                console: \"info\",\r\n                metrics: \"off\",\r\n            };\r\n        }\r\n        return {\r\n            application: getDefaultApplicationName(),\r\n            metrics: getMetricsDefaults(),\r\n            agm: {},\r\n            gateway: getGatewayDefaults(),\r\n            logger: getDefaultLogger(),\r\n            bus: false\r\n        };\r\n    }\r\n    function getConfigProp(prop1, prop2) {\r\n        var masterConfigProp1 = masterConfig[prop1];\r\n        var userProp1 = configuration[prop1];\r\n        var dynamicDefaultsProp1 = dynamicDefaults[prop1];\r\n        var hardDefaultsProp1 = hardDefaults[prop1];\r\n        if (prop2) {\r\n            if (masterConfigProp1 && masterConfigProp1[prop2] !== undefined) {\r\n                return masterConfigProp1[prop2];\r\n            }\r\n            if (userProp1 && userProp1[prop2] !== undefined) {\r\n                return userProp1[prop2];\r\n            }\r\n            if (dynamicDefaultsProp1 && dynamicDefaultsProp1[prop2] !== undefined) {\r\n                return dynamicDefaultsProp1[prop2];\r\n            }\r\n            if (hardDefaultsProp1 && hardDefaultsProp1[prop2] !== undefined) {\r\n                return hardDefaultsProp1[prop2];\r\n            }\r\n        }\r\n        else {\r\n            if (masterConfigProp1 !== undefined) {\r\n                return masterConfigProp1;\r\n            }\r\n            if (userProp1 !== undefined) {\r\n                return userProp1;\r\n            }\r\n            if (dynamicDefaultsProp1 !== undefined) {\r\n                return dynamicDefaultsProp1;\r\n            }\r\n            if (hardDefaultsProp1 !== undefined) {\r\n                return hardDefaultsProp1;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    function ifNotFalse(what, then) {\r\n        if (typeof what === \"boolean\" && !what) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return then;\r\n        }\r\n    }\r\n    var connection = getGateway();\r\n    var contexts = getContexts(connection);\r\n    var channels = getChannels(contexts);\r\n    var bus = getBus(connection);\r\n    return {\r\n        bus: bus,\r\n        identity: metricsIdentity,\r\n        application: getApplication(),\r\n        auth: getAuth(),\r\n        logger: getLogger(),\r\n        connection: connection,\r\n        metrics: getMetrics(),\r\n        agm: getAgm(),\r\n        contexts: contexts,\r\n        channels: channels,\r\n        version: ext.version || pjson.version,\r\n        libs: ext.libs\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=config.js.map\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection_1 = __webpack_require__(23);\r\nvar messageReplayer_1 = __webpack_require__(78);\r\nvar GW3ConnectionImpl = (function (_super) {\r\n    __extends(GW3ConnectionImpl, _super);\r\n    function GW3ConnectionImpl(settings) {\r\n        var _this = _super.call(this, settings) || this;\r\n        if (settings.replaySpecs &&\r\n            settings.replaySpecs.length) {\r\n            _this.replayer = new messageReplayer_1.MessageReplayerImpl(settings.replaySpecs);\r\n        }\r\n        return _this;\r\n    }\r\n    GW3ConnectionImpl.prototype.init = function (transport, protocol) {\r\n        _super.prototype.init.call(this, transport, protocol);\r\n        if (this.replayer) {\r\n            this.replayer.init(this);\r\n        }\r\n        this.gw3Protocol = protocol;\r\n    };\r\n    GW3ConnectionImpl.prototype.toAPI = function () {\r\n        var that = this;\r\n        var superAPI = _super.prototype.toAPI.call(this);\r\n        return {\r\n            domain: that.domain.bind(that),\r\n            get peerId() { return that.peerId; },\r\n            get token() { return that.token; },\r\n            get info() { return that.info; },\r\n            get resolvedIdentity() { return that.resolvedIdentity; },\r\n            get availableDomains() { return that.availableDomains; },\r\n            get gatewayToken() { return that.gatewayToken; },\r\n            get replayer() { return that.replayer; },\r\n            on: superAPI.on,\r\n            send: superAPI.send,\r\n            off: superAPI.off,\r\n            login: superAPI.login,\r\n            logout: superAPI.logout,\r\n            loggedIn: superAPI.loggedIn,\r\n            connected: superAPI.connected,\r\n            disconnected: superAPI.disconnected,\r\n            authToken: that.authToken.bind(that),\r\n            get protocolVersion() { return superAPI.protocolVersion; },\r\n        };\r\n    };\r\n    GW3ConnectionImpl.prototype.domain = function (domain, logger, successMessages, errorMessages) {\r\n        return this.gw3Protocol.domain(domain, logger, successMessages, errorMessages);\r\n    };\r\n    GW3ConnectionImpl.prototype.authToken = function () {\r\n        return this.gw3Protocol.authToken();\r\n    };\r\n    return GW3ConnectionImpl;\r\n}(connection_1.default));\r\nexports.default = GW3ConnectionImpl;\r\n//# sourceMappingURL=gw3Connection.js.map\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection_1 = __webpack_require__(23);\r\nvar gw3_1 = __webpack_require__(80);\r\nvar hc_1 = __webpack_require__(82);\r\nvar ws_1 = __webpack_require__(85);\r\nvar gw3Connection_1 = __webpack_require__(76);\r\nvar gw1_1 = __webpack_require__(79);\r\nvar hc_2 = __webpack_require__(83);\r\nvar inproc_1 = __webpack_require__(84);\r\nexports.default = (function (settings) {\r\n    settings = settings || {};\r\n    settings.reconnectAttempts = settings.reconnectAttempts || 10;\r\n    settings.reconnectInterval = settings.reconnectInterval || 500;\r\n    var connection = new connection_1.default(settings);\r\n    var logger = settings.logger;\r\n    if (!logger) {\r\n        throw new Error(\"please pass a logger object\");\r\n    }\r\n    var protocol = new hc_1.default();\r\n    var transport = new hc_2.default();\r\n    var outsideHC = settings.gdVersion !== 2 || settings.force;\r\n    if (outsideHC) {\r\n        if (settings.gw && settings.gw.facade && settings.gw.token && settings.protocolVersion === 3) {\r\n            transport = new inproc_1.default(settings.gw.token, settings.gw.facade, logger.subLogger(\"inproc\"));\r\n        }\r\n        else if (settings.ws !== undefined) {\r\n            transport = new ws_1.default(settings, logger.subLogger(\"ws\"));\r\n        }\r\n        else {\r\n            throw new Error(\"No connection information specified\");\r\n        }\r\n        if (settings.protocolVersion === 3) {\r\n            var gw3Connection = new gw3Connection_1.default(settings);\r\n            var gw3Port = gw3_1.default(gw3Connection, settings, logger.subLogger(\"gw3\"));\r\n            gw3Connection.init(transport, gw3Port);\r\n            return gw3Connection.toAPI();\r\n        }\r\n        else {\r\n            protocol = new gw1_1.default(connection, settings);\r\n        }\r\n    }\r\n    connection.init(transport, protocol);\r\n    return connection.toAPI();\r\n});\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar MessageReplayerImpl = (function () {\r\n    function MessageReplayerImpl(specs) {\r\n        this.specsNames = [];\r\n        this.messages = {};\r\n        this.subs = {};\r\n        this.subsRefCount = {};\r\n        this.specs = {};\r\n        for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\r\n            var spec = specs_1[_i];\r\n            this.specs[spec.name] = spec;\r\n            this.specsNames.push(spec.name);\r\n        }\r\n    }\r\n    MessageReplayerImpl.prototype.init = function (connection) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var _loop_1 = function (type) {\r\n                var refCount = this_1.subsRefCount[type];\r\n                if (!refCount) {\r\n                    refCount = 0;\r\n                }\r\n                refCount += 1;\r\n                this_1.subsRefCount[type] = refCount;\r\n                if (refCount > 1) {\r\n                    return \"continue\";\r\n                }\r\n                var sub = connection.on(\"glue-core\", type, function (msg) { return _this.processMessage(type, msg); });\r\n                this_1.subs[type] = sub;\r\n            };\r\n            var this_1 = this;\r\n            for (var _b = 0, _c = this.specs[name_1].types; _b < _c.length; _b++) {\r\n                var type = _c[_b];\r\n                _loop_1(type);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.processMessage = function (type, msg) {\r\n        if (this.isDone || !msg) {\r\n            return;\r\n        }\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_2 = _a[_i];\r\n            if (this.specs[name_2].types.indexOf(type) !== -1) {\r\n                var messages = this.messages[name_2] || [];\r\n                this.messages[name_2] = messages;\r\n                messages.push(msg);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.drain = function (name, callback) {\r\n        if (callback) {\r\n            (this.messages[name] || []).forEach(callback);\r\n        }\r\n        delete this.messages[name];\r\n        for (var _i = 0, _a = this.specs[name].types; _i < _a.length; _i++) {\r\n            var type = _a[_i];\r\n            this.subsRefCount[type] -= 1;\r\n            if (this.subsRefCount[type] <= 0) {\r\n                this.connection.off(this.subs[type]);\r\n                delete this.subs[type];\r\n                delete this.subsRefCount[type];\r\n            }\r\n        }\r\n        delete this.specs[name];\r\n        if (!this.specs.length) {\r\n            this.isDone = true;\r\n        }\r\n    };\r\n    return MessageReplayerImpl;\r\n}());\r\nexports.MessageReplayerImpl = MessageReplayerImpl;\r\n//# sourceMappingURL=messageReplayer.js.map\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GW1Protocol = (function () {\r\n    function GW1Protocol(connection, settings) {\r\n        this._connection = connection;\r\n        this._settings = settings;\r\n    }\r\n    GW1Protocol.prototype.processStringMessage = function (message) {\r\n        var messageObj = JSON.parse(message);\r\n        return {\r\n            msg: messageObj.message,\r\n            msgType: messageObj.type,\r\n        };\r\n    };\r\n    GW1Protocol.prototype.createStringMessage = function (product, type, message, id) {\r\n        return JSON.stringify({\r\n            type: type,\r\n            message: message,\r\n            id: id,\r\n        });\r\n    };\r\n    GW1Protocol.prototype.login = function (message) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var sendOptions = {\r\n                retryInterval: _this._settings.reconnectInterval,\r\n                maxRetries: _this._settings.reconnectAttempts\r\n            };\r\n            _this._connection.send(\"hello\", \"hello\", {}, null, sendOptions)\r\n                .then(function () { return resolve({ application: undefined }); })\r\n                .catch(reject);\r\n        });\r\n    };\r\n    GW1Protocol.prototype.logout = function () {\r\n    };\r\n    GW1Protocol.prototype.loggedIn = function (callback) {\r\n        callback();\r\n        return function () {\r\n        };\r\n    };\r\n    GW1Protocol.prototype.processObjectMessage = function (message) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    GW1Protocol.prototype.createObjectMessage = function (product, type, message, id) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    return GW1Protocol;\r\n}());\r\nexports.default = GW1Protocol;\r\n//# sourceMappingURL=gw1.js.map\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3Domain_1 = __webpack_require__(81);\r\nvar callback_registry_1 = __webpack_require__(1);\r\nfunction default_1(connection, settings, logger) {\r\n    var datePrefix = \"#T42_DATE#\";\r\n    var datePrefixLen = datePrefix.length;\r\n    var dateMinLen = datePrefixLen + 1;\r\n    var datePrefixFirstChar = datePrefix[0];\r\n    var registry = callback_registry_1.default();\r\n    var globalDomain;\r\n    var isLoggedIn = false;\r\n    var shouldTryLogin = true;\r\n    var initialLogin = true;\r\n    var initialLoginAttempts = 3;\r\n    var initialLoginAttemptsInterval = 500;\r\n    var pingTimer;\r\n    var sessions = [];\r\n    var loginConfig;\r\n    connection.disconnected(handleDisconnected.bind(this));\r\n    ping();\r\n    function processStringMessage(message) {\r\n        var msg = JSON.parse(message, function (key, value) {\r\n            if (typeof value !== \"string\") {\r\n                return value;\r\n            }\r\n            if (value.length < dateMinLen) {\r\n                return value;\r\n            }\r\n            if (value[0] !== datePrefixFirstChar) {\r\n                return value;\r\n            }\r\n            if (value.substring(0, datePrefixLen) !== datePrefix) {\r\n                return value;\r\n            }\r\n            try {\r\n                var milliseconds = parseInt(value.substring(datePrefixLen, value.length), 10);\r\n                if (isNaN(milliseconds)) {\r\n                    return value;\r\n                }\r\n                return new Date(milliseconds);\r\n            }\r\n            catch (ex) {\r\n                return value;\r\n            }\r\n        });\r\n        return {\r\n            msg: msg,\r\n            msgType: msg.type,\r\n        };\r\n    }\r\n    function createStringMessage(product, type, message, id) {\r\n        var oldToJson = Date.prototype.toJSON;\r\n        try {\r\n            Date.prototype.toJSON = function () {\r\n                return datePrefix + this.getTime();\r\n            };\r\n            var result = JSON.stringify(message);\r\n            return result;\r\n        }\r\n        finally {\r\n            Date.prototype.toJSON = oldToJson;\r\n        }\r\n    }\r\n    function processObjectMessage(message) {\r\n        if (!message.type) {\r\n            throw new Error(\"Object should have type property\");\r\n        }\r\n        return {\r\n            msg: message,\r\n            msgType: message.type,\r\n        };\r\n    }\r\n    function createObjectMessage(product, type, message, id) {\r\n        return message;\r\n    }\r\n    function login(config) {\r\n        logger.debug(\"logging in...\");\r\n        loginConfig = config;\r\n        if (!loginConfig) {\r\n            loginConfig = { username: \"\", password: \"\" };\r\n        }\r\n        shouldTryLogin = true;\r\n        return new Promise(function (resolve, reject) {\r\n            var authentication = {};\r\n            connection.gatewayToken = config.gatewayToken;\r\n            if (connection.gatewayToken) {\r\n                authentication.method = \"gateway-token\";\r\n                authentication.token = connection.gatewayToken;\r\n            }\r\n            else if (config.token) {\r\n                authentication.method = \"access-token\";\r\n                authentication.token = config.token;\r\n            }\r\n            else if (config.username) {\r\n                authentication.method = \"secret\";\r\n                authentication.login = config.username;\r\n                authentication.secret = config.password;\r\n            }\r\n            else {\r\n                throw new Error(\"invalid auth message\" + JSON.stringify(config));\r\n            }\r\n            var helloMsg = {\r\n                type: \"hello\",\r\n                identity: settings.identity,\r\n                authentication: authentication,\r\n            };\r\n            globalDomain = gw3Domain_1.default(\"global\", connection, logger, [\r\n                \"welcome\",\r\n                \"token\"\r\n            ]);\r\n            var sendOptions = { skipPeerId: true };\r\n            if (initialLogin) {\r\n                sendOptions.retryInterval = settings.reconnectInterval;\r\n                sendOptions.maxRetries = settings.reconnectAttempts;\r\n            }\r\n            globalDomain.send(helloMsg, undefined, sendOptions)\r\n                .then(function (msg) {\r\n                initialLogin = false;\r\n                logger.debug(\"login successful with PeerId \" + msg.peer_id);\r\n                connection.peerId = msg.peer_id;\r\n                connection.resolvedIdentity = msg.resolved_identity;\r\n                connection.availableDomains = msg.available_domains;\r\n                if (msg.options) {\r\n                    connection.token = msg.options.access_token;\r\n                    connection.info = msg.options.info;\r\n                }\r\n                setLoggedIn(true);\r\n                resolve(msg.resolved_identity);\r\n            })\r\n                .catch(function (err) {\r\n                logger.error(\"error sending hello message - \" + err);\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function logout() {\r\n        logger.debug(\"logging out...\");\r\n        shouldTryLogin = false;\r\n        if (pingTimer) {\r\n            clearTimeout(pingTimer);\r\n        }\r\n        sessions.forEach(function (session) {\r\n            session.leave();\r\n        });\r\n    }\r\n    function loggedIn(callback) {\r\n        if (isLoggedIn) {\r\n            callback();\r\n        }\r\n        return registry.add(\"onLoggedIn\", callback);\r\n    }\r\n    function domain(domainName, domainLogger, successMessages, errorMessages) {\r\n        var session = sessions.filter(function (s) { return s.domain === domainName; })[0];\r\n        if (!session) {\r\n            session = gw3Domain_1.default(domainName, connection, domainLogger, successMessages, errorMessages);\r\n            sessions.push(session);\r\n        }\r\n        return session;\r\n    }\r\n    function handleDisconnected() {\r\n        setLoggedIn(false);\r\n        var tryToLogin = shouldTryLogin;\r\n        if (tryToLogin && initialLogin) {\r\n            if (initialLoginAttempts <= 0) {\r\n                return;\r\n            }\r\n            initialLoginAttempts--;\r\n        }\r\n        logger.debug(\"disconnected - will try new login?\" + shouldTryLogin);\r\n        if (shouldTryLogin) {\r\n            connection.login(loginConfig)\r\n                .catch(function () {\r\n                setTimeout(handleDisconnected, 1000);\r\n            });\r\n        }\r\n    }\r\n    function setLoggedIn(value) {\r\n        isLoggedIn = value;\r\n        if (isLoggedIn) {\r\n            registry.execute(\"onLoggedIn\");\r\n        }\r\n    }\r\n    function ping() {\r\n        if (!shouldTryLogin) {\r\n            return;\r\n        }\r\n        if (isLoggedIn) {\r\n            connection.send(\"\", \"\", { type: \"ping\" });\r\n        }\r\n        pingTimer = setTimeout(ping, 30 * 1000);\r\n    }\r\n    function authToken() {\r\n        var createTokenReq = {\r\n            type: \"create-token\"\r\n        };\r\n        return globalDomain.send(createTokenReq)\r\n            .then(function (res) {\r\n            return res.token;\r\n        });\r\n    }\r\n    return {\r\n        processStringMessage: processStringMessage,\r\n        createStringMessage: createStringMessage,\r\n        createObjectMessage: createObjectMessage,\r\n        processObjectMessage: processObjectMessage,\r\n        login: login,\r\n        logout: logout,\r\n        loggedIn: loggedIn,\r\n        domain: domain,\r\n        authToken: authToken,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3.js.map\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callbackRegistry = __webpack_require__(1);\r\nvar shortid_1 = __webpack_require__(9);\r\nfunction default_1(domain, connection, logger, successMessages, errorMessages) {\r\n    if (domain == null) {\r\n        domain = \"global\";\r\n    }\r\n    var isJoined = false;\r\n    var tryReconnecting = false;\r\n    var _latestOptions;\r\n    var _connectionOn = false;\r\n    var callbacks = callbackRegistry();\r\n    connection.disconnected(handleConnectionDisconnected);\r\n    connection.loggedIn(handleConnectionLoggedIn);\r\n    connection.on(domain, \"success\", function (msg) { return handleSuccessMessage(msg); });\r\n    connection.on(domain, \"error\", function (msg) { return handleErrorMessage(msg); });\r\n    connection.on(domain, \"result\", function (msg) { return handleSuccessMessage(msg); });\r\n    if (successMessages) {\r\n        successMessages.forEach(function (sm) {\r\n            connection.on(domain, sm, function (msg) { return handleSuccessMessage(msg); });\r\n        });\r\n    }\r\n    if (errorMessages) {\r\n        errorMessages.forEach(function (sm) {\r\n            connection.on(domain, sm, function (msg) { return handleErrorMessage(msg); });\r\n        });\r\n    }\r\n    var requestsMap = {};\r\n    function join(options) {\r\n        _latestOptions = options;\r\n        return new Promise(function (resolve, reject) {\r\n            if (isJoined) {\r\n                resolve();\r\n                return;\r\n            }\r\n            var joinPromise;\r\n            if (domain === \"global\") {\r\n                joinPromise = _connectionOn ? Promise.resolve({}) : Promise.reject(\"not connected to gateway\");\r\n            }\r\n            else {\r\n                logger.debug(\"joining \" + domain);\r\n                var joinMsg = {\r\n                    type: \"join\",\r\n                    destination: domain,\r\n                    domain: \"global\",\r\n                    options: options,\r\n                };\r\n                joinPromise = send(joinMsg);\r\n            }\r\n            joinPromise\r\n                .then(function () {\r\n                handleJoined();\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                logger.debug(\"error joining \" + domain + \" domain: \" + JSON.stringify(err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function leave() {\r\n        if (domain === \"global\") {\r\n            return;\r\n        }\r\n        logger.debug(\"stopping session \" + domain + \"...\");\r\n        var leaveMsg = {\r\n            type: \"leave\",\r\n            destination: domain,\r\n            domain: \"global\",\r\n        };\r\n        send(leaveMsg).then(function () {\r\n            isJoined = false;\r\n            callbacks.execute(\"onLeft\");\r\n        });\r\n    }\r\n    function handleJoined() {\r\n        logger.debug(\"did join \" + domain);\r\n        isJoined = true;\r\n        var wasReconnect = tryReconnecting;\r\n        tryReconnecting = false;\r\n        callbacks.execute(\"onJoined\", wasReconnect);\r\n    }\r\n    function handleConnectionDisconnected() {\r\n        _connectionOn = false;\r\n        logger.warn(\"connection is down\");\r\n        isJoined = false;\r\n        tryReconnecting = true;\r\n        callbacks.execute(\"onLeft\", { disconnected: true });\r\n    }\r\n    function handleConnectionLoggedIn() {\r\n        _connectionOn = true;\r\n        if (tryReconnecting) {\r\n            logger.info(\"connection is now up - trying to reconnect...\");\r\n            join(_latestOptions);\r\n        }\r\n    }\r\n    function onJoined(callback) {\r\n        if (isJoined) {\r\n            callback(false);\r\n        }\r\n        return callbacks.add(\"onJoined\", callback);\r\n    }\r\n    function onLeft(callback) {\r\n        if (!isJoined) {\r\n            callback();\r\n        }\r\n        return callbacks.add(\"onLeft\", callback);\r\n    }\r\n    function handleErrorMessage(msg) {\r\n        if (domain !== msg.domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.error(msg);\r\n    }\r\n    function handleSuccessMessage(msg) {\r\n        if (msg.domain !== domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.success(msg);\r\n    }\r\n    function getNextRequestId() {\r\n        return shortid_1.generate();\r\n    }\r\n    function send(msg, tag, options) {\r\n        options = options || {};\r\n        msg.request_id = msg.request_id || getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        if (!options.skipPeerId) {\r\n            msg.peer_id = connection.peerId;\r\n        }\r\n        var requestId = msg.request_id;\r\n        return new Promise(function (resolve, reject) {\r\n            requestsMap[requestId] = {\r\n                success: function (successMsg) {\r\n                    delete requestsMap[requestId];\r\n                    successMsg._tag = tag;\r\n                    resolve(successMsg);\r\n                },\r\n                error: function (errorMsg) {\r\n                    logger.warn(\"GW error - \" + JSON.stringify(errorMsg) + \" for request \" + JSON.stringify(msg));\r\n                    delete requestsMap[requestId];\r\n                    errorMsg._tag = tag;\r\n                    reject(errorMsg);\r\n                },\r\n            };\r\n            connection\r\n                .send(domain, domain, msg, undefined, options)\r\n                .catch(function (err) {\r\n                requestsMap[requestId].error({ err: err });\r\n            });\r\n        });\r\n    }\r\n    function sendFireAndForget(msg) {\r\n        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        msg.peer_id = connection.peerId;\r\n        connection.send(domain, domain, msg);\r\n    }\r\n    return {\r\n        join: join,\r\n        leave: leave,\r\n        onJoined: onJoined,\r\n        onLeft: onLeft,\r\n        send: send,\r\n        sendFireAndForget: sendFireAndForget,\r\n        on: function (type, callback) {\r\n            connection.on(domain, type, function (msg) {\r\n                if (msg.domain !== domain) {\r\n                    return;\r\n                }\r\n                try {\r\n                    callback(msg);\r\n                }\r\n                catch (e) {\r\n                    logger.error(\"Callback  failed: \" + e + \" \\n msg was: \" + JSON.stringify(msg));\r\n                }\r\n            });\r\n        },\r\n        loggedIn: function (callback) { return connection.loggedIn(callback); },\r\n        connected: function (callback) { return connection.connected(callback); },\r\n        disconnected: function (callback) { return connection.disconnected(callback); },\r\n        get peerId() {\r\n            return connection.peerId;\r\n        },\r\n        get domain() {\r\n            return domain;\r\n        },\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3Domain.js.map\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCProtocol = (function () {\r\n    function HCProtocol() {\r\n    }\r\n    HCProtocol.prototype.processStringMessage = function (message) {\r\n        var messageObj = JSON.parse(message);\r\n        return {\r\n            msg: messageObj,\r\n            msgType: messageObj.type,\r\n        };\r\n    };\r\n    HCProtocol.prototype.createStringMessage = function (product, type, message, id) {\r\n        return JSON.stringify(message);\r\n    };\r\n    HCProtocol.prototype.login = function (message) {\r\n        return Promise.resolve({ application: undefined });\r\n    };\r\n    HCProtocol.prototype.logout = function () {\r\n    };\r\n    HCProtocol.prototype.loggedIn = function (callback) {\r\n        callback();\r\n        return function () {\r\n        };\r\n    };\r\n    HCProtocol.prototype.processObjectMessage = function (message) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    HCProtocol.prototype.createObjectMessage = function (product, type, message, id) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    return HCProtocol;\r\n}());\r\nexports.default = HCProtocol;\r\n//# sourceMappingURL=hc.js.map\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCTransport = (function () {\r\n    function HCTransport() {\r\n        this.connectionId = Math.floor(1e10 * Math.random()).toString();\r\n    }\r\n    HCTransport.prototype.send = function (message, product, type) {\r\n        if (product === \"metrics\") {\r\n            window.htmlContainer.metricsFacade.send(type, message);\r\n        }\r\n        else if (product === \"log\") {\r\n            window.htmlContainer.loggingFacade.send(type, message);\r\n        }\r\n        return Promise.resolve(undefined);\r\n    };\r\n    HCTransport.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    HCTransport.prototype.onMessage = function (callback) {\r\n    };\r\n    HCTransport.prototype.close = function () {\r\n    };\r\n    HCTransport.prototype.open = function () {\r\n    };\r\n    return HCTransport;\r\n}());\r\nexports.default = HCTransport;\r\n//# sourceMappingURL=hc.js.map\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar Inproc = (function () {\r\n    function Inproc(token, gw, logger) {\r\n        this.registry = callback_registry_1.default();\r\n        this.gw = gw;\r\n        this.gwToken = token;\r\n        this.logger = logger;\r\n        this.connectToken = this.gw.connect(this.gwToken, this.messageHandler.bind(this));\r\n    }\r\n    Object.defineProperty(Inproc.prototype, \"isObjectBasedTransport\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Inproc.prototype.sendObject = function (msg) {\r\n        this.logger.debug(JSON.stringify(msg));\r\n        this.gw.send(this.connectToken, msg);\r\n        return Promise.resolve(undefined);\r\n    };\r\n    Inproc.prototype.send = function (msg, product, type) {\r\n        return Promise.reject(\"not supported\");\r\n    };\r\n    Inproc.prototype.onMessage = function (callback) {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    };\r\n    Inproc.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    Inproc.prototype.close = function () {\r\n    };\r\n    Inproc.prototype.open = function () {\r\n    };\r\n    Inproc.prototype.messageHandler = function (msg) {\r\n        if (this.logger.consoleLevel() === \"trace\") {\r\n            this.logger.debug(JSON.stringify(msg));\r\n        }\r\n        this.registry.execute(\"onMessage\", msg);\r\n    };\r\n    return Inproc;\r\n}());\r\nexports.default = Inproc;\r\n//# sourceMappingURL=inproc.js.map\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = __webpack_require__(1);\r\nvar utils_1 = __webpack_require__(13);\r\nvar WebSocket = utils_1.default.isNode() ? __webpack_require__(39) : window.WebSocket;\r\nvar WS = (function () {\r\n    function WS(settings, logger) {\r\n        this._running = true;\r\n        this._initied = false;\r\n        this._registry = callback_registry_1.default();\r\n        this._settings = settings;\r\n        this._logger = logger;\r\n    }\r\n    WS.prototype.onMessage = function (callback) {\r\n        return this._registry.add(\"onMessage\", callback);\r\n    };\r\n    WS.prototype.send = function (msg, product, type, options) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            options = options || {};\r\n            _this.waitForSocketConnection(function () {\r\n                try {\r\n                    _this._ws.send(msg);\r\n                    resolve();\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, reject, options.maxRetries, options.retryInterval);\r\n        });\r\n    };\r\n    WS.prototype.open = function () {\r\n        this._running = true;\r\n    };\r\n    WS.prototype.close = function () {\r\n        this._running = false;\r\n        this._ws.close();\r\n    };\r\n    WS.prototype.onConnectedChanged = function (callback) {\r\n        return this._registry.add(\"onConnectedChanged\", callback);\r\n    };\r\n    WS.prototype.initiateSocket = function () {\r\n        var _this = this;\r\n        this._logger.debug(\"initiating _ws to \" + this._settings.ws + \"...\");\r\n        this._ws = new WebSocket(this._settings.ws);\r\n        this._ws.onerror = function (err) {\r\n            _this.notifyStatusChanged(false, err);\r\n        };\r\n        this._ws.onclose = function () {\r\n            _this._logger.debug(\"_ws closed\");\r\n            _this.notifyStatusChanged(false);\r\n        };\r\n        this._ws.onopen = function () {\r\n            _this._logger.debug(\"_ws opened\");\r\n            _this.notifyStatusChanged(true);\r\n        };\r\n        this._ws.onmessage = function (message) {\r\n            _this._registry.execute(\"onMessage\", message.data);\r\n        };\r\n    };\r\n    WS.prototype.waitForSocketConnection = function (callback, failed, retriesLeft, retryInterval) {\r\n        var _this = this;\r\n        if (!callback) {\r\n            callback = function () { };\r\n        }\r\n        if (!failed) {\r\n            failed = function () { };\r\n        }\r\n        if (retryInterval === undefined) {\r\n            retryInterval = this._settings.reconnectInterval;\r\n        }\r\n        if (retriesLeft !== undefined) {\r\n            if (retriesLeft === 0) {\r\n                failed(\"wait for socket on \" + this._settings.ws + \" failed - no more retries left\");\r\n                return;\r\n            }\r\n            this._logger.debug(\"will retry \" + retriesLeft + \" more times (every \" + retryInterval + \" ms)\");\r\n        }\r\n        if (!this._running) {\r\n            failed(\"wait for socket on \" + this._settings.ws + \" failed - socket closed by user\");\r\n            return;\r\n        }\r\n        if (!this._ws || this._ws.readyState > 1) {\r\n            this.initiateSocket();\r\n        }\r\n        else if (this._ws.readyState === 1) {\r\n            return callback();\r\n        }\r\n        setTimeout(function () {\r\n            var retries = retriesLeft === undefined ? undefined : retriesLeft - 1;\r\n            _this.waitForSocketConnection(callback, failed, retries, retryInterval);\r\n        }, retryInterval);\r\n    };\r\n    WS.prototype.notifyStatusChanged = function (status, reason) {\r\n        this._registry.execute(\"onConnectedChanged\", status, reason);\r\n    };\r\n    return WS;\r\n}());\r\nexports.default = WS;\r\n//# sourceMappingURL=ws.js.map\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3ContextData_1 = __webpack_require__(87);\r\nvar helpers_1 = __webpack_require__(90);\r\nvar msg = __webpack_require__(24);\r\nvar contextMessageReplaySpec_1 = __webpack_require__(12);\r\nvar GW3Bridge = (function () {\r\n    function GW3Bridge(config) {\r\n        var _this = this;\r\n        this._contextNameToData = {};\r\n        this._gw3Subscriptions = [];\r\n        this._nextCallbackSubscriptionNumber = 0;\r\n        this._contextNameToId = {};\r\n        this._contextIdToName = {};\r\n        this._connection = config.connection;\r\n        this._logger = config.logger;\r\n        this._gw3Session = this._connection.domain(\"global\", this._logger, [\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n        ]);\r\n        this.subscribeToContextCreatedMessages();\r\n        this.subscribeToContextUpdatedMessages();\r\n        this.subscribeToContextDestroyedMessages();\r\n        this._connection.replayer.drain(contextMessageReplaySpec_1.ContextMessageReplaySpec.name, function (message) {\r\n            var type = message.type;\r\n            if (!type) {\r\n                return;\r\n            }\r\n            if (type === msg.GW_MESSAGE_CONTEXT_CREATED ||\r\n                type === msg.GW_MESSAGE_CONTEXT_ADDED ||\r\n                type === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n                _this.handleContextCreatedMessage(message);\r\n            }\r\n            else if (type === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT ||\r\n                type === msg.GW_MESSAGE_CONTEXT_UPDATED ||\r\n                type === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n                _this.handleContextUpdatedMessage(message);\r\n            }\r\n            else if (type === msg.GW_MESSAGE_CONTEXT_DESTROYED ||\r\n                type === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n                _this.handleContextDestroyedMessage(message);\r\n            }\r\n        });\r\n    }\r\n    GW3Bridge.prototype.dispose = function () {\r\n        for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {\r\n            var sub = _a[_i];\r\n            this._connection.off(sub);\r\n        }\r\n        this._gw3Subscriptions.length = 0;\r\n        for (var contextName in this._contextNameToData) {\r\n            if (this._contextNameToId.hasOwnProperty(contextName)) {\r\n                delete this._contextNameToData[contextName];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.createContext = function (name, data) {\r\n        var _this = this;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            domain: \"global\",\r\n            name: name,\r\n            data: data,\r\n            lifetime: \"retained\",\r\n        })\r\n            .then(function (createContextMsg) {\r\n            _this._contextNameToId[name] = createContextMsg.context_id;\r\n            if (!_this._contextIdToName[createContextMsg.context_id]) {\r\n                _this._contextIdToName[createContextMsg.context_id] = name;\r\n                var contextData = _this._contextNameToData[name] || new gw3ContextData_1.GW3ContextData(createContextMsg.context_id, name, true, null);\r\n                contextData.isAnnounced = true;\r\n                contextData.name = name;\r\n                contextData.contextId = createContextMsg.context_id;\r\n                _this._contextNameToData[name] = contextData;\r\n                contextData.context = createContextMsg.data;\r\n                contextData.sentExplicitSubscription = true;\r\n                if (contextData.context) {\r\n                    _this.invokeUpdateCallbacks(contextData, contextData.context, null);\r\n                }\r\n                return _this.update(name, data).then(function () { return createContextMsg.context_id; });\r\n            }\r\n            return createContextMsg.context_id;\r\n        });\r\n    };\r\n    GW3Bridge.prototype.all = function () {\r\n        var _this = this;\r\n        return Object.keys(this._contextNameToData)\r\n            .filter(function (name) { return _this._contextNameToData[name].isAnnounced; });\r\n    };\r\n    GW3Bridge.prototype.update = function (name, delta) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, delta);\r\n        }\r\n        var calculatedDelta = this.calculateContextDelta(contextData.context, delta);\r\n        if (!Object.keys(calculatedDelta.added).length\r\n            && !Object.keys(calculatedDelta.updated).length\r\n            && !calculatedDelta.removed.length) {\r\n            return Promise.resolve();\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: calculatedDelta,\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, calculatedDelta, {\r\n                updaterId: gwResponse.peer_id\r\n            });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.set = function (name, data) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, data);\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: { reset: data },\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n                var _this = this;\r\n                return __generator(this, function (_a) {\r\n                    this.subscribe(name, function (data, delta, removed, un) {\r\n                        _this.unsubscribe(un);\r\n                        resolve(data);\r\n                    });\r\n                    return [2];\r\n                });\r\n            }); });\r\n        }\r\n        else {\r\n            return Promise.resolve(contextData.context);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribe = function (name, callback) {\r\n        var thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;\r\n        this._nextCallbackSubscriptionNumber += 1;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData ||\r\n            !contextData.isAnnounced) {\r\n            contextData = contextData || new gw3ContextData_1.GW3ContextData(undefined, name, false, undefined);\r\n            this._contextNameToData[name] = contextData;\r\n            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n        var hadCallbacks = contextData.hasCallbacks();\r\n        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n        if (!hadCallbacks) {\r\n            if (!contextData.joinedActivity) {\r\n                if (contextData.context &&\r\n                    contextData.sentExplicitSubscription) {\r\n                    callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n                    return Promise.resolve(thisCallbackSubscriptionNumber);\r\n                }\r\n                return this.sendSubscribe(contextData)\r\n                    .then(function () { return thisCallbackSubscriptionNumber; });\r\n            }\r\n            else {\r\n                callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n                return Promise.resolve(thisCallbackSubscriptionNumber);\r\n            }\r\n        }\r\n        else {\r\n            callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.unsubscribe = function (subscriptionKey) {\r\n        for (var _i = 0, _a = Object.keys(this._contextNameToData); _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var contextId = this._contextNameToId[name_1];\r\n            var contextData = this._contextNameToData[name_1];\r\n            if (!contextData) {\r\n                return;\r\n            }\r\n            var hadCallbacks = contextData.hasCallbacks();\r\n            delete contextData.updateCallbacks[subscriptionKey];\r\n            if (contextData.isAnnounced &&\r\n                hadCallbacks &&\r\n                !contextData.hasCallbacks() &&\r\n                contextData.sentExplicitSubscription) {\r\n                this.sendUnsubscribe(contextData);\r\n            }\r\n            if (!contextData.isAnnounced &&\r\n                !contextData.hasCallbacks()) {\r\n                delete this._contextNameToData[name_1];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleUpdated = function (contextData, delta, extraData) {\r\n        var oldContext = contextData.context;\r\n        contextData.context = helpers_1.applyContextDelta(contextData.context, delta);\r\n        if (this._contextNameToData[contextData.name] === contextData &&\r\n            !helpers_1.deepEqual(oldContext, contextData.context)) {\r\n            this.invokeUpdateCallbacks(contextData, contextData.context, delta, extraData);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextCreatedMessages = function () {\r\n        var createdMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n        ];\r\n        for (var _i = 0, createdMessageTypes_1 = createdMessageTypes; _i < createdMessageTypes_1.length; _i++) {\r\n            var createdMessageType = createdMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", createdMessageType, this.handleContextCreatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextCreatedMessage = function (contextCreatedMsg) {\r\n        var createdMessageType = contextCreatedMsg.type;\r\n        if (createdMessageType === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;\r\n        }\r\n        else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_ADDED) {\r\n            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;\r\n        }\r\n        else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_CREATED) {\r\n        }\r\n        var name = this._contextIdToName[contextCreatedMsg.context_id];\r\n        if (!name) {\r\n            throw new Error(\"Received created event for context with unknown name: \" + contextCreatedMsg.context_id);\r\n        }\r\n        if (!this._contextNameToId[name]) {\r\n            throw new Error(\"Received created event for context with unknown id: \" + contextCreatedMsg.context_id);\r\n        }\r\n        var contextData = this._contextNameToData[name];\r\n        if (contextData) {\r\n            if (contextData.isAnnounced) {\r\n                return;\r\n            }\r\n            else {\r\n                if (!contextData.hasCallbacks()) {\r\n                    throw new Error(\"Assertion failure: contextData.hasCallbacks()\");\r\n                }\r\n                contextData.isAnnounced = true;\r\n                contextData.contextId = contextCreatedMsg.context_id;\r\n                contextData.activityId = contextCreatedMsg.activity_id;\r\n                if (!contextData.sentExplicitSubscription) {\r\n                    this.sendSubscribe(contextData);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._contextNameToData[name] = contextData =\r\n                new gw3ContextData_1.GW3ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextUpdatedMessages = function () {\r\n        var updatedMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY,\r\n        ];\r\n        for (var _i = 0, updatedMessageTypes_1 = updatedMessageTypes; _i < updatedMessageTypes_1.length; _i++) {\r\n            var updatedMessageType = updatedMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", updatedMessageType, this.handleContextUpdatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextUpdatedMessage = function (contextUpdatedMsg) {\r\n        var updatedMessageType = contextUpdatedMsg.type;\r\n        var contextId = contextUpdatedMsg.context_id;\r\n        var contextData = this._contextNameToData[this._contextIdToName[contextId]];\r\n        var justSeen = !contextData || !contextData.isAnnounced;\r\n        if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            if (!contextData) {\r\n                contextData = new gw3ContextData_1.GW3ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);\r\n                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;\r\n                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;\r\n                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;\r\n            }\r\n            else {\r\n                contextData.contextId = contextId;\r\n                contextData.isAnnounced = true;\r\n                contextData.activityId = contextUpdatedMsg.activity_id;\r\n            }\r\n            contextData.joinedActivity = true;\r\n        }\r\n        else {\r\n            if (!contextData || !contextData.isAnnounced) {\r\n                if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n                    contextData = contextData || new gw3ContextData_1.GW3ContextData(contextId, contextUpdatedMsg.name, true, null);\r\n                    contextData.sentExplicitSubscription = true;\r\n                    this._contextNameToData[contextUpdatedMsg.name] = contextData;\r\n                    this._contextIdToName[contextId] = contextUpdatedMsg.name;\r\n                    this._contextNameToId[contextUpdatedMsg.name] = contextId;\r\n                }\r\n                else {\r\n                    this._logger.error(\"Received 'update' for unknown context: \" + contextId);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        var oldContext = contextData.context;\r\n        if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            contextData.context = contextUpdatedMsg.data || {};\r\n        }\r\n        else if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            contextData.context = contextUpdatedMsg.context_snapshot || {};\r\n        }\r\n        else if (updatedMessageType === msg.GW_MESSAGE_CONTEXT_UPDATED) {\r\n            contextData.context = helpers_1.applyContextDelta(contextData.context, contextUpdatedMsg.delta);\r\n        }\r\n        else {\r\n            throw new Error(\"Unrecognized context update message \" + updatedMessageType);\r\n        }\r\n        if (justSeen ||\r\n            !helpers_1.deepEqual(contextData.context, oldContext) ||\r\n            updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            this.invokeUpdateCallbacks(contextData, contextData.context, null, { updaterId: contextUpdatedMsg.updater_id });\r\n        }\r\n    };\r\n    GW3Bridge.prototype.invokeUpdateCallbacks = function (contextData, data, delta, extraData) {\r\n        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };\r\n        for (var updateCallbackIndex in contextData.updateCallbacks) {\r\n            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {\r\n                try {\r\n                    var updateCallback = contextData.updateCallbacks[updateCallbackIndex];\r\n                    updateCallback(helpers_1.deepClone(data), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex), extraData);\r\n                }\r\n                catch (err) {\r\n                    this._logger.debug(\"Callback error: \" + JSON.stringify(err));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextDestroyedMessages = function () {\r\n        var destroyedMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n        ];\r\n        for (var _i = 0, destroyedMessageTypes_1 = destroyedMessageTypes; _i < destroyedMessageTypes_1.length; _i++) {\r\n            var destroyedMessageType = destroyedMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", destroyedMessageType, this.handleContextDestroyedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextDestroyedMessage = function (destroyedMsg) {\r\n        var destroyedMessageType = destroyedMsg.type;\r\n        var contextId;\r\n        var name;\r\n        if (destroyedMessageType === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n            name = destroyedMsg.activity_id;\r\n            contextId = this._contextNameToId[name];\r\n            if (!contextId) {\r\n                this._logger.error(\"Received 'destroyed' for unknown activity: \" + destroyedMsg.activity_id);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            contextId = destroyedMsg.context_id;\r\n            name = this._contextIdToName[contextId];\r\n            if (!name) {\r\n                this._logger.error(\"Received 'destroyed' for unknown context: \" + destroyedMsg.context_id);\r\n                return;\r\n            }\r\n        }\r\n        delete this._contextIdToName[contextId];\r\n        delete this._contextNameToId[name];\r\n        var contextData = this._contextNameToData[name];\r\n        delete this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            this._logger.error(\"Received 'destroyed' for unknown context: \" + contextId);\r\n            return;\r\n        }\r\n    };\r\n    GW3Bridge.prototype.sendSubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = true;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.sendUnsubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = false;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.calculateContextDelta = function (from, to) {\r\n        var delta = { added: {}, updated: {}, removed: [], reset: null };\r\n        if (from) {\r\n            for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n                var x = _a[_i];\r\n                if (Object.keys(to).indexOf(x) !== -1\r\n                    && to[x] !== null\r\n                    && !helpers_1.deepEqual(from[x], to[x])) {\r\n                    delta.updated[x] = to[x];\r\n                }\r\n            }\r\n        }\r\n        for (var _b = 0, _c = Object.keys(to); _b < _c.length; _b++) {\r\n            var x = _c[_b];\r\n            if (!from || (Object.keys(from).indexOf(x) === -1)) {\r\n                if (to[x] !== null) {\r\n                    delta.added[x] = to[x];\r\n                }\r\n            }\r\n            else if (to[x] === null) {\r\n                delta.removed.push(x);\r\n            }\r\n        }\r\n        return delta;\r\n    };\r\n    return GW3Bridge;\r\n}());\r\nexports.GW3Bridge = GW3Bridge;\r\n//# sourceMappingURL=gw3Bridge.js.map\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GW3ContextData = (function () {\r\n    function GW3ContextData(contextId, name, isAnnounced, activityId) {\r\n        this.updateCallbacks = {};\r\n        this.contextId = contextId;\r\n        this.name = name;\r\n        this.isAnnounced = isAnnounced;\r\n        this.activityId = activityId;\r\n        this.context = {};\r\n    }\r\n    GW3ContextData.prototype.hasCallbacks = function () {\r\n        return Object.keys(this.updateCallbacks).length > 0;\r\n    };\r\n    GW3ContextData.prototype.getState = function () {\r\n        if (this.isAnnounced && this.hasCallbacks()) {\r\n            return 3;\r\n        }\r\n        if (this.isAnnounced) {\r\n            return 2;\r\n        }\r\n        if (this.hasCallbacks()) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    };\r\n    return GW3ContextData;\r\n}());\r\nexports.GW3ContextData = GW3ContextData;\r\n//# sourceMappingURL=gw3ContextData.js.map\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCBridge = (function () {\r\n    function HCBridge(config) {\r\n        this._facade = window.htmlContainer.sharedContextFacade;\r\n    }\r\n    HCBridge.prototype.all = function () {\r\n        var allObj = this._facade.all();\r\n        if (!allObj || !allObj.keys) {\r\n            return [];\r\n        }\r\n        return allObj.keys;\r\n    };\r\n    HCBridge.prototype.update = function (name, delta) {\r\n        this._facade.update(name, delta);\r\n        return Promise.resolve();\r\n    };\r\n    HCBridge.prototype.set = function (name, data) {\r\n        this._facade.set(name, data);\r\n        return Promise.resolve();\r\n    };\r\n    HCBridge.prototype.subscribe = function (name, callback) {\r\n        var snapshot = null;\r\n        var key = this._facade.subscribe(name, function (data, delta, removed) {\r\n            if (!key && key !== 0) {\r\n                snapshot = data;\r\n                return;\r\n            }\r\n            callback(data, delta, removed, key);\r\n        });\r\n        if (snapshot) {\r\n            callback(snapshot, snapshot, [], key);\r\n            snapshot = null;\r\n        }\r\n        return Promise.resolve(key);\r\n    };\r\n    HCBridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                this.subscribe(name, function (data, un) {\r\n                    _this.unsubscribe(un);\r\n                    resolve(data);\r\n                });\r\n                return [2];\r\n            });\r\n        }); });\r\n    };\r\n    HCBridge.prototype.unsubscribe = function (key) {\r\n        this._facade.unsubscribe(key);\r\n    };\r\n    return HCBridge;\r\n}());\r\nexports.HCBridge = HCBridge;\r\n//# sourceMappingURL=hcBridge.js.map\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3Bridge_1 = __webpack_require__(86);\r\nvar hcBridge_1 = __webpack_require__(88);\r\nvar ContextsModule = (function () {\r\n    function ContextsModule(config) {\r\n        this.config = config;\r\n        try {\r\n            if (config.gdMajorVersion === 2) {\r\n                var hc = window.htmlContainer;\r\n                if (!hc.sharedContextFacade) {\r\n                    throw new Error(\"Your version of HtmlContainer does not support contexts.\"\r\n                        + \" Get version 1.46.0.0 or later to have that feature.\");\r\n                }\r\n                this._bridge = new hcBridge_1.HCBridge(config);\r\n            }\r\n            else if (config.connection.protocolVersion === 3) {\r\n                this._bridge = new gw3Bridge_1.GW3Bridge(config);\r\n            }\r\n            else {\r\n                throw new Error(\"To use the Contexts library you must run in the\"\r\n                    + \" HTML Container or using a connection to Gateway v3.\");\r\n            }\r\n        }\r\n        catch (err) {\r\n            throw err;\r\n        }\r\n    }\r\n    ContextsModule.prototype.all = function () {\r\n        return this._bridge.all();\r\n    };\r\n    ContextsModule.prototype.update = function (name, delta) {\r\n        this.checkName(name);\r\n        return this._bridge.update(name, delta);\r\n    };\r\n    ContextsModule.prototype.set = function (name, data) {\r\n        this.checkName(name);\r\n        return this._bridge.set(name, data);\r\n    };\r\n    ContextsModule.prototype.subscribe = function (name, callback) {\r\n        var _this = this;\r\n        this.checkName(name);\r\n        return this._bridge\r\n            .subscribe(name, function (data, delta, removed, key, extraData) { return callback(data, delta, removed, function () { return _this._bridge.unsubscribe(key); }, extraData); })\r\n            .then(function (key) {\r\n            return function () {\r\n                _this._bridge.unsubscribe(key);\r\n            };\r\n        });\r\n    };\r\n    ContextsModule.prototype.get = function (name) {\r\n        return this._bridge.get(name);\r\n    };\r\n    ContextsModule.prototype.ready = function () {\r\n        return Promise.resolve(this);\r\n    };\r\n    ContextsModule.prototype.checkName = function (name) {\r\n        if (typeof name !== \"string\" ||\r\n            name == \"\") {\r\n            throw new Error(\"'name' must be non-empty string, got '\" + name + \"'\");\r\n        }\r\n    };\r\n    return ContextsModule;\r\n}());\r\nexports.ContextsModule = ContextsModule;\r\n//# sourceMappingURL=contextsModule.js.map\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction applyContextDelta(context, delta) {\r\n    if (delta) {\r\n        if (delta.reset) {\r\n            context = __assign({}, delta.reset);\r\n            return context;\r\n        }\r\n        context = deepClone(context, null);\r\n        var added_1 = delta.added;\r\n        var updated_1 = delta.updated;\r\n        var removed = delta.removed;\r\n        if (added_1) {\r\n            Object.keys(added_1).forEach(function (key) {\r\n                context[key] = added_1[key];\r\n            });\r\n        }\r\n        if (updated_1) {\r\n            Object.keys(updated_1).forEach(function (key) {\r\n                mergeObjectsProperties(key, context, updated_1);\r\n            });\r\n        }\r\n        if (removed) {\r\n            removed.forEach(function (key) {\r\n                delete context[key];\r\n            });\r\n        }\r\n    }\r\n    return context;\r\n}\r\nexports.applyContextDelta = applyContextDelta;\r\nfunction deepClone(obj, hash) {\r\n    hash = hash || new WeakMap();\r\n    if (Object(obj) !== obj) {\r\n        return obj;\r\n    }\r\n    if (obj instanceof Set) {\r\n        return new Set(obj);\r\n    }\r\n    if (hash.has(obj)) {\r\n        return hash.get(obj);\r\n    }\r\n    var result = obj instanceof Date ? new Date(obj)\r\n        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)\r\n            : obj.constructor ? new obj.constructor()\r\n                : Object.create(null);\r\n    hash.set(obj, result);\r\n    if (obj instanceof Map) {\r\n        Array.from(obj, function (_a) {\r\n            var key = _a[0], val = _a[1];\r\n            return result.set(key, deepClone(val, hash));\r\n        });\r\n    }\r\n    return Object.assign.apply(Object, [result].concat(Object.keys(obj).map(function (key) {\r\n        var _a;\r\n        return (_a = {}, _a[key] = deepClone(obj[key], hash), _a);\r\n    })));\r\n}\r\nexports.deepClone = deepClone;\r\nvar mergeObjectsProperties = function (key, what, withWhat) {\r\n    var right = withWhat[key];\r\n    if (right === undefined) {\r\n        return what;\r\n    }\r\n    var left = what[key];\r\n    if (!left || !right) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    if (typeof left === \"string\" ||\r\n        typeof left === \"number\" ||\r\n        typeof left === \"boolean\" ||\r\n        typeof right === \"string\" ||\r\n        typeof right === \"number\" ||\r\n        typeof right === \"boolean\" ||\r\n        Array.isArray(left) ||\r\n        Array.isArray(right)) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    what[key] = Object.assign({}, left, right);\r\n    return what;\r\n};\r\nfunction deepEqual(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    if (!(x instanceof Object) || !(y instanceof Object)) {\r\n        return false;\r\n    }\r\n    if (x.constructor !== y.constructor) {\r\n        return false;\r\n    }\r\n    for (var p in x) {\r\n        if (!x.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (!y.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        if (x[p] === y[p]) {\r\n            continue;\r\n        }\r\n        if (typeof (x[p]) !== \"object\") {\r\n            return false;\r\n        }\r\n        if (!deepEqual(x[p], y[p])) {\r\n            return false;\r\n        }\r\n    }\r\n    for (var p in y) {\r\n        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.deepEqual = deepEqual;\r\n//# sourceMappingURL=helpers.js.map\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar contextsModule_1 = __webpack_require__(89);\r\nexports.ContextsModule = contextsModule_1.ContextsModule;\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar LogLevel = (function () {\r\n    function LogLevel() {\r\n    }\r\n    LogLevel.canPublish = function (level, restriction) {\r\n        var levelIdx = LogLevel.order.indexOf(level);\r\n        var restrictionIdx = LogLevel.order.indexOf(restriction);\r\n        return levelIdx >= restrictionIdx;\r\n    };\r\n    LogLevel.off = \"off\";\r\n    LogLevel.trace = \"trace\";\r\n    LogLevel.debug = \"debug\";\r\n    LogLevel.info = \"info\";\r\n    LogLevel.warn = \"warn\";\r\n    LogLevel.error = \"error\";\r\n    LogLevel.order = [LogLevel.trace, LogLevel.debug, LogLevel.info, LogLevel.warn, LogLevel.error, LogLevel.off];\r\n    return LogLevel;\r\n}());\r\nexports.default = LogLevel;\r\n//# sourceMappingURL=levels.js.map\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar levels_1 = __webpack_require__(92);\r\nvar LoggerImpl = (function () {\r\n    function LoggerImpl(name, parent, metricSystem) {\r\n        this._subloggers = [];\r\n        this._name = name;\r\n        this._parent = parent;\r\n        if (parent) {\r\n            this._path = parent.path + \".\" + name;\r\n        }\r\n        else {\r\n            this._path = name;\r\n        }\r\n        this._loggerFullName = \"[\" + this._path + \"]\";\r\n        if (typeof metricSystem !== \"undefined\") {\r\n            this.metricsLevel(\"warn\", metricSystem.subSystem(name));\r\n        }\r\n    }\r\n    Object.defineProperty(LoggerImpl.prototype, \"name\", {\r\n        get: function () {\r\n            return this._name;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(LoggerImpl.prototype, \"path\", {\r\n        get: function () {\r\n            return this._path;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    LoggerImpl.prototype.subLogger = function (name) {\r\n        var existingSub = this._subloggers.filter(function (subLogger) {\r\n            return subLogger.name === name;\r\n        })[0];\r\n        if (existingSub !== undefined) {\r\n            return existingSub;\r\n        }\r\n        Object.keys(this).forEach(function (key) {\r\n            if (key === name) {\r\n                throw new Error(\"This sub logger name is not allowed.\");\r\n            }\r\n        });\r\n        var sub = new LoggerImpl(name, this);\r\n        this._subloggers.push(sub);\r\n        return sub;\r\n    };\r\n    LoggerImpl.prototype.publishLevel = function (level) {\r\n        if (level !== null && level !== undefined) {\r\n            this._publishLevel = level;\r\n        }\r\n        return this._publishLevel || this._parent.publishLevel();\r\n    };\r\n    LoggerImpl.prototype.consoleLevel = function (level) {\r\n        if (level !== null && level !== undefined) {\r\n            this._consoleLevel = level;\r\n        }\r\n        return this._consoleLevel || this._parent.consoleLevel();\r\n    };\r\n    LoggerImpl.prototype.metricsLevel = function (level, metricsSystem) {\r\n        if (level !== null && level !== undefined) {\r\n            this._metricLevel = level;\r\n        }\r\n        if (metricsSystem !== undefined) {\r\n            if (typeof metricsSystem === \"object\" && typeof metricsSystem.objectMetric === \"function\") {\r\n                this._metricSystem = metricsSystem;\r\n            }\r\n            else {\r\n                throw new Error(\"Please specify metric system\");\r\n            }\r\n        }\r\n        return this._metricLevel || this._parent.metricsLevel();\r\n    };\r\n    LoggerImpl.prototype.log = function (message, level) {\r\n        this.publishMessage(level || levels_1.default.info, message);\r\n    };\r\n    LoggerImpl.prototype.trace = function (message) {\r\n        this.log(message, levels_1.default.trace);\r\n    };\r\n    LoggerImpl.prototype.debug = function (message) {\r\n        this.log(message, levels_1.default.debug);\r\n    };\r\n    LoggerImpl.prototype.info = function (message) {\r\n        this.log(message, levels_1.default.info);\r\n    };\r\n    LoggerImpl.prototype.warn = function (message) {\r\n        this.log(message, levels_1.default.warn);\r\n    };\r\n    LoggerImpl.prototype.error = function (message) {\r\n        this.log(message, levels_1.default.error);\r\n    };\r\n    LoggerImpl.prototype.toAPIObject = function () {\r\n        var that = this;\r\n        return {\r\n            name: this.name,\r\n            subLogger: this.subLogger.bind(that),\r\n            publishLevel: this.publishLevel.bind(that),\r\n            consoleLevel: this.consoleLevel.bind(that),\r\n            metricsLevel: this.metricsLevel.bind(that),\r\n            log: this.log.bind(that),\r\n            trace: this.trace.bind(that),\r\n            debug: this.debug.bind(that),\r\n            info: this.info.bind(that),\r\n            warn: this.warn.bind(that),\r\n            error: this.error.bind(that),\r\n        };\r\n    };\r\n    LoggerImpl.prototype.publishMessage = function (level, message) {\r\n        var loggerName = this._loggerFullName;\r\n        if (level === levels_1.default.error) {\r\n            var e = new Error();\r\n            if (e.stack) {\r\n                message = message + \"\\n\" +\r\n                    (e.stack.split(\"\\n\").slice(3).join(\"\\n\"));\r\n            }\r\n        }\r\n        if (levels_1.default.canPublish(level, this.consoleLevel())) {\r\n            var toPrint = loggerName + \": \" + message;\r\n            switch (level) {\r\n                case levels_1.default.trace:\r\n                    console.trace(toPrint);\r\n                    break;\r\n                case levels_1.default.debug:\r\n                    if (console.debug) {\r\n                        console.debug(toPrint);\r\n                    }\r\n                    else {\r\n                        console.log(toPrint);\r\n                    }\r\n                    break;\r\n                case levels_1.default.info:\r\n                    console.info(toPrint);\r\n                    break;\r\n                case levels_1.default.warn:\r\n                    console.warn(toPrint);\r\n                    break;\r\n                case levels_1.default.error:\r\n                    console.error(toPrint);\r\n                    break;\r\n            }\r\n        }\r\n        if (levels_1.default.canPublish(level, this.publishLevel())) {\r\n            LoggerImpl.GetConnection().send(\"log\", \"LogMessage\", {\r\n                instance: LoggerImpl.Instance,\r\n                level: levels_1.default.order.indexOf(level),\r\n                logger: loggerName,\r\n                message: message,\r\n            });\r\n        }\r\n        if (levels_1.default.canPublish(level, this.metricsLevel())) {\r\n            if (this._metricSystem !== undefined) {\r\n                this._metricSystem.objectMetric(\"LogMessage\", {\r\n                    Level: level,\r\n                    Logger: loggerName,\r\n                    Message: message,\r\n                    Time: new Date(),\r\n                });\r\n                if (level === levels_1.default.error) {\r\n                    this._metricSystem.setState(100, message);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return LoggerImpl;\r\n}());\r\nexports.default = LoggerImpl;\r\n//# sourceMappingURL=logger.js.map\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar logger_1 = __webpack_require__(93);\r\nexports.default = (function (settings) {\r\n    var identity = settings.identity;\r\n    if (!identity) {\r\n        throw new Error(\"identity is missing\");\r\n    }\r\n    var identityStr = identity.system + \"\\\\\" + identity.service + \"\\\\\" + identity.instance;\r\n    logger_1.default.Instance = identityStr;\r\n    logger_1.default.GetConnection = settings.getConnection;\r\n    var mainLogger = new logger_1.default(\"main\");\r\n    mainLogger.publishLevel(settings.publish || \"off\");\r\n    mainLogger.consoleLevel(settings.console || \"info\");\r\n    mainLogger.metricsLevel(settings.metrics || \"off\");\r\n    var apiLogger = mainLogger.toAPIObject();\r\n    return apiLogger;\r\n});\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar glue_1 = __webpack_require__(28);\r\nvar pjson = __webpack_require__(15);\r\nif (typeof window !== \"undefined\") {\r\n    window.GlueCore = glue_1.default;\r\n}\r\nglue_1.default.default = glue_1.default;\r\nglue_1.default.version = pjson.version;\r\nmodule.exports = glue_1.default;\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction addressMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var conflation = definition.conflation;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.ADDRESS;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = addressMetric;\r\n//# sourceMappingURL=address.js.map\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction countMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || 0;\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.COUNT;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function incrementBy(num) {\r\n        update(_value + num);\r\n    }\r\n    function increment() {\r\n        incrementBy(1);\r\n    }\r\n    function decrement() {\r\n        incrementBy(-1);\r\n    }\r\n    function decrementBy(num) {\r\n        incrementBy(num * -1);\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get path() {\r\n            return _path;\r\n        },\r\n        get value() {\r\n            return _value;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n        incrementBy: incrementBy,\r\n        increment: increment,\r\n        decrement: decrement,\r\n        decrementBy: decrementBy,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = countMetric;\r\n//# sourceMappingURL=count.js.map\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction numberMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _path = parent.path.slice(0);\r\n    var _value = value || 0;\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.NUMBER;\r\n    _path.push(parent.name);\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function incrementBy(num) {\r\n        update(_value + num);\r\n    }\r\n    function increment() {\r\n        incrementBy(1);\r\n    }\r\n    function decrement() {\r\n        incrementBy(-1);\r\n    }\r\n    function decrementBy(num) {\r\n        incrementBy(num * -1);\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        type: type,\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n        incrementBy: incrementBy,\r\n        increment: increment,\r\n        decrement: decrement,\r\n        decrementBy: decrementBy,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = numberMetric;\r\n//# sourceMappingURL=number.js.map\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = __webpack_require__(0);\r\nvar helpers_1 = __webpack_require__(2);\r\nfunction objectMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.OBJECT;\r\n    function update(newValue) {\r\n        mergeValues(newValue);\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function mergeValues(values) {\r\n        return Object.keys(_value).forEach(function (k) {\r\n            if (typeof values[k] !== \"undefined\") {\r\n                _value[k] = values[k];\r\n            }\r\n        });\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = objectMetric;\r\n//# sourceMappingURL=object.js.map\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction rateMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.RATE;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = rateMetric;\r\n//# sourceMappingURL=rate.js.map\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction statisticsMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.STATISTICS;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = statisticsMetric;\r\n//# sourceMappingURL=statistics.js.map\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction stringMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.STRING;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        type: type,\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = stringMetric;\r\n//# sourceMappingURL=string.js.map\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction timespanMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.TIMESPAN;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function start() {\r\n        update(true);\r\n    }\r\n    function stop() {\r\n        update(false);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        start: start,\r\n        stop: stop,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = timespanMetric;\r\n//# sourceMappingURL=timespan.js.map\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(2);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction timestampMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.TIMESTAMP;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function now() {\r\n        update(new Date());\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        now: now,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = timestampMetric;\r\n//# sourceMappingURL=timestamp.js.map\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar serializer_1 = __webpack_require__(106);\r\nfunction default_1(connection, config) {\r\n    var DEFAULT_HEARTBEAT_INTERVAL = 3000;\r\n    var heartbeatTimer;\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var _connection = connection;\r\n    var heartbeatInterval = config.heartbeatInterval || DEFAULT_HEARTBEAT_INTERVAL;\r\n    var send = function (type, message) {\r\n        _connection.send(\"metrics\", type, message);\r\n    };\r\n    function sendFull(repo) {\r\n        if (!repo.root) {\r\n            return;\r\n        }\r\n        if (repo.root.subSystems.length === 0) {\r\n            return;\r\n        }\r\n        sendFullSystem(repo.root);\r\n    }\r\n    function sendFullSystem(system) {\r\n        createSystem(system);\r\n        system.subSystems.forEach(function (sub) {\r\n            sendFullSystem(sub);\r\n        });\r\n        system.metrics.forEach(function (metric) {\r\n            createMetric(metric);\r\n        });\r\n    }\r\n    function heartbeat(repo) {\r\n        send(\"HeartbeatMetrics\", {\r\n            publishingInterval: heartbeatInterval,\r\n            instance: repo.instance,\r\n        });\r\n    }\r\n    function createSystem(system) {\r\n        if (system.parent !== undefined) {\r\n            send(\"CreateMetricSystem\", {\r\n                id: system.id,\r\n                instance: system.repo.instance,\r\n                definition: {\r\n                    name: system.name,\r\n                    description: system.description,\r\n                    path: system.path,\r\n                },\r\n            });\r\n        }\r\n    }\r\n    function updateSystem(system, state) {\r\n        send(\"UpdateMetricSystem\", {\r\n            id: system.id,\r\n            instance: system.repo.instance,\r\n            state: state,\r\n        });\r\n    }\r\n    function createMetric(metric) {\r\n        send(\"CreateMetric\", serializer_1.default(metric));\r\n    }\r\n    function updateMetric(metric) {\r\n        send(\"UpdateMetric\", serializer_1.default(metric));\r\n    }\r\n    function init(repo) {\r\n        heartbeat(repo);\r\n        _connection.on(\"metrics\", \"MetricsSnapshotRequest\", function (instanceInfo) {\r\n            if (instanceInfo.Instance !== repo.instance) {\r\n                return;\r\n            }\r\n            sendFull(repo);\r\n        });\r\n        _connection.disconnected(function () { return clearInterval(heartbeatTimer); });\r\n        if (typeof window !== \"undefined\" && typeof window.htmlContainer === \"undefined\") {\r\n            heartbeatTimer = setInterval(function () {\r\n                heartbeat(repo);\r\n            }, heartbeatInterval);\r\n        }\r\n    }\r\n    var me = {\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n        init: init,\r\n    };\r\n    return me;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw1.js.map\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction metricToMessage(metric) {\r\n    var definition = getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution, metric.conflation);\r\n    function getMetricDefinition(name, value, path, type, description, period, resolution, conflation) {\r\n        var _definition = {\r\n            name: name,\r\n            description: description,\r\n            type: type ? type : getTypeFromValue(value),\r\n            path: path,\r\n            resolution: resolution,\r\n            period: period,\r\n            conflation: conflation,\r\n        };\r\n        if (_definition.type === metric_types_1.default.OBJECT) {\r\n            _definition.Composite = Object.keys(value).reduce(function (arr, key) {\r\n                var val = value[key];\r\n                arr.push(getMetricDefinition(key, val, path));\r\n                return arr;\r\n            }, []);\r\n        }\r\n        return _definition;\r\n    }\r\n    function serializeValue(value, _metric) {\r\n        if (value && value.constructor === Date) {\r\n            return {\r\n                value: {\r\n                    type: _valueTypes.indexOf(\"date\"),\r\n                    value: value.valueOf(),\r\n                    isArray: false,\r\n                },\r\n            };\r\n        }\r\n        if (typeof value === \"object\") {\r\n            return {\r\n                CompositeValue: Object.keys(value).reduce(function (arr, key) {\r\n                    var val = serializeValue(value[key]);\r\n                    val.InnerMetricName = key;\r\n                    arr.push(val);\r\n                    return arr;\r\n                }, []),\r\n            };\r\n        }\r\n        var valueType = _metric ? _metric.getValueType() : undefined;\r\n        valueType = valueType || _valueTypes.indexOf(typeof value);\r\n        return {\r\n            value: {\r\n                type: valueType,\r\n                value: value,\r\n                isArray: false,\r\n            },\r\n        };\r\n    }\r\n    function getTypeFromValue(value) {\r\n        var typeAsString = value.constructor === Date ? \"timestamp\" : typeof value;\r\n        switch (typeAsString) {\r\n            case \"string\":\r\n                return metric_types_1.default.STRING;\r\n            case \"number\":\r\n                return metric_types_1.default.NUMBER;\r\n            case \"timestamp\":\r\n                return metric_types_1.default.TIMESTAMP;\r\n            case \"object\":\r\n                return metric_types_1.default.OBJECT;\r\n        }\r\n        return 0;\r\n    }\r\n    var _valueTypes = [\r\n        \"boolean\",\r\n        \"int\",\r\n        \"number\",\r\n        \"long\",\r\n        \"string\",\r\n        \"date\",\r\n        \"object\",\r\n    ];\r\n    return {\r\n        id: metric.id,\r\n        instance: metric.repo.instance,\r\n        definition: definition,\r\n        value: serializeValue(metric.value, metric),\r\n    };\r\n}\r\nexports.default = metricToMessage;\r\n//# sourceMappingURL=serializer.js.map\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar serializer_1 = __webpack_require__(108);\r\nfunction default_1(connection, config) {\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var joinPromise;\r\n    var session;\r\n    var init = function (repo) {\r\n        var resolveReadyPromise;\r\n        joinPromise = new Promise(function (resolve) {\r\n            resolveReadyPromise = resolve;\r\n        });\r\n        session = connection.domain(\"metrics\", config.logger);\r\n        session.onJoined(function (reconnect) {\r\n            if (!reconnect) {\r\n                resolveReadyPromise();\r\n                resolveReadyPromise = undefined;\r\n            }\r\n            var rootStateMetric = {\r\n                name: \"/State\",\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var defineRootMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [rootStateMetric],\r\n            };\r\n            session.send(defineRootMetricsMsg);\r\n            if (reconnect) {\r\n                replayRepo(repo);\r\n            }\r\n        });\r\n        session.join(config.identity);\r\n    };\r\n    var replayRepo = function (repo) {\r\n        replaySystem(repo.root);\r\n    };\r\n    var replaySystem = function (system) {\r\n        createSystem(system);\r\n        system.metrics.forEach(function (m) {\r\n            createMetric(m);\r\n        });\r\n        system.subSystems.forEach(function (ss) {\r\n            replaySystem(ss);\r\n        });\r\n    };\r\n    var createSystem = function (system) {\r\n        if (system.parent === undefined) {\r\n            return;\r\n        }\r\n        joinPromise.then(function () {\r\n            var metric = {\r\n                name: serializer_1.normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var createMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [metric],\r\n            };\r\n            session.send(createMetricsMsg);\r\n        });\r\n    };\r\n    var updateSystem = function (system, state) {\r\n        joinPromise.then(function () {\r\n            var shadowedUpdateMetric = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: serializer_1.normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                        value: {\r\n                            Description: state.description,\r\n                            Value: state.state,\r\n                        },\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(shadowedUpdateMetric);\r\n            var stateObj = serializer_1.composeMsgForRootStateMetric(system);\r\n            var rootMetric = {\r\n                type: \"publish\",\r\n                peer_id: connection.peerId,\r\n                values: [{\r\n                        name: \"/State\",\r\n                        value: {\r\n                            Description: stateObj.description,\r\n                            Value: stateObj.value,\r\n                        },\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(rootMetric);\r\n        });\r\n    };\r\n    var createMetric = function (metric) {\r\n        joinPromise.then(function () {\r\n            var m = serializer_1.serializeMetric(metric);\r\n            var createMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [m],\r\n            };\r\n            session.send(createMetricsMsg);\r\n            if (typeof metric.value !== \"undefined\") {\r\n                updateMetric(metric);\r\n            }\r\n        });\r\n    };\r\n    var updateMetric = function (metric) {\r\n        joinPromise.then(function () {\r\n            var value = serializer_1.getMetricValueByType(metric);\r\n            var publishMetricsMsg = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: serializer_1.normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name),\r\n                        value: value,\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(publishMetricsMsg);\r\n        });\r\n    };\r\n    return {\r\n        init: init,\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3.js.map\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction getMetricTypeByValue(metric) {\r\n    if ((metric.value && metric.value.constructor === Date) || metric.type === metric_types_1.default.TIMESPAN || metric.type === metric_types_1.default.TIMESTAMP) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof metric.value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof metric.value === \"string\" || metric.type === metric_types_1.default.STRING || metric.type === metric_types_1.default.RATE) {\r\n        return \"string\";\r\n    }\r\n    else if (typeof metric.value === \"object\") {\r\n        return \"object\";\r\n    }\r\n}\r\nfunction getTypeByValue(value) {\r\n    if (value.constructor === Date) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof value === \"string\") {\r\n        return \"string\";\r\n    }\r\n    else if (typeof value === \"object\") {\r\n        return \"object\";\r\n    }\r\n    else {\r\n        return \"string\";\r\n    }\r\n}\r\nfunction serializeMetric(metric) {\r\n    var serializedMetrics = {};\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"object\") {\r\n        var values = Object.keys(metric.value).reduce(function (memo, key) {\r\n            var innerType = getTypeByValue(metric.value[key]);\r\n            if (innerType === \"object\") {\r\n                var composite = defineNestedComposite(metric.value[key]);\r\n                memo[key] = {\r\n                    type: \"object\",\r\n                    description: \"\",\r\n                    context: {},\r\n                    composite: composite,\r\n                };\r\n            }\r\n            else {\r\n                memo[key] = {\r\n                    type: innerType,\r\n                    description: \"\",\r\n                    context: {},\r\n                };\r\n            }\r\n            return memo;\r\n        }, {});\r\n        serializedMetrics.composite = values;\r\n    }\r\n    serializedMetrics.name = normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name);\r\n    serializedMetrics.type = type;\r\n    serializedMetrics.description = metric.description;\r\n    serializedMetrics.context = {};\r\n    return serializedMetrics;\r\n}\r\nexports.serializeMetric = serializeMetric;\r\nfunction defineNestedComposite(values) {\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var type = getTypeByValue(values[key]);\r\n        if (type === \"object\") {\r\n            memo[key] = {\r\n                type: \"object\",\r\n                description: \"\",\r\n                context: {},\r\n                composite: defineNestedComposite(values[key]),\r\n            };\r\n        }\r\n        else {\r\n            memo[key] = {\r\n                type: type,\r\n                description: \"\",\r\n                context: {},\r\n            };\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction normalizeMetricName(name) {\r\n    if (typeof name !== \"undefined\" && name.length > 0 && name[0] !== \"/\") {\r\n        return \"/\" + name;\r\n    }\r\n    else {\r\n        return name;\r\n    }\r\n}\r\nexports.normalizeMetricName = normalizeMetricName;\r\nfunction getMetricValueByType(metric) {\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"timestamp\") {\r\n        return Date.now();\r\n    }\r\n    else {\r\n        return publishNestedComposite(metric.value);\r\n    }\r\n}\r\nexports.getMetricValueByType = getMetricValueByType;\r\nfunction publishNestedComposite(values) {\r\n    if (typeof values !== \"object\") {\r\n        return values;\r\n    }\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var value = values[key];\r\n        if (typeof value === \"object\" && value.constructor !== Date) {\r\n            memo[key] = publishNestedComposite(value);\r\n        }\r\n        else if (value.constructor === Date) {\r\n            memo[key] = new Date(value).getTime();\r\n        }\r\n        else if (value.constructor === Boolean) {\r\n            memo[key] = value.toString();\r\n        }\r\n        else {\r\n            memo[key] = value;\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction flatten(arr) {\r\n    return arr.reduce(function (flat, toFlatten) {\r\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\r\n    }, []);\r\n}\r\nfunction getHighestState(arr) {\r\n    return arr.sort(function (a, b) {\r\n        return b.state - a.state;\r\n    })[0];\r\n}\r\nfunction aggregateDescription(arr) {\r\n    var msg = \"\";\r\n    arr.forEach(function (m, idx, a) {\r\n        var path = m.path.join(\".\");\r\n        if (idx === a.length - 1) {\r\n            msg += path + \".\" + m.name + \": \" + m.description;\r\n        }\r\n        else {\r\n            msg += path + \".\" + m.name + \": \" + m.description + \",\";\r\n        }\r\n    });\r\n    if (msg.length > 100) {\r\n        return msg.slice(0, 100) + \"...\";\r\n    }\r\n    else {\r\n        return msg;\r\n    }\r\n}\r\nfunction composeMsgForRootStateMetric(system) {\r\n    var aggregatedState = system.root.getAggregateState();\r\n    var merged = flatten(aggregatedState);\r\n    var highestState = getHighestState(merged);\r\n    var aggregateDesc = aggregateDescription(merged);\r\n    return {\r\n        description: aggregateDesc,\r\n        value: highestState.state,\r\n    };\r\n}\r\nexports.composeMsgForRootStateMetric = composeMsgForRootStateMetric;\r\n//# sourceMappingURL=serializer.js.map\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3_1 = __webpack_require__(107);\r\nvar gw1_1 = __webpack_require__(105);\r\nvar repository_1 = __webpack_require__(110);\r\nexports.default = (function (settings) {\r\n    var options = {\r\n        connection: settings.connection,\r\n        identity: settings.identity,\r\n        logger: settings.logger,\r\n        heartbeatInterval: settings.heartbeatInterval,\r\n        settings: {},\r\n        clickStream: settings.clickStream,\r\n    };\r\n    if (!options.connection || typeof options.connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var _protocol;\r\n    if (options.connection.protocolVersion === 3) {\r\n        _protocol = gw3_1.default(options.connection, settings);\r\n    }\r\n    else {\r\n        _protocol = gw1_1.default(options.connection, settings);\r\n    }\r\n    var repo = repository_1.default(options, _protocol);\r\n    var rootSystem = repo.root;\r\n    return rootSystem;\r\n});\r\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar system_1 = __webpack_require__(111);\r\nfunction repository(options, protocol) {\r\n    if (!options.identity) {\r\n        throw new Error(\"Identity missing from metrics configuration\");\r\n    }\r\n    if (!options.identity.service || typeof options.identity.service !== \"string\") {\r\n        throw new Error(\"Service missing or invalid in metrics identity configuration\");\r\n    }\r\n    if (!options.identity.system || typeof options.identity.system !== \"string\") {\r\n        throw new Error(\"System missing or invalid in metrics identity configuration\");\r\n    }\r\n    if (!options.identity.instance || typeof options.identity.instance !== \"string\") {\r\n        throw new Error(\"Instance missing or invalid in metrics identity configuration\");\r\n    }\r\n    var identity = options.identity;\r\n    var instance = options.identity.system + \"/\" + options.identity.service + \"/\" + options.identity.instance;\r\n    function _initSystemMetrics(rootSystem, useClickStream) {\r\n        if (typeof navigator !== \"undefined\") {\r\n            rootSystem.stringMetric(\"UserAgent\", navigator.userAgent);\r\n        }\r\n        if (useClickStream && typeof document !== \"undefined\") {\r\n            var clickStream_1 = rootSystem.subSystem(\"ClickStream\");\r\n            var documentClickHandler = function (e) {\r\n                if (!e.target) {\r\n                    return;\r\n                }\r\n                var target = e.target;\r\n                clickStream_1.objectMetric(\"LastBrowserEvent\", {\r\n                    type: \"click\",\r\n                    timestamp: new Date(),\r\n                    target: {\r\n                        className: e.target ? target.className : \"\",\r\n                        id: target.id,\r\n                        type: \"<\" + target.tagName.toLowerCase() + \">\",\r\n                        href: target.href || \"\",\r\n                    },\r\n                });\r\n            };\r\n            clickStream_1.objectMetric(\"Page\", {\r\n                title: document.title,\r\n                page: window.location.href,\r\n            });\r\n            if (document.addEventListener) {\r\n                document.addEventListener(\"click\", documentClickHandler);\r\n            }\r\n            else {\r\n                document.attachEvent(\"onclick\", documentClickHandler);\r\n            }\r\n        }\r\n        var startTime = rootSystem.stringMetric(\"StartTime\", (new Date()).toString());\r\n        var urlMetric = rootSystem.stringMetric(\"StartURL\", \"\");\r\n        var appNameMetric = rootSystem.stringMetric(\"AppName\", \"\");\r\n        if (typeof window !== \"undefined\") {\r\n            if (typeof window.location !== \"undefined\") {\r\n                var startUrl = window.location.href;\r\n                urlMetric.update(startUrl);\r\n            }\r\n            if (typeof window.glue42gd !== \"undefined\") {\r\n                appNameMetric.update(window.glue42gd.appName);\r\n            }\r\n        }\r\n    }\r\n    var me = {\r\n        identity: identity,\r\n        instance: instance,\r\n        get root() {\r\n            return _root;\r\n        },\r\n    };\r\n    protocol.init(me);\r\n    var _root = system_1.default(\"\", me, protocol);\r\n    _initSystemMetrics(_root, options.clickStream || options.clickStream === undefined);\r\n    return me;\r\n}\r\nexports.default = repository;\r\n//# sourceMappingURL=repository.js.map\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar address_1 = __webpack_require__(96);\r\nvar count_1 = __webpack_require__(97);\r\nvar number_1 = __webpack_require__(98);\r\nvar object_1 = __webpack_require__(99);\r\nvar rate_1 = __webpack_require__(100);\r\nvar statistics_1 = __webpack_require__(101);\r\nvar string_1 = __webpack_require__(102);\r\nvar timespan_1 = __webpack_require__(103);\r\nvar timestamp_1 = __webpack_require__(104);\r\nvar metric_types_1 = __webpack_require__(0);\r\nfunction system(name, repo, protocol, parent, description) {\r\n    if (!repo) {\r\n        throw new Error(\"Repository is required\");\r\n    }\r\n    if (!protocol) {\r\n        throw new Error(\"Transport is required\");\r\n    }\r\n    var _transport = protocol;\r\n    var _name = name;\r\n    var _description = description || \"\";\r\n    var _repo = repo;\r\n    var _parent = parent;\r\n    var _path = _buildPath(parent);\r\n    var _state = {};\r\n    var id = _arrayToString(_path, \"/\") + name;\r\n    var identity = repo.identity;\r\n    var root = repo.root;\r\n    var _subSystems = [];\r\n    var _metrics = [];\r\n    function subSystem(nameSystem, descriptionSystem) {\r\n        if (!nameSystem || nameSystem.length === 0) {\r\n            throw new Error(\"name is required\");\r\n        }\r\n        var match = _subSystems.filter(function (s) { return s.name === nameSystem; });\r\n        if (match.length > 0) {\r\n            return match[0];\r\n        }\r\n        var _system = system(nameSystem, _repo, _transport, me, descriptionSystem);\r\n        _subSystems.push(_system);\r\n        return _system;\r\n    }\r\n    function setState(state, stateDescription) {\r\n        _state = { state: state, description: stateDescription };\r\n        _transport.updateSystem(me, _state);\r\n    }\r\n    function stringMetric(definition, value) {\r\n        return _getOrCreateMetric.call(me, definition, metric_types_1.default.STRING, value, function (metricDef) { return string_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function numberMetric(definition, value) {\r\n        return _getOrCreateMetric.call(me, definition, metric_types_1.default.NUMBER, value, function (metricDef) { return number_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function countMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.COUNT, value, function (metricDef) { return count_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function addressMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.ADDRESS, value, function (metricDef) { return address_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function objectMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.OBJECT, value, function (metricDef) { return object_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function timespanMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.TIMESPAN, value, function (metricDef) { return timespan_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function timestampMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.TIMESTAMP, value, function (metricDef) { return timestamp_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function rateMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.RATE, value, function (metricDef) { return rate_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function statisticsMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.STATISTICS, value, function (metricDef) { return statistics_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function _unionToMetricDef(def) {\r\n        var metricDefinition = {};\r\n        if (typeof def === \"string\") {\r\n            metricDefinition.name = def;\r\n        }\r\n        else {\r\n            metricDefinition = def;\r\n        }\r\n        if (metricDefinition.name === undefined) {\r\n            throw new Error(\"Metric name is required\");\r\n        }\r\n        return metricDefinition;\r\n    }\r\n    function _getOrCreateMetric(definition, expectedType, value, createMetric) {\r\n        var metricDefinition = _unionToMetricDef(definition);\r\n        var matching = _metrics.filter(function (shadowedMetric) { return shadowedMetric.name === metricDefinition.name; });\r\n        if (matching.length > 0) {\r\n            var existing = matching[0];\r\n            if (existing.type !== expectedType) {\r\n                throw new Error(\"A metric named \" + metricDefinition.name + \" is already defined with different type.\");\r\n            }\r\n            if (typeof value !== \"undefined\") {\r\n                existing.update(value);\r\n            }\r\n            return existing;\r\n        }\r\n        var metric = createMetric(metricDefinition);\r\n        _metrics.push(metric);\r\n        return metric;\r\n    }\r\n    function _buildPath(shadowedSystem) {\r\n        if (!shadowedSystem || !shadowedSystem.parent) {\r\n            return [];\r\n        }\r\n        var path = _buildPath(shadowedSystem.parent);\r\n        path.push(shadowedSystem.name);\r\n        return path;\r\n    }\r\n    function _arrayToString(path, separator) {\r\n        return ((path && path.length > 0) ? path.join(separator) : \"\");\r\n    }\r\n    function getAggregateState() {\r\n        var aggState = [];\r\n        if (Object.keys(_state).length > 0) {\r\n            aggState.push({\r\n                name: _name,\r\n                path: _path,\r\n                state: _state.state,\r\n                description: _state.description,\r\n            });\r\n        }\r\n        _subSystems.forEach(function (shadowedSubSystem) {\r\n            var result = shadowedSubSystem.getAggregateState();\r\n            if (result.length > 0) {\r\n                aggState.push.apply(aggState, result);\r\n            }\r\n        });\r\n        return aggState;\r\n    }\r\n    var me = {\r\n        get name() {\r\n            return _name;\r\n        },\r\n        get description() {\r\n            return _description;\r\n        },\r\n        get repo() {\r\n            return _repo;\r\n        },\r\n        get parent() {\r\n            return _parent;\r\n        },\r\n        path: _path,\r\n        id: id,\r\n        identity: identity,\r\n        root: root,\r\n        get subSystems() {\r\n            return _subSystems;\r\n        },\r\n        get metrics() {\r\n            return _metrics;\r\n        },\r\n        subSystem: subSystem,\r\n        getState: function () {\r\n            return _state;\r\n        },\r\n        setState: setState,\r\n        stringMetric: stringMetric,\r\n        statisticsMetric: statisticsMetric,\r\n        rateMetric: rateMetric,\r\n        timestampMetric: timestampMetric,\r\n        timespanMetric: timespanMetric,\r\n        objectMetric: objectMetric,\r\n        addressMetric: addressMetric,\r\n        countMetric: countMetric,\r\n        numberMetric: numberMetric,\r\n        getAggregateState: getAggregateState,\r\n    };\r\n    _transport.createSystem(me);\r\n    return me;\r\n}\r\nexports.default = system;\r\n//# sourceMappingURL=system.js.map\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1() {\r\n    function now() {\r\n        return new Date().getTime();\r\n    }\r\n    var startTime = now();\r\n    var endTime;\r\n    var period;\r\n    function stop() {\r\n        endTime = now();\r\n        period = now() - startTime;\r\n        return period;\r\n    }\r\n    return {\r\n        get startTime() {\r\n            return startTime;\r\n        },\r\n        get endTime() {\r\n            return endTime;\r\n        },\r\n        get period() {\r\n            return period;\r\n        },\r\n        stop: stop\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"cluster\");\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"fs\");\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"https\");\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"stream\");\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"tls\");\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"zlib\");\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// tick42-glue-core.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 95);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8cb2f5747093b3860f93","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    DEFAULT: 0,\r\n    STRING: 1,\r\n    NUMBER: 2,\r\n    COUNT: 3,\r\n    RATE: 4,\r\n    STATISTICS: 6,\r\n    TIMESTAMP: 7,\r\n    ADDRESS: 8,\r\n    TIMESPAN: 10,\r\n    OBJECT: 11\r\n};\r\n//# sourceMappingURL=metric-types.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/const/metric-types.js\n// module id = 0\n// module chunks = 0","\"use strict\";\r\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            callbacks[key] = allForKey;\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear\r\n    };\r\n}\r\n;\r\ncreateRegistry.default = createRegistry;\r\nmodule.exports = createRegistry;\r\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/callback-registry/lib/index.js\n// module id = 1\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    validate: function (definition, parent, transport) {\r\n        if (definition === null || typeof definition !== \"object\") {\r\n            throw new Error(\"Missing definition\");\r\n        }\r\n        if (parent === null || typeof parent !== \"object\") {\r\n            throw new Error(\"Missing parent\");\r\n        }\r\n        if (transport === null || typeof transport !== \"object\") {\r\n            throw new Error(\"Missing transport\");\r\n        }\r\n    },\r\n};\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/helpers.js\n// module id = 2\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 3\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar shortid = require(\"shortid\");\r\nexports.default = shortid;\r\n//# sourceMappingURL=random.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/helpers/random.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nfunction get () {\n  return alphabet || ORIGINAL;\n}\n\nmodule.exports = {\n    get: get,\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/alphabet.js\n// module id = 5\n// module chunks = 0","\nvar zlib = require('zlib');\n\nvar AVAILABLE_WINDOW_BITS = [8, 9, 10, 11, 12, 13, 14, 15];\nvar DEFAULT_WINDOW_BITS = 15;\nvar DEFAULT_MEM_LEVEL = 8;\n\nPerMessageDeflate.extensionName = 'permessage-deflate';\n\n/**\n * Per-message Compression Extensions implementation\n */\n\nfunction PerMessageDeflate(options, isServer) {\n  this._options = options || {};\n  this._isServer = !!isServer;\n  this._inflate = null;\n  this._deflate = null;\n  this.params = null;\n}\n\n/**\n * Create extension parameters offer\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.offer = function() {\n  var params = {};\n  if (this._options.serverNoContextTakeover) {\n    params.server_no_context_takeover = true;\n  }\n  if (this._options.clientNoContextTakeover) {\n    params.client_no_context_takeover = true;\n  }\n  if (this._options.serverMaxWindowBits) {\n    params.server_max_window_bits = this._options.serverMaxWindowBits;\n  }\n  if (this._options.clientMaxWindowBits) {\n    params.client_max_window_bits = this._options.clientMaxWindowBits;\n  } else if (this._options.clientMaxWindowBits == null) {\n    params.client_max_window_bits = true;\n  }\n  return params;\n};\n\n/**\n * Accept extension offer\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.accept = function(paramsList) {\n  paramsList = this.normalizeParams(paramsList);\n\n  var params;\n  if (this._isServer) {\n    params = this.acceptAsServer(paramsList);\n  } else {\n    params = this.acceptAsClient(paramsList);\n  }\n\n  this.params = params;\n  return params;\n};\n\n/**\n * Accept extension offer from client\n *\n * @api private\n */\n\nPerMessageDeflate.prototype.acceptAsServer = function(paramsList) {\n  var accepted = {};\n  var result = paramsList.some(function(params) {\n    accepted = {};\n    if (this._options.serverNoContextTakeover === false && params.server_no_context_takeover) {\n      return;\n    }\n    if (this._options.serverMaxWindowBits === false && params.server_max_window_bits) {\n      return;\n    }\n    if (typeof this._options.serverMaxWindowBits === 'number' &&\n        typeof params.server_max_window_bits === 'number' &&\n        this._options.serverMaxWindowBits > params.server_max_window_bits) {\n      return;\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n      return;\n    }\n\n    if (this._options.serverNoContextTakeover || params.server_no_context_takeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover !== false && params.client_no_context_takeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof this._options.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n    } else if (typeof params.server_max_window_bits === 'number') {\n      accepted.server_max_window_bits = params.server_max_window_bits;\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits !== false && typeof params.client_max_window_bits === 'number') {\n      accepted.client_max_window_bits = params.client_max_window_bits;\n    }\n    return true;\n  }, this);\n\n  if (!result) {\n    throw new Error('Doesn\\'t support the offered configuration');\n  }\n\n  return accepted;\n};\n\n/**\n * Accept extension response from server\n *\n * @api privaye\n */\n\nPerMessageDeflate.prototype.acceptAsClient = function(paramsList) {\n  var params = paramsList[0];\n  if (this._options.clientNoContextTakeover != null) {\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n  }\n  if (this._options.clientMaxWindowBits != null) {\n    if (this._options.clientMaxWindowBits === false && params.client_max_window_bits) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number' &&\n        (!params.client_max_window_bits || params.client_max_window_bits > this._options.clientMaxWindowBits)) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n  }\n  return params;\n};\n\n/**\n * Normalize extensions parameters\n *\n * @api private\n */\n\nPerMessageDeflate.prototype.normalizeParams = function(paramsList) {\n  return paramsList.map(function(params) {\n    Object.keys(params).forEach(function(key) {\n      var value = params[key];\n      if (value.length > 1) {\n        throw new Error('Multiple extension parameters for ' + key);\n      }\n\n      value = value[0];\n\n      switch (key) {\n      case 'server_no_context_takeover':\n      case 'client_no_context_takeover':\n        if (value !== true) {\n          throw new Error('invalid extension parameter value for ' + key + ' (' + value + ')');\n        }\n        params[key] = true;\n        break;\n      case 'server_max_window_bits':\n      case 'client_max_window_bits':\n        if (typeof value === 'string') {\n          value = parseInt(value, 10);\n          if (!~AVAILABLE_WINDOW_BITS.indexOf(value)) {\n            throw new Error('invalid extension parameter value for ' + key + ' (' + value + ')');\n          }\n        }\n        if (!this._isServer && value === true) {\n          throw new Error('Missing extension parameter value for ' + key);\n        }\n        params[key] = value;\n        break;\n      default:\n        throw new Error('Not defined extension parameter (' + key + ')');\n      }\n    }, this);\n    return params;\n  }, this);\n};\n\n/**\n * Decompress message\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.decompress = function (data, fin, callback) {\n  var endpoint = this._isServer ? 'client' : 'server';\n\n  if (!this._inflate) {\n    var maxWindowBits = this.params[endpoint + '_max_window_bits'];\n    this._inflate = zlib.createInflateRaw({\n      windowBits: 'number' === typeof maxWindowBits ? maxWindowBits : DEFAULT_WINDOW_BITS\n    });\n  }\n\n  var self = this;\n  var buffers = [];\n\n  this._inflate.on('error', onError).on('data', onData);\n  this._inflate.write(data);\n  if (fin) {\n    this._inflate.write(new Buffer([0x00, 0x00, 0xff, 0xff]));\n  }\n  this._inflate.flush(function() {\n    cleanup();\n    callback(null, Buffer.concat(buffers));\n  });\n\n  function onError(err) {\n    cleanup();\n    callback(err);\n  }\n\n  function onData(data) {\n    buffers.push(data);\n  }\n\n  function cleanup() {\n    self._inflate.removeListener('error', onError);\n    self._inflate.removeListener('data', onData);\n    if (fin && self.params[endpoint + '_no_context_takeover']) {\n      self._inflate = null;\n    }\n  }\n};\n\n/**\n * Compress message\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.compress = function (data, fin, callback) {\n  var endpoint = this._isServer ? 'server' : 'client';\n\n  if (!this._deflate) {\n    var maxWindowBits = this.params[endpoint + '_max_window_bits'];\n    this._deflate = zlib.createDeflateRaw({\n      flush: zlib.Z_SYNC_FLUSH,\n      windowBits: 'number' === typeof maxWindowBits ? maxWindowBits : DEFAULT_WINDOW_BITS,\n      memLevel: this._options.memLevel || DEFAULT_MEM_LEVEL\n    });\n  }\n\n  var self = this;\n  var buffers = [];\n\n  this._deflate.on('error', onError).on('data', onData);\n  this._deflate.write(data);\n  this._deflate.flush(function() {\n    cleanup();\n    var data = Buffer.concat(buffers);\n    if (fin) {\n      data = data.slice(0, data.length - 4);\n    }\n    callback(null, data);\n  });\n\n  function onError(err) {\n    cleanup();\n    callback(err);\n  }\n\n  function onData(data) {\n    buffers.push(data);\n  }\n\n  function cleanup() {\n    self._deflate.removeListener('error', onError);\n    self._deflate.removeListener('data', onData);\n    if (fin && self.params[endpoint + '_no_context_takeover']) {\n      self._deflate = null;\n    }\n  }\n};\n\nmodule.exports = PerMessageDeflate;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/PerMessageDeflate.js\n// module id = 6\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction convertInfoToInstance(info) {\r\n    if (typeof info !== \"object\") {\r\n        info = {};\r\n    }\r\n    return {\r\n        application: info.ApplicationName,\r\n        environment: info.Environment,\r\n        machine: info.MachineName,\r\n        pid: info.ProcessId,\r\n        region: info.Region,\r\n        service: info.ServiceName,\r\n        user: info.UserName,\r\n        started: info.ProcessStartTime,\r\n    };\r\n}\r\nexports.convertInfoToInstance = convertInfoToInstance;\r\nfunction isStreamingFlagSet(flags) {\r\n    if (typeof flags !== \"number\" || isNaN(flags)) {\r\n        return false;\r\n    }\r\n    var mask = 32;\r\n    var result = flags & mask;\r\n    return result === mask;\r\n}\r\nexports.isStreamingFlagSet = isStreamingFlagSet;\r\nfunction convertInstance(instance) {\r\n    return {\r\n        ApplicationName: instance.application,\r\n        ProcessId: instance.pid,\r\n        MachineName: instance.machine,\r\n        UserName: instance.user,\r\n        Environment: instance.environment,\r\n        Region: instance.region,\r\n    };\r\n}\r\nexports.convertInstance = convertInstance;\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/helpers.js\n// module id = 7\n// module chunks = 0","module.exports = require(\"events\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"events\"\n// module id = 8\n// module chunks = 0","'use strict';\nmodule.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/index.js\n// module id = 9\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1(promise, successCallback, errorCallback) {\r\n    if (typeof successCallback !== \"function\" && typeof errorCallback !== \"function\") {\r\n        return promise;\r\n    }\r\n    if (typeof successCallback !== \"function\") {\r\n        successCallback = function () { };\r\n    }\r\n    else if (typeof errorCallback !== \"function\") {\r\n        errorCallback = function () { };\r\n    }\r\n    promise.then(successCallback, errorCallback);\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=promisify.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/helpers/promisify.js\n// module id = 10\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerSubscription = (function () {\r\n    function ServerSubscription(protocol, repoMethod, subscription) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.subscription = subscription;\r\n    }\r\n    Object.defineProperty(ServerSubscription.prototype, \"stream\", {\r\n        get: function () { return this.repoMethod.stream; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"arguments\", {\r\n        get: function () { return this.subscription.arguments || {}; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"branchKey\", {\r\n        get: function () { return this.subscription.branchKey; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"instance\", {\r\n        get: function () { return this.subscription.instance; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerSubscription.prototype.close = function () {\r\n        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);\r\n    };\r\n    ServerSubscription.prototype.push = function (data) {\r\n        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);\r\n    };\r\n    return ServerSubscription;\r\n}());\r\nexports.default = ServerSubscription;\r\n//# sourceMappingURL=subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/subscription.js\n// module id = 11\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar msg = require(\"./bridges/gw3/gw3Messages\");\r\nexports.ContextMessageReplaySpec = {\r\n    get name() {\r\n        return \"context\";\r\n    },\r\n    get types() {\r\n        return [\r\n            msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY\r\n        ];\r\n    }\r\n};\r\n//# sourceMappingURL=contextMessageReplaySpec.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/contextMessageReplaySpec.js\n// module id = 12\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Utils = (function () {\r\n    function Utils() {\r\n    }\r\n    Utils.getGDMajorVersion = function () {\r\n        if (typeof window === \"undefined\") {\r\n            return -1;\r\n        }\r\n        if (!window.glueDesktop) {\r\n            return -1;\r\n        }\r\n        if (!window.glueDesktop.version) {\r\n            return -1;\r\n        }\r\n        var ver = Number(window.glueDesktop.version.substr(0, 1));\r\n        return isNaN(ver) ? -1 : ver;\r\n    };\r\n    Utils.isNode = function () {\r\n        try {\r\n            return Object.prototype.toString.call(global.process) === \"[object process]\";\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    };\r\n    return Utils;\r\n}());\r\nexports.default = Utils;\r\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/utils.js\n// module id = 13\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 14\n// module chunks = 0","module.exports = {\"name\":\"tick42-glue-core\",\"version\":\"4.3.7\",\"description\":\"Glue42 core library including logger, connection, agm and metrics\",\"main\":\"./dist/node/tick42-glue-core.js\",\"types\":\"./glue.d.ts\",\"browser\":\"./dist/web/tick42-glue-core.js\",\"scripts\":{\"init-dev-mode\":\"node ./build/scripts/init-dev-mode.js\",\"remove-installed-dependencies\":\"node ./build/scripts/remove-installed-dependencies.js\",\"clean\":\"node ./build/scripts/clean.js\",\"pre:build\":\"npm run clean && npm run tslint && tsc && set NODE_ENV=development\",\"file-versionify\":\"node ./build/scripts/file-versionify.js\",\"tslint\":\"tslint -t codeFrame ./src/**.ts\",\"tslint:fix\":\"tslint -t codeFrame --fix ./src/**.ts\",\"watch\":\"onchange ./src/**/*.ts -- npm run build:dev\",\"build:dev\":\"npm run pre:build && set NODE_ENV=development && webpack && npm run file-versionify\",\"build:prod\":\"npm run pre:build && set NODE_ENV=development && webpack && set NODE_ENV=production && webpack && npm run file-versionify\",\"docs\":\"typedoc --options typedoc.json ./src\",\"prepublish\":\"npm run build:prod && npm run test:only\",\"test\":\"npm run build:dev && npm run test:only\",\"test:only\":\"mocha ./tests/ --recursive\",\"test:core\":\"mocha ./tests/core\",\"test:agm\":\"mocha ./tests/agm\",\"test:bus\":\"mocha ./tests/bus\"},\"repository\":{\"type\":\"git\",\"url\":\"https://stash.tick42.com/scm/tg/js-glue-core.git\"},\"author\":{\"name\":\"Tick42\",\"url\":\"http://www.glue42.com\"},\"license\":\"ISC\",\"dependencies\":{\"callback-registry\":\"^2.4.0\",\"es6-promise\":\"^4.1.0\",\"shortid\":\"^2.2.6\",\"util-deprecate\":\"^1.0.2\",\"ws\":\"^0.7.2\"},\"devDependencies\":{\"@types/node\":\"^10.7.0\",\"@types/shortid\":\"0.0.29\",\"archiver\":\"^1.3.0\",\"babel-core\":\"^6.25.0\",\"babel-loader\":\"^6.4.1\",\"babel-plugin-add-module-exports\":\"^0.2.1\",\"babel-preset-es2015\":\"^6.16.0\",\"babel-preset-stage-2\":\"^6.22.0\",\"chai\":\"^4.0.2\",\"deep-equal\":\"^1.0.1\",\"mocha\":\"^2.5.3\",\"onchange\":\"3.*\",\"pre-commit\":\"^1.1.3\",\"readline-sync\":\"^1.4.5\",\"shelljs\":\"^0.6.0\",\"tick42-gateway\":\"0.2.7\",\"tick42-webpack-config\":\"4.1.6\",\"tslint\":\"^5.11.0\",\"typescript\":\"^3.0.1\",\"webpack\":\"2.3.3\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./package.json\n// module id = 15\n// module chunks = 0","/*!\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar fs = require('fs');\n\nfunction Options(defaults) {\n  var internalValues = {};\n  var values = this.value = {};\n  Object.keys(defaults).forEach(function(key) {\n    internalValues[key] = defaults[key];\n    Object.defineProperty(values, key, {\n      get: function() { return internalValues[key]; },\n      configurable: false,\n      enumerable: true\n    });\n  });\n  this.reset = function() {\n    Object.keys(defaults).forEach(function(key) {\n      internalValues[key] = defaults[key];\n    });\n    return this;\n  };\n  this.merge = function(options, required) {\n    options = options || {};\n    if (Object.prototype.toString.call(required) === '[object Array]') {\n      var missing = [];\n      for (var i = 0, l = required.length; i < l; ++i) {\n        var key = required[i];\n        if (!(key in options)) {\n          missing.push(key);\n        }\n      }\n      if (missing.length > 0) {\n        if (missing.length > 1) {\n          throw new Error('options ' +\n            missing.slice(0, missing.length - 1).join(', ') + ' and ' +\n            missing[missing.length - 1] + ' must be defined');\n        }\n        else throw new Error('option ' + missing[0] + ' must be defined');\n      }\n    }\n    Object.keys(options).forEach(function(key) {\n      if (key in internalValues) {\n        internalValues[key] = options[key];\n      }\n    });\n    return this;\n  };\n  this.copy = function(keys) {\n    var obj = {};\n    Object.keys(defaults).forEach(function(key) {\n      if (keys.indexOf(key) !== -1) {\n        obj[key] = values[key];\n      }\n    });\n    return obj;\n  };\n  this.read = function(filename, cb) {\n    if (typeof cb == 'function') {\n      var self = this;\n      fs.readFile(filename, function(error, data) {\n        if (error) return cb(error);\n        var conf = JSON.parse(data);\n        self.merge(conf);\n        cb();\n      });\n    }\n    else {\n      var conf = JSON.parse(fs.readFileSync(filename));\n      this.merge(conf);\n    }\n    return this;\n  };\n  this.isDefined = function(key) {\n    return typeof values[key] != 'undefined';\n  };\n  this.isDefinedAndNonNull = function(key) {\n    return typeof values[key] != 'undefined' && values[key] !== null;\n  };\n  Object.freeze(values);\n  Object.freeze(this);\n}\n\nmodule.exports = Options;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/options/lib/options.js\n// module id = 16\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = require('bufferutil');\n} catch (e) {\n  module.exports = require('./BufferUtil.fallback');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/BufferUtil.js\n// module id = 17\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports = {\n  isValidErrorCode: function(code) {\n    return (code >= 1000 && code <= 1011 && code != 1004 && code != 1005 && code != 1006) ||\n         (code >= 3000 && code <= 4999);\n  },\n  1000: 'normal',\n  1001: 'going away',\n  1002: 'protocol error',\n  1003: 'unsupported data',\n  1004: 'reserved',\n  1005: 'reserved for extensions',\n  1006: 'reserved for extensions',\n  1007: 'inconsistent or invalid data',\n  1008: 'policy violation',\n  1009: 'message too big',\n  1010: 'extension handshake missing',\n  1011: 'an unexpected condition prevented the request from being fulfilled',\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/ErrorCodes.js\n// module id = 18\n// module chunks = 0","\nvar util = require('util');\n\n/**\n * Module exports.\n */\n\nexports.parse = parse;\nexports.format = format;\n\n/**\n * Parse extensions header value\n */\n\nfunction parse(value) {\n  value = value || '';\n\n  var extensions = {};\n\n  value.split(',').forEach(function(v) {\n    var params = v.split(';');\n    var token = params.shift().trim();\n    var paramsList = extensions[token] = extensions[token] || [];\n    var parsedParams = {};\n\n    params.forEach(function(param) {\n      var parts = param.trim().split('=');\n      var key = parts[0];\n      var value = parts[1];\n      if (typeof value === 'undefined') {\n        value = true;\n      } else {\n        // unquote value\n        if (value[0] === '\"') {\n          value = value.slice(1);\n        }\n        if (value[value.length - 1] === '\"') {\n          value = value.slice(0, value.length - 1);\n        }\n      }\n      (parsedParams[key] = parsedParams[key] || []).push(value);\n    });\n\n    paramsList.push(parsedParams);\n  });\n\n  return extensions;\n}\n\n/**\n * Format extensions header value\n */\n\nfunction format(value) {\n  return Object.keys(value).map(function(token) {\n    var paramsList = value[token];\n    if (!util.isArray(paramsList)) {\n      paramsList = [paramsList];\n    }\n    return paramsList.map(function(params) {\n      return [token].concat(Object.keys(params).map(function(k) {\n        var p = params[k];\n        if (!util.isArray(p)) p = [p];\n        return p.map(function(v) {\n          return v === true ? k : k + '=' + v;\n        }).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Extensions.js\n// module id = 19\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util')\n  , Validation = require('./Validation').Validation\n  , ErrorCodes = require('./ErrorCodes')\n  , BufferPool = require('./BufferPool')\n  , bufferUtil = require('./BufferUtil').BufferUtil\n  , PerMessageDeflate = require('./PerMessageDeflate');\n\n/**\n * HyBi Receiver implementation\n */\n\nfunction Receiver (extensions) {\n  // memory pool for fragmented messages\n  var fragmentedPoolPrevUsed = -1;\n  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {\n    return db.used + length;\n  }, function(db) {\n    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed >= 0 ?\n      (fragmentedPoolPrevUsed + db.used) / 2 :\n      db.used;\n  });\n\n  // memory pool for unfragmented messages\n  var unfragmentedPoolPrevUsed = -1;\n  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {\n    return db.used + length;\n  }, function(db) {\n    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed >= 0 ?\n      (unfragmentedPoolPrevUsed + db.used) / 2 :\n      db.used;\n  });\n\n  this.extensions = extensions || {};\n  this.state = {\n    activeFragmentedOperation: null,\n    lastFragment: false,\n    masked: false,\n    opcode: 0,\n    fragmentedOperation: false\n  };\n  this.overflow = [];\n  this.headerBuffer = new Buffer(10);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.currentMessage = [];\n  this.messageHandlers = [];\n  this.expectHeader(2, this.processPacket);\n  this.dead = false;\n  this.processing = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  var dataLength = data.length;\n  if (dataLength == 0) return;\n  if (this.expectBuffer == null) {\n    this.overflow.push(data);\n    return;\n  }\n  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);\n  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);\n  this.expectOffset += toRead;\n  if (toRead < dataLength) {\n    this.overflow.push(data.slice(toRead));\n  }\n  while (this.expectBuffer && this.expectOffset == this.expectBuffer.length) {\n    var bufferForHandler = this.expectBuffer;\n    this.expectBuffer = null;\n    this.expectOffset = 0;\n    this.expectHandler.call(this, bufferForHandler);\n  }\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.overflow = null;\n  this.headerBuffer = null;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.unfragmentedBufferPool = null;\n  this.fragmentedBufferPool = null;\n  this.state = null;\n  this.currentMessage = null;\n  this.onerror = null;\n  this.ontext = null;\n  this.onbinary = null;\n  this.onclose = null;\n  this.onping = null;\n  this.onpong = null;\n};\n\n/**\n * Waits for a certain amount of header bytes to be available, then fires a callback.\n *\n * @api private\n */\n\nReceiver.prototype.expectHeader = function(length, handler) {\n  if (length == 0) {\n    handler(null);\n    return;\n  }\n  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);\n  this.expectHandler = handler;\n  var toRead = length;\n  while (toRead > 0 && this.overflow.length > 0) {\n    var fromOverflow = this.overflow.pop();\n    if (toRead < fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));\n    var read = Math.min(fromOverflow.length, toRead);\n    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\n    this.expectOffset += read;\n    toRead -= read;\n  }\n};\n\n/**\n * Waits for a certain amount of data bytes to be available, then fires a callback.\n *\n * @api private\n */\n\nReceiver.prototype.expectData = function(length, handler) {\n  if (length == 0) {\n    handler(null);\n    return;\n  }\n  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);\n  this.expectHandler = handler;\n  var toRead = length;\n  while (toRead > 0 && this.overflow.length > 0) {\n    var fromOverflow = this.overflow.pop();\n    if (toRead < fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));\n    var read = Math.min(fromOverflow.length, toRead);\n    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\n    this.expectOffset += read;\n    toRead -= read;\n  }\n};\n\n/**\n * Allocates memory from the buffer pool.\n *\n * @api private\n */\n\nReceiver.prototype.allocateFromPool = function(length, isFragmented) {\n  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);\n};\n\n/**\n * Start processing a new packet.\n *\n * @api private\n */\n\nReceiver.prototype.processPacket = function (data) {\n  if (this.extensions[PerMessageDeflate.extensionName]) {\n    if ((data[0] & 0x30) != 0) {\n      this.error('reserved fields (2, 3) must be empty', 1002);\n      return;\n    }\n  } else {\n    if ((data[0] & 0x70) != 0) {\n      this.error('reserved fields must be empty', 1002);\n      return;\n    }\n  }\n  this.state.lastFragment = (data[0] & 0x80) == 0x80;\n  this.state.masked = (data[1] & 0x80) == 0x80;\n  var compressed = (data[0] & 0x40) == 0x40;\n  var opcode = data[0] & 0xf;\n  if (opcode === 0) {\n    if (compressed) {\n      this.error('continuation frame cannot have the Per-message Compressed bits', 1002);\n      return;\n    }\n    // continuation frame\n    this.state.fragmentedOperation = true;\n    this.state.opcode = this.state.activeFragmentedOperation;\n    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {\n      this.error('continuation frame cannot follow current opcode', 1002);\n      return;\n    }\n  }\n  else {\n    if (opcode < 3 && this.state.activeFragmentedOperation != null) {\n      this.error('data frames after the initial data frame must have opcode 0', 1002);\n      return;\n    }\n    if (opcode >= 8 && compressed) {\n      this.error('control frames cannot have the Per-message Compressed bits', 1002);\n      return;\n    }\n    this.state.compressed = compressed;\n    this.state.opcode = opcode;\n    if (this.state.lastFragment === false) {\n      this.state.fragmentedOperation = true;\n      this.state.activeFragmentedOperation = opcode;\n    }\n    else this.state.fragmentedOperation = false;\n  }\n  var handler = opcodes[this.state.opcode];\n  if (typeof handler == 'undefined') this.error('no handler for opcode ' + this.state.opcode, 1002);\n  else {\n    handler.start.call(this, data);\n  }\n};\n\n/**\n * Endprocessing a packet.\n *\n * @api private\n */\n\nReceiver.prototype.endPacket = function() {\n  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);\n  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(false);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  if (this.state.lastFragment && this.state.opcode === this.state.activeFragmentedOperation) {\n    // end current fragmented operation\n    this.state.activeFragmentedOperation = null;\n  }\n  this.state.lastFragment = false;\n  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;\n  this.state.masked = false;\n  this.expectHeader(2, this.processPacket);\n};\n\n/**\n * Reset the parser state.\n *\n * @api private\n */\n\nReceiver.prototype.reset = function() {\n  if (this.dead) return;\n  this.state = {\n    activeFragmentedOperation: null,\n    lastFragment: false,\n    masked: false,\n    opcode: 0,\n    fragmentedOperation: false\n  };\n  this.fragmentedBufferPool.reset(true);\n  this.unfragmentedBufferPool.reset(true);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.overflow = [];\n  this.currentMessage = [];\n  this.messageHandlers = [];\n};\n\n/**\n * Unmask received data.\n *\n * @api private\n */\n\nReceiver.prototype.unmask = function (mask, buf, binary) {\n  if (mask != null && buf != null) bufferUtil.unmask(buf, mask);\n  if (binary) return buf;\n  return buf != null ? buf.toString('utf8') : '';\n};\n\n/**\n * Concatenates a list of buffers.\n *\n * @api private\n */\n\nReceiver.prototype.concatBuffers = function(buffers) {\n  var length = 0;\n  for (var i = 0, l = buffers.length; i < l; ++i) length += buffers[i].length;\n  var mergedBuffer = new Buffer(length);\n  bufferUtil.merge(mergedBuffer, buffers);\n  return mergedBuffer;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, protocolErrorCode) {\n  this.reset();\n  this.onerror(reason, protocolErrorCode);\n  return this;\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nReceiver.prototype.flush = function() {\n  if (this.processing || this.dead) return;\n\n  var handler = this.messageHandlers.shift();\n  if (!handler) return;\n\n  this.processing = true;\n  var self = this;\n\n  handler(function() {\n    self.processing = false;\n    self.flush();\n  });\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nReceiver.prototype.applyExtensions = function(messageBuffer, fin, compressed, callback) {\n  var self = this;\n  if (compressed) {\n    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {\n      if (self.dead) return;\n      if (err) {\n        callback(new Error('invalid compressed data'));\n        return;\n      }\n      callback(null, buffer);\n    });\n  } else {\n    callback(null, messageBuffer);\n  }\n};\n\n/**\n * Buffer utilities\n */\n\nfunction readUInt16BE(start) {\n  return (this[start]<<8) +\n         this[start+1];\n}\n\nfunction readUInt32BE(start) {\n  return (this[start]<<24) +\n         (this[start+1]<<16) +\n         (this[start+2]<<8) +\n         this[start+3];\n}\n\nfunction fastCopy(length, srcBuffer, dstBuffer, dstOffset) {\n  switch (length) {\n    default: srcBuffer.copy(dstBuffer, dstOffset, 0, length); break;\n    case 16: dstBuffer[dstOffset+15] = srcBuffer[15];\n    case 15: dstBuffer[dstOffset+14] = srcBuffer[14];\n    case 14: dstBuffer[dstOffset+13] = srcBuffer[13];\n    case 13: dstBuffer[dstOffset+12] = srcBuffer[12];\n    case 12: dstBuffer[dstOffset+11] = srcBuffer[11];\n    case 11: dstBuffer[dstOffset+10] = srcBuffer[10];\n    case 10: dstBuffer[dstOffset+9] = srcBuffer[9];\n    case 9: dstBuffer[dstOffset+8] = srcBuffer[8];\n    case 8: dstBuffer[dstOffset+7] = srcBuffer[7];\n    case 7: dstBuffer[dstOffset+6] = srcBuffer[6];\n    case 6: dstBuffer[dstOffset+5] = srcBuffer[5];\n    case 5: dstBuffer[dstOffset+4] = srcBuffer[4];\n    case 4: dstBuffer[dstOffset+3] = srcBuffer[3];\n    case 3: dstBuffer[dstOffset+2] = srcBuffer[2];\n    case 2: dstBuffer[dstOffset+1] = srcBuffer[1];\n    case 1: dstBuffer[dstOffset] = srcBuffer[0];\n  }\n}\n\nfunction clone(obj) {\n  var cloned = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      cloned[k] = obj[k];\n    }\n  }\n  return cloned;\n}\n\n/**\n * Opcode handlers\n */\n\nvar opcodes = {\n  // text\n  '1': {\n    start: function(data) {\n      var self = this;\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['1'].getData.call(self, firstLength);\n      }\n      else if (firstLength == 126) {\n        self.expectHeader(2, function(data) {\n          opcodes['1'].getData.call(self, readUInt16BE.call(data, 0));\n        });\n      }\n      else if (firstLength == 127) {\n        self.expectHeader(8, function(data) {\n          if (readUInt32BE.call(data, 0) != 0) {\n            self.error('packets with length spanning more than 32 bit is currently not supported', 1008);\n            return;\n          }\n          opcodes['1'].getData.call(self, readUInt32BE.call(data, 4));\n        });\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['1'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['1'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      var packet = this.unmask(mask, data, true) || new Buffer(0);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.applyExtensions(packet, state.lastFragment, state.compressed, function(err, buffer) {\n          if (err) return self.error(err.message, 1007);\n          if (buffer != null) self.currentMessage.push(buffer);\n\n          if (state.lastFragment) {\n            var messageBuffer = self.concatBuffers(self.currentMessage);\n            self.currentMessage = [];\n            if (!Validation.isValidUTF8(messageBuffer)) {\n              self.error('invalid utf8 sequence', 1007);\n              return;\n            }\n            self.ontext(messageBuffer.toString('utf8'), {masked: state.masked, buffer: messageBuffer});\n          }\n          callback();\n        });\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // binary\n  '2': {\n    start: function(data) {\n      var self = this;\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['2'].getData.call(self, firstLength);\n      }\n      else if (firstLength == 126) {\n        self.expectHeader(2, function(data) {\n          opcodes['2'].getData.call(self, readUInt16BE.call(data, 0));\n        });\n      }\n      else if (firstLength == 127) {\n        self.expectHeader(8, function(data) {\n          if (readUInt32BE.call(data, 0) != 0) {\n            self.error('packets with length spanning more than 32 bit is currently not supported', 1008);\n            return;\n          }\n          opcodes['2'].getData.call(self, readUInt32BE.call(data, 4, true));\n        });\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['2'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['2'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      var packet = this.unmask(mask, data, true) || new Buffer(0);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.applyExtensions(packet, state.lastFragment, state.compressed, function(err, buffer) {\n          if (err) return self.error(err.message, 1007);\n          if (buffer != null) self.currentMessage.push(buffer);\n          if (state.lastFragment) {\n            var messageBuffer = self.concatBuffers(self.currentMessage);\n            self.currentMessage = [];\n            self.onbinary(messageBuffer, {masked: state.masked, buffer: messageBuffer});\n          }\n          callback();\n        });\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // close\n  '8': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented close is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['8'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['8'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['8'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = self.unmask(mask, data, true);\n\n      var state = clone(this.state);\n      this.messageHandlers.push(function() {\n        if (data && data.length == 1) {\n          self.error('close packets with data must be at least two bytes long', 1002);\n          return;\n        }\n        var code = data && data.length > 1 ? readUInt16BE.call(data, 0) : 1000;\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          self.error('invalid error code', 1002);\n          return;\n        }\n        var message = '';\n        if (data && data.length > 2) {\n          var messageBuffer = data.slice(2);\n          if (!Validation.isValidUTF8(messageBuffer)) {\n            self.error('invalid utf8 sequence', 1007);\n            return;\n          }\n          message = messageBuffer.toString('utf8');\n        }\n        self.onclose(code, message, {masked: state.masked});\n        self.reset();\n      });\n      this.flush();\n    },\n  },\n  // ping\n  '9': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented ping is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['9'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['9'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['9'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = this.unmask(mask, data, true);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.onping(data, {masked: state.masked, binary: true});\n        callback();\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // pong\n  '10': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented pong is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['10'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (this.state.masked) {\n        this.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['10'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        this.expectData(length, function(data) {\n          opcodes['10'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = self.unmask(mask, data, true);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.onpong(data, {masked: state.masked, binary: true});\n        callback();\n      });\n      this.flush();\n      this.endPacket();\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Receiver.js\n// module id = 20\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = require('events')\n  , util = require('util')\n  , EventEmitter = events.EventEmitter\n  , ErrorCodes = require('./ErrorCodes')\n  , bufferUtil = require('./BufferUtil').BufferUtil\n  , PerMessageDeflate = require('./PerMessageDeflate');\n\n/**\n * HyBi Sender implementation\n */\n\nfunction Sender(socket, extensions) {\n  events.EventEmitter.call(this);\n\n  this._socket = socket;\n  this.extensions = extensions || {};\n  this.firstFragment = true;\n  this.compress = false;\n  this.messageHandlers = [];\n  this.processing = false;\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (typeof code !== 'undefined') {\n    if (typeof code !== 'number' ||\n      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');\n  }\n  code = code || 1000;\n  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));\n  writeUInt16BE.call(dataBuffer, code, 0);\n  if (dataBuffer.length > 2) dataBuffer.write(data, 2);\n\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0x8, dataBuffer, true, mask);\n    callback();\n    if (typeof cb == 'function') cb();\n  });\n  this.flush();\n};\n\n/**\n * Sends a ping message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0x9, data || '', true, mask);\n    callback();\n  });\n  this.flush();\n};\n\n/**\n * Sends a pong message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0xa, data || '', true, mask);\n    callback();\n  });\n  this.flush();\n};\n\n/**\n * Sends text or binary data to the remote party.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  var finalFragment = options && options.fin === false ? false : true;\n  var mask = options && options.mask;\n  var compress = options && options.compress;\n  var opcode = options && options.binary ? 2 : 1;\n  if (this.firstFragment === false) {\n    opcode = 0;\n    compress = false;\n  } else {\n    this.firstFragment = false;\n    this.compress = compress;\n  }\n  if (finalFragment) this.firstFragment = true\n\n  var compressFragment = this.compress;\n\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {\n      if (err) {\n        if (typeof cb == 'function') cb(err);\n        else self.emit('error', err);\n        return;\n      }\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      callback();\n    });\n  });\n  this.flush();\n};\n\n/**\n * Frames and sends a piece of data according to the HyBi WebSocket protocol.\n *\n * @api private\n */\n\nSender.prototype.frameAndSend = function(opcode, data, finalFragment, maskData, compressed, cb) {\n  var canModifyData = false;\n\n  if (!data) {\n    try {\n      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0, 0] : [])), 'binary', cb);\n    }\n    catch (e) {\n      if (typeof cb == 'function') cb(e);\n      else this.emit('error', e);\n    }\n    return;\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    canModifyData = true;\n    if (data && (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {\n      data = getArrayBuffer(data);\n    } else {\n      data = new Buffer(data);\n    }\n  }\n\n  var dataLength = data.length\n    , dataOffset = maskData ? 6 : 2\n    , secondByte = dataLength;\n\n  if (dataLength >= 65536) {\n    dataOffset += 8;\n    secondByte = 127;\n  }\n  else if (dataLength > 125) {\n    dataOffset += 2;\n    secondByte = 126;\n  }\n\n  var mergeBuffers = dataLength < 32768 || (maskData && !canModifyData);\n  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;\n  var outputBuffer = new Buffer(totalLength);\n  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;\n  if (compressed) outputBuffer[0] |= 0x40;\n\n  switch (secondByte) {\n    case 126:\n      writeUInt16BE.call(outputBuffer, dataLength, 2);\n      break;\n    case 127:\n      writeUInt32BE.call(outputBuffer, 0, 2);\n      writeUInt32BE.call(outputBuffer, dataLength, 6);\n  }\n\n  if (maskData) {\n    outputBuffer[1] = secondByte | 0x80;\n    var mask = this._randomMask || (this._randomMask = getRandomMask());\n    outputBuffer[dataOffset - 4] = mask[0];\n    outputBuffer[dataOffset - 3] = mask[1];\n    outputBuffer[dataOffset - 2] = mask[2];\n    outputBuffer[dataOffset - 1] = mask[3];\n    if (mergeBuffers) {\n      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      bufferUtil.mask(data, mask, data, 0, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n  else {\n    outputBuffer[1] = secondByte;\n    if (mergeBuffers) {\n      data.copy(outputBuffer, dataOffset);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nSender.prototype.flush = function() {\n  if (this.processing) return;\n\n  var handler = this.messageHandlers.shift();\n  if (!handler) return;\n\n  this.processing = true;\n\n  var self = this;\n\n  handler(function() {\n    self.processing = false;\n    self.flush();\n  });\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nSender.prototype.applyExtensions = function(data, fin, compress, callback) {\n  if (compress && data) {\n    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);\n  } else {\n    callback(null, data);\n  }\n};\n\nmodule.exports = Sender;\n\nfunction writeUInt16BE(value, offset) {\n  this[offset] = (value & 0xff00)>>8;\n  this[offset+1] = value & 0xff;\n}\n\nfunction writeUInt32BE(value, offset) {\n  this[offset] = (value & 0xff000000)>>24;\n  this[offset+1] = (value & 0xff0000)>>16;\n  this[offset+2] = (value & 0xff00)>>8;\n  this[offset+3] = value & 0xff;\n}\n\nfunction getArrayBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var array = new Uint8Array(data.buffer || data)\n    , l = data.byteLength || data.length\n    , o = data.byteOffset || 0\n    , buffer = new Buffer(l);\n  for (var i = 0; i < l; ++i) {\n    buffer[i] = array[o+i];\n  }\n  return buffer;\n}\n\nfunction getRandomMask() {\n  return new Buffer([\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255)\n  ]);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Sender.js\n// module id = 21\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar url = require('url')\n  , util = require('util')\n  , http = require('http')\n  , https = require('https')\n  , crypto = require('crypto')\n  , stream = require('stream')\n  , Ultron = require('ultron')\n  , Options = require('options')\n  , Sender = require('./Sender')\n  , Receiver = require('./Receiver')\n  , SenderHixie = require('./Sender.hixie')\n  , ReceiverHixie = require('./Receiver.hixie')\n  , Extensions = require('./Extensions')\n  , PerMessageDeflate = require('./PerMessageDeflate')\n  , EventEmitter = require('events').EventEmitter;\n\n/**\n * Constants\n */\n\n// Default protocol version\n\nvar protocolVersion = 13;\n\n// Close timeout\n\nvar closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly\n\n/**\n * WebSocket implementation\n *\n * @constructor\n * @param {String} address Connection address.\n * @param {String|Array} protocols WebSocket protocols.\n * @param {Object} options Additional connection options.\n * @api public\n */\nfunction WebSocket(address, protocols, options) {\n  EventEmitter.call(this);\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols;\n    protocols = null;\n  }\n\n  if ('string' === typeof protocols) {\n    protocols = [ protocols ];\n  }\n\n  if (!Array.isArray(protocols)) {\n    protocols = [];\n  }\n\n  this._socket = null;\n  this._ultron = null;\n  this._closeReceived = false;\n  this.bytesReceived = 0;\n  this.readyState = null;\n  this.supports = {};\n  this.extensions = {};\n\n  if (Array.isArray(address)) {\n    initAsServerClient.apply(this, address.concat(options));\n  } else {\n    initAsClient.apply(this, [address, protocols, options]);\n  }\n}\n\n/**\n * Inherits from EventEmitter.\n */\nutil.inherits(WebSocket, EventEmitter);\n\n/**\n * Ready States\n */\n[\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function each(state, index) {\n    WebSocket.prototype[state] = WebSocket[state] = index;\n});\n\n/**\n * Gracefully closes the connection, after sending a description message to the server\n *\n * @param {Object} data to be sent to the server\n * @api public\n */\nWebSocket.prototype.close = function close(code, data) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this.readyState === WebSocket.CONNECTING) {\n    this.readyState = WebSocket.CLOSED;\n    return;\n  }\n\n  if (this.readyState === WebSocket.CLOSING) {\n    if (this._closeReceived && this._isServer) {\n      this.terminate();\n    }\n    return;\n  }\n\n  var self = this;\n  try {\n    this.readyState = WebSocket.CLOSING;\n    this._closeCode = code;\n    this._closeMessage = data;\n    var mask = !this._isServer;\n    this._sender.close(code, data, mask, function(err) {\n      if (err) self.emit('error', err);\n\n      if (self._closeReceived && self._isServer) {\n        self.terminate();\n      } else {\n        // ensure that the connection is cleaned up even when no response of closing handshake.\n        clearTimeout(self._closeTimer);\n        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);\n      }\n    });\n  } catch (e) {\n    this.emit('error', e);\n  }\n};\n\n/**\n * Pause the client stream\n *\n * @api public\n */\nWebSocket.prototype.pause = function pauser() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n  return this._socket.pause();\n};\n\n/**\n * Sends a ping\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\nWebSocket.prototype.ping = function ping(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.ping(data, options);\n};\n\n/**\n * Sends a pong\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\nWebSocket.prototype.pong = function(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.pong(data, options);\n};\n\n/**\n * Resume the client stream\n *\n * @api public\n */\nWebSocket.prototype.resume = function resume() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n  return this._socket.resume();\n};\n\n/**\n * Sends a piece of data\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} Optional callback which is executed after the send completes\n * @api public\n */\n\nWebSocket.prototype.send = function send(data, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));\n    else throw new Error('not opened');\n    return;\n  }\n\n  if (!data) data = '';\n  if (this._queue) {\n    var self = this;\n    this._queue.push(function() { self.send(data, options, cb); });\n    return;\n  }\n\n  options = options || {};\n  options.fin = true;\n\n  if (typeof options.binary === 'undefined') {\n    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||\n      data instanceof Uint8Array ||\n      data instanceof Uint16Array ||\n      data instanceof Uint32Array ||\n      data instanceof Int8Array ||\n      data instanceof Int16Array ||\n      data instanceof Int32Array ||\n      data instanceof Float32Array ||\n      data instanceof Float64Array);\n  }\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  var readable = typeof stream.Readable === 'function'\n    ? stream.Readable\n    : stream.Stream;\n\n  if (data instanceof readable) {\n    startQueue(this);\n    var self = this;\n\n    sendStream(this, data, options, function send(error) {\n      process.nextTick(function tock() {\n        executeQueueSends(self);\n      });\n\n      if (typeof cb === 'function') cb(error);\n    });\n  } else {\n    this._sender.send(data, options, cb);\n  }\n};\n\n/**\n * Streams data through calls to a user supplied function\n *\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} 'function (error, send)' which is executed on successive ticks of which send is 'function (data, final)'.\n * @api public\n */\nWebSocket.prototype.stream = function stream(options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var self = this;\n\n  if (typeof cb !== 'function') throw new Error('callback must be provided');\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));\n    else throw new Error('not opened');\n    return;\n  }\n\n  if (this._queue) {\n    this._queue.push(function () { self.stream(options, cb); });\n    return;\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  startQueue(this);\n\n  function send(data, final) {\n    try {\n      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');\n      options.fin = final === true;\n      self._sender.send(data, options);\n      if (!final) process.nextTick(cb.bind(null, null, send));\n      else executeQueueSends(self);\n    } catch (e) {\n      if (typeof cb === 'function') cb(e);\n      else {\n        delete self._queue;\n        self.emit('error', e);\n      }\n    }\n  }\n\n  process.nextTick(cb.bind(null, null, send));\n};\n\n/**\n * Immediately shuts down the connection\n *\n * @api public\n */\nWebSocket.prototype.terminate = function terminate() {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this._socket) {\n    this.readyState = WebSocket.CLOSING;\n\n    // End the connection\n    try { this._socket.end(); }\n    catch (e) {\n      // Socket error during end() call, so just destroy it right now\n      cleanupWebsocketResources.call(this, true);\n      return;\n    }\n\n    // Add a timeout to ensure that the connection is completely\n    // cleaned up within 30 seconds, even if the clean close procedure\n    // fails for whatever reason\n    // First cleanup any pre-existing timeout from an earlier \"terminate\" call,\n    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts\n    // and hold the program open for `closeTimout` time.\n    if (this._closeTimer) { clearTimeout(this._closeTimer); }\n    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);\n  } else if (this.readyState === WebSocket.CONNECTING) {\n    cleanupWebsocketResources.call(this, true);\n  }\n};\n\n/**\n * Expose bufferedAmount\n *\n * @api public\n */\nObject.defineProperty(WebSocket.prototype, 'bufferedAmount', {\n  get: function get() {\n    var amount = 0;\n    if (this._socket) {\n      amount = this._socket.bufferSize || 0;\n    }\n    return amount;\n  }\n});\n\n/**\n * Emulates the W3C Browser based WebSocket interface using function members.\n *\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\n['open', 'error', 'close', 'message'].forEach(function(method) {\n  Object.defineProperty(WebSocket.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    get: function get() {\n      var listener = this.listeners(method)[0];\n      return listener ? (listener._listener ? listener._listener : listener) : undefined;\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    set: function set(listener) {\n      this.removeAllListeners(method);\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nWebSocket.prototype.addEventListener = function(method, listener) {\n  var target = this;\n\n  function onMessage (data, flags) {\n    listener.call(target, new MessageEvent(data, flags.binary ? 'Binary' : 'Text', target));\n  }\n\n  function onClose (code, message) {\n    listener.call(target, new CloseEvent(code, message, target));\n  }\n\n  function onError (event) {\n    event.target = target;\n    listener.call(target, event);\n  }\n\n  function onOpen () {\n    listener.call(target, new OpenEvent(target));\n  }\n\n  if (typeof listener === 'function') {\n    if (method === 'message') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  }\n};\n\nmodule.exports = WebSocket;\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction MessageEvent(dataArg, typeArg, target) {\n  this.data = dataArg;\n  this.type = typeArg;\n  this.target = target;\n}\n\n/**\n * W3C CloseEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction CloseEvent(code, reason, target) {\n  this.wasClean = (typeof code === 'undefined' || code === 1000);\n  this.code = code;\n  this.reason = reason;\n  this.target = target;\n}\n\n/**\n * W3C OpenEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction OpenEvent(target) {\n  this.target = target;\n}\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\nfunction initAsServerClient(req, socket, upgradeHead, options) {\n  options = new Options({\n    protocolVersion: protocolVersion,\n    protocol: null,\n    extensions: {}\n  }).merge(options);\n\n  // expose state properties\n  this.protocol = options.value.protocol;\n  this.protocolVersion = options.value.protocolVersion;\n  this.extensions = options.value.extensions;\n  this.supports.binary = (this.protocolVersion !== 'hixie-76');\n  this.upgradeReq = req;\n  this.readyState = WebSocket.CONNECTING;\n  this._isServer = true;\n\n  // establish connection\n  if (options.value.protocolVersion === 'hixie-76') {\n    establishConnection.call(this, ReceiverHixie, SenderHixie, socket, upgradeHead);\n  } else {\n    establishConnection.call(this, Receiver, Sender, socket, upgradeHead);\n  }\n}\n\nfunction initAsClient(address, protocols, options) {\n  options = new Options({\n    origin: null,\n    protocolVersion: protocolVersion,\n    host: null,\n    headers: null,\n    protocol: protocols.join(','),\n    agent: null,\n\n    // ssl-related options\n    pfx: null,\n    key: null,\n    passphrase: null,\n    cert: null,\n    ca: null,\n    ciphers: null,\n    rejectUnauthorized: null,\n    perMessageDeflate: true\n  }).merge(options);\n\n  if (options.value.protocolVersion !== 8 && options.value.protocolVersion !== 13) {\n    throw new Error('unsupported protocol version');\n  }\n\n  // verify URL and establish http class\n  var serverUrl = url.parse(address);\n  var isUnixSocket = serverUrl.protocol === 'ws+unix:';\n  if (!serverUrl.host && !isUnixSocket) throw new Error('invalid url');\n  var isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  var httpObj = isSecure ? https : http;\n  var port = serverUrl.port || (isSecure ? 443 : 80);\n  var auth = serverUrl.auth;\n\n  // prepare extensions\n  var extensionsOffer = {};\n  var perMessageDeflate;\n  if (options.value.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(typeof options.value.perMessageDeflate !== true ? options.value.perMessageDeflate : {}, false);\n    extensionsOffer[PerMessageDeflate.extensionName] = perMessageDeflate.offer();\n  }\n\n  // expose state properties\n  this._isServer = false;\n  this.url = address;\n  this.protocolVersion = options.value.protocolVersion;\n  this.supports.binary = (this.protocolVersion !== 'hixie-76');\n\n  // begin handshake\n  var key = new Buffer(options.value.protocolVersion + '-' + Date.now()).toString('base64');\n  var shasum = crypto.createHash('sha1');\n  shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  var expectedServerKey = shasum.digest('base64');\n\n  var agent = options.value.agent;\n\n  var headerHost = serverUrl.hostname;\n  // Append port number to Host header, only if specified in the url\n  // and non-default\n  if (serverUrl.port) {\n    if ((isSecure && (port !== 443)) || (!isSecure && (port !== 80))){\n      headerHost = headerHost + ':' + port;\n    }\n  }\n\n  var requestOptions = {\n    port: port,\n    host: serverUrl.hostname,\n    headers: {\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket',\n      'Host': headerHost,\n      'Sec-WebSocket-Version': options.value.protocolVersion,\n      'Sec-WebSocket-Key': key\n    }\n  };\n\n  // If we have basic auth.\n  if (auth) {\n    requestOptions.headers.Authorization = 'Basic ' + new Buffer(auth).toString('base64');\n  }\n\n  if (options.value.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.value.protocol;\n  }\n\n  if (options.value.host) {\n    requestOptions.headers.Host = options.value.host;\n  }\n\n  if (options.value.headers) {\n    for (var header in options.value.headers) {\n       if (options.value.headers.hasOwnProperty(header)) {\n        requestOptions.headers[header] = options.value.headers[header];\n       }\n    }\n  }\n\n  if (Object.keys(extensionsOffer).length) {\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format(extensionsOffer);\n  }\n\n  if (options.isDefinedAndNonNull('pfx')\n   || options.isDefinedAndNonNull('key')\n   || options.isDefinedAndNonNull('passphrase')\n   || options.isDefinedAndNonNull('cert')\n   || options.isDefinedAndNonNull('ca')\n   || options.isDefinedAndNonNull('ciphers')\n   || options.isDefinedAndNonNull('rejectUnauthorized')) {\n\n    if (options.isDefinedAndNonNull('pfx')) requestOptions.pfx = options.value.pfx;\n    if (options.isDefinedAndNonNull('key')) requestOptions.key = options.value.key;\n    if (options.isDefinedAndNonNull('passphrase')) requestOptions.passphrase = options.value.passphrase;\n    if (options.isDefinedAndNonNull('cert')) requestOptions.cert = options.value.cert;\n    if (options.isDefinedAndNonNull('ca')) requestOptions.ca = options.value.ca;\n    if (options.isDefinedAndNonNull('ciphers')) requestOptions.ciphers = options.value.ciphers;\n    if (options.isDefinedAndNonNull('rejectUnauthorized')) requestOptions.rejectUnauthorized = options.value.rejectUnauthorized;\n\n    if (!agent) {\n        // global agent ignores client side certificates\n        agent = new httpObj.Agent(requestOptions);\n    }\n  }\n\n  requestOptions.path = serverUrl.path || '/';\n\n  if (agent) {\n    requestOptions.agent = agent;\n  }\n\n  if (isUnixSocket) {\n    requestOptions.socketPath = serverUrl.pathname;\n  }\n  if (options.value.origin) {\n    if (options.value.protocolVersion < 13) requestOptions.headers['Sec-WebSocket-Origin'] = options.value.origin;\n    else requestOptions.headers.Origin = options.value.origin;\n  }\n\n  var self = this;\n  var req = httpObj.request(requestOptions);\n\n  req.on('error', function onerror(error) {\n    self.emit('error', error);\n    cleanupWebsocketResources.call(self, error);\n  });\n\n  req.once('response', function response(res) {\n    var error;\n\n    if (!self.emit('unexpected-response', req, res)) {\n      error = new Error('unexpected server response (' + res.statusCode + ')');\n      req.abort();\n      self.emit('error', error);\n    }\n\n    cleanupWebsocketResources.call(self, error);\n  });\n\n  req.once('upgrade', function upgrade(res, socket, upgradeHead) {\n    if (self.readyState === WebSocket.CLOSED) {\n      // client closed before server accepted connection\n      self.emit('close');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverKey = res.headers['sec-websocket-accept'];\n    if (typeof serverKey === 'undefined' || serverKey !== expectedServerKey) {\n      self.emit('error', 'invalid server key');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protList = (options.value.protocol || \"\").split(/, */);\n    var protError = null;\n\n    if (!options.value.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.value.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      self.emit('error', protError);\n      self.removeAllListeners();\n      socket.end();\n      return;\n    } else if (serverProt) {\n      self.protocol = serverProt;\n    }\n\n    var serverExtensions = Extensions.parse(res.headers['sec-websocket-extensions']);\n    if (perMessageDeflate && serverExtensions[PerMessageDeflate.extensionName]) {\n      try {\n        perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        self.emit('error', 'invalid extension parameter');\n        self.removeAllListeners();\n        socket.end();\n        return;\n      }\n      self.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    establishConnection.call(self, Receiver, Sender, socket, upgradeHead);\n\n    // perform cleanup on http resources\n    req.removeAllListeners();\n    req = null;\n    agent = null;\n  });\n\n  req.end();\n  this.readyState = WebSocket.CONNECTING;\n}\n\nfunction establishConnection(ReceiverClass, SenderClass, socket, upgradeHead) {\n  var ultron = this._ultron = new Ultron(socket);\n  this._socket = socket;\n\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  var self = this;\n  this._receiver = new ReceiverClass(this.extensions);\n\n  // socket cleanup handlers\n  ultron.on('end', cleanupWebsocketResources.bind(this));\n  ultron.on('close', cleanupWebsocketResources.bind(this));\n  ultron.on('error', cleanupWebsocketResources.bind(this));\n\n  // ensure that the upgradeHead is added to the receiver\n  function firstHandler(data) {\n    if (self.readyState !== WebSocket.OPEN && self.readyState !== WebSocket.CLOSING) return;\n\n    if (upgradeHead && upgradeHead.length > 0) {\n      self.bytesReceived += upgradeHead.length;\n      var head = upgradeHead;\n      upgradeHead = null;\n      self._receiver.add(head);\n    }\n\n    dataHandler = realHandler;\n\n    if (data) {\n      self.bytesReceived += data.length;\n      self._receiver.add(data);\n    }\n  }\n\n  // subsequent packets are pushed straight to the receiver\n  function realHandler(data) {\n    if (data) self.bytesReceived += data.length;\n    self._receiver.add(data);\n  }\n\n  var dataHandler = firstHandler;\n\n  // if data was passed along with the http upgrade,\n  // this will schedule a push of that on to the receiver.\n  // this has to be done on next tick, since the caller\n  // hasn't had a chance to set event handlers on this client\n  // object yet.\n  process.nextTick(firstHandler);\n\n  // receiver event handlers\n  self._receiver.ontext = function ontext(data, flags) {\n    flags = flags || {};\n\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onbinary = function onbinary(data, flags) {\n    flags = flags || {};\n\n    flags.binary = true;\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onping = function onping(data, flags) {\n    flags = flags || {};\n\n    self.pong(data, {\n      mask: !self._isServer,\n      binary: flags.binary === true\n    }, true);\n\n    self.emit('ping', data, flags);\n  };\n\n  self._receiver.onpong = function onpong(data, flags) {\n    self.emit('pong', data, flags || {});\n  };\n\n  self._receiver.onclose = function onclose(code, data, flags) {\n    flags = flags || {};\n\n    self._closeReceived = true;\n    self.close(code, data);\n  };\n\n  self._receiver.onerror = function onerror(reason, errorCode) {\n    // close the connection when the receiver reports a HyBi error code\n    self.close(typeof errorCode !== 'undefined' ? errorCode : 1002, '');\n    self.emit('error', reason, errorCode);\n  };\n\n  // finalize the client\n  this._sender = new SenderClass(socket, this.extensions);\n  this._sender.on('error', function onerror(error) {\n    self.close(1002, '');\n    self.emit('error', error);\n  });\n\n  this.readyState = WebSocket.OPEN;\n  this.emit('open');\n\n  ultron.on('data', dataHandler);\n}\n\nfunction startQueue(instance) {\n  instance._queue = instance._queue || [];\n}\n\nfunction executeQueueSends(instance) {\n  var queue = instance._queue;\n  if (typeof queue === 'undefined') return;\n\n  delete instance._queue;\n  for (var i = 0, l = queue.length; i < l; ++i) {\n    queue[i]();\n  }\n}\n\nfunction sendStream(instance, stream, options, cb) {\n  stream.on('data', function incoming(data) {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));\n      else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = false;\n    instance._sender.send(data, options);\n  });\n\n  stream.on('end', function end() {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));\n      else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = true;\n    instance._sender.send(null, options);\n\n    if (typeof cb === 'function') cb(null);\n  });\n}\n\nfunction cleanupWebsocketResources(error) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  var emitClose = this.readyState !== WebSocket.CONNECTING;\n  this.readyState = WebSocket.CLOSED;\n\n  clearTimeout(this._closeTimer);\n  this._closeTimer = null;\n\n  if (emitClose) {\n    this.emit('close', this._closeCode || 1000, this._closeMessage || '');\n  }\n\n  if (this._socket) {\n    if (this._ultron) this._ultron.destroy();\n    this._socket.on('error', function onerror() {\n      try { this.destroy(); }\n      catch (e) {}\n    });\n\n    try {\n      if (!error) this._socket.end();\n      else this._socket.destroy();\n    } catch (e) { /* Ignore termination errors */ }\n\n    this._socket = null;\n    this._ultron = null;\n  }\n\n  if (this._sender) {\n    this._sender.removeAllListeners();\n    this._sender = null;\n  }\n\n  if (this._receiver) {\n    this._receiver.cleanup();\n    this._receiver = null;\n  }\n\n  this.removeAllListeners();\n  this.on('error', function onerror() {}); // catch all errors after this\n  delete this._queue;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/WebSocket.js\n// module id = 22\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar ConnectionImpl = (function () {\r\n    function ConnectionImpl(settings) {\r\n        this.messageHandlers = {};\r\n        this.ids = 1;\r\n        this.registry = callback_registry_1.default();\r\n        this._connected = false;\r\n        this._settings = settings;\r\n        this._logger = settings.logger;\r\n    }\r\n    ConnectionImpl.prototype.init = function (transport, protocol) {\r\n        this._protocol = protocol;\r\n        this._transport = transport;\r\n        this._transport.onConnectedChanged(this.handleConnectionChanged.bind(this));\r\n        this._transport.onMessage(this.handleTransportMessage.bind(this));\r\n    };\r\n    ConnectionImpl.prototype.send = function (product, type, message, id, options) {\r\n        if (this._transport.isObjectBasedTransport) {\r\n            var msg = this._protocol.createObjectMessage(product, type, message, id);\r\n            return this._transport.sendObject(msg, product, type, options);\r\n        }\r\n        else {\r\n            var strMessage = this._protocol.createStringMessage(product, type, message, id);\r\n            return this._transport.send(strMessage, product, type, options);\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.on = function (product, type, messageHandler) {\r\n        type = type.toLowerCase();\r\n        if (this.messageHandlers[type] === undefined) {\r\n            this.messageHandlers[type] = {};\r\n        }\r\n        var id = this.ids++;\r\n        this.messageHandlers[type][id] = messageHandler;\r\n        return {\r\n            type: type,\r\n            id: id,\r\n        };\r\n    };\r\n    ConnectionImpl.prototype.off = function (info) {\r\n        delete this.messageHandlers[info.type.toLowerCase()][info.id];\r\n    };\r\n    Object.defineProperty(ConnectionImpl.prototype, \"isConnected\", {\r\n        get: function () {\r\n            return this._connected;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ConnectionImpl.prototype.connected = function (callback) {\r\n        if (this._connected) {\r\n            callback(this._settings.ws || this._settings.http);\r\n        }\r\n        return this.registry.add(\"connected\", callback);\r\n    };\r\n    ConnectionImpl.prototype.disconnected = function (callback) {\r\n        return this.registry.add(\"disconnected\", callback);\r\n    };\r\n    ConnectionImpl.prototype.login = function (authRequest) {\r\n        this._transport.open();\r\n        return this._protocol.login(authRequest);\r\n    };\r\n    ConnectionImpl.prototype.logout = function () {\r\n        this._protocol.logout();\r\n        this._transport.close();\r\n    };\r\n    ConnectionImpl.prototype.loggedIn = function (callback) {\r\n        return this._protocol.loggedIn(callback);\r\n    };\r\n    Object.defineProperty(ConnectionImpl.prototype, \"protocolVersion\", {\r\n        get: function () {\r\n            return this._settings.protocolVersion || 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ConnectionImpl.prototype.toAPI = function () {\r\n        var that = this;\r\n        return {\r\n            send: that.send.bind(that),\r\n            on: that.on.bind(that),\r\n            off: that.off.bind(that),\r\n            login: that.login.bind(that),\r\n            logout: that.logout.bind(that),\r\n            loggedIn: that.loggedIn.bind(that),\r\n            connected: that.connected.bind(that),\r\n            disconnected: that.disconnected.bind(that),\r\n            get protocolVersion() {\r\n                return that.protocolVersion;\r\n            }\r\n        };\r\n    };\r\n    ConnectionImpl.prototype.distributeMessage = function (message, type) {\r\n        var _this = this;\r\n        var handlers = this.messageHandlers[type.toLowerCase()];\r\n        if (handlers !== undefined) {\r\n            Object.keys(handlers).forEach(function (handlerId) {\r\n                var handler = handlers[handlerId];\r\n                if (handler !== undefined) {\r\n                    try {\r\n                        handler(message);\r\n                    }\r\n                    catch (error) {\r\n                        _this._logger.error(\"Message handler failed with \" + error.stack);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.handleConnectionChanged = function (connected) {\r\n        if (this._connected === connected) {\r\n            return;\r\n        }\r\n        this._connected = connected;\r\n        if (connected) {\r\n            this.registry.execute(\"connected\");\r\n        }\r\n        else {\r\n            this.registry.execute(\"disconnected\");\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.handleTransportMessage = function (msg) {\r\n        var msgObj;\r\n        if (typeof msg === \"string\") {\r\n            msgObj = this._protocol.processStringMessage(msg);\r\n        }\r\n        else {\r\n            msgObj = this._protocol.processObjectMessage(msg);\r\n        }\r\n        this.distributeMessage(msgObj.msg, msgObj.msgType);\r\n    };\r\n    return ConnectionImpl;\r\n}());\r\nexports.default = ConnectionImpl;\r\n//# sourceMappingURL=connection.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/connection.js\n// module id = 23\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GW_MESSAGE_CREATE_CONTEXT = \"create-context\";\r\nexports.GW_MESSAGE_ACTIVITY_CREATED = \"created\";\r\nexports.GW_MESSAGE_ACTIVITY_DESTROYED = \"destroyed\";\r\nexports.GW_MESSAGE_CONTEXT_CREATED = \"context-created\";\r\nexports.GW_MESSAGE_CONTEXT_ADDED = \"context-added\";\r\nexports.GW_MESSAGE_SUBSCRIBE_CONTEXT = \"subscribe-context\";\r\nexports.GW_MESSAGE_SUBSCRIBED_CONTEXT = \"subscribed-context\";\r\nexports.GW_MESSAGE_UNSUBSCRIBE_CONTEXT = \"unsubscribe-context\";\r\nexports.GW_MESSAGE_DESTROY_CONTEXT = \"destroy-context\";\r\nexports.GW_MESSAGE_CONTEXT_DESTROYED = \"context-destroyed\";\r\nexports.GW_MESSAGE_UPDATE_CONTEXT = \"update-context\";\r\nexports.GW_MESSAGE_CONTEXT_UPDATED = \"context-updated\";\r\nexports.GW_MESSAGE_JOINED_ACTIVITY = \"joined\";\r\n//# sourceMappingURL=gw3Messages.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/gw3/gw3Messages.js\n// module id = 24\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection = {\r\n    protocolVersion: -1,\r\n    send: function (product, type, message, id, options) {\r\n        return Promise.resolve(undefined);\r\n    },\r\n    on: function (product, type, messageHandler) {\r\n        return { type: \"1\", id: 1 };\r\n    },\r\n    off: function (info) {\r\n    },\r\n    login: function (message) {\r\n        return undefined;\r\n    },\r\n    logout: function () {\r\n    },\r\n    loggedIn: function (callback) {\r\n        return undefined;\r\n    },\r\n    connected: function (callback) {\r\n        return undefined;\r\n    },\r\n    disconnected: function (callback) {\r\n        return undefined;\r\n    },\r\n};\r\nexports.default = connection;\r\n//# sourceMappingURL=dummyConnection.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/dummyConnection.js\n// module id = 25\n// module chunks = 0","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 26\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 27\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar main_1 = require(\"./metrics/main\");\r\nvar main_2 = require(\"./connection/main\");\r\nvar main_3 = require(\"./logger/main\");\r\nvar main_4 = require(\"./agm/main\");\r\nvar main_5 = require(\"./bus/main\");\r\nvar config_1 = require(\"./config\");\r\nvar dummyConnection_1 = require(\"./dummyConnection\");\r\nvar timer_1 = require(\"./timer\");\r\nvar utils_1 = require(\"./utils\");\r\nvar dummyConnection_2 = require(\"./dummyConnection\");\r\nvar main_6 = require(\"./contexts/main\");\r\nvar contextMessageReplaySpec_1 = require(\"./contexts/contextMessageReplaySpec\");\r\nvar GlueCore = function (userConfig, ext) {\r\n    var gdVersion = -1;\r\n    var hc;\r\n    var glue42gd;\r\n    if (typeof window !== \"undefined\") {\r\n        gdVersion = utils_1.default.getGDMajorVersion();\r\n        if (gdVersion === 2) {\r\n            hc = window.htmlContainer;\r\n        }\r\n        else if (gdVersion >= 3) {\r\n            glue42gd = window.glue42gd;\r\n        }\r\n    }\r\n    var glueInitTimer = timer_1.default();\r\n    userConfig = userConfig || {};\r\n    ext = ext || {};\r\n    var internalConfig = config_1.default(userConfig, ext, hc, glue42gd, gdVersion);\r\n    var _connection;\r\n    var _agm;\r\n    var _logger;\r\n    var _rootMetrics;\r\n    var _metrics;\r\n    var _contexts;\r\n    var _bus;\r\n    var libs = {};\r\n    function registerLib(name, inner, t) {\r\n        inner.initStartTime = t.startTime;\r\n        if (inner.ready) {\r\n            inner.ready().then(function () {\r\n                inner.initTime = t.stop();\r\n                inner.initEndTime = t.endTime;\r\n            });\r\n        }\r\n        else {\r\n            inner.initTime = t.stop();\r\n            inner.initEndTime = t.endTime;\r\n        }\r\n        libs[name] = inner;\r\n        GlueCore[name] = inner;\r\n    }\r\n    function setupConnection() {\r\n        var initTimer = timer_1.default();\r\n        internalConfig.connection.logger = _logger.subLogger(\"connection\");\r\n        _connection = main_2.default(internalConfig.connection);\r\n        var authPromise = Promise.resolve(internalConfig.auth);\r\n        if (internalConfig.connection && !internalConfig.auth) {\r\n            var protocolVersion = internalConfig.connection.protocolVersion;\r\n            if (!protocolVersion || protocolVersion === 1) {\r\n                registerLib(\"connection\", _connection, initTimer);\r\n                return Promise.resolve({});\r\n            }\r\n            if (protocolVersion === 2) {\r\n                return Promise.reject(\"You need to provide auth information\");\r\n            }\r\n            if (protocolVersion === 3) {\r\n                if (glue42gd) {\r\n                    authPromise = glue42gd.getGWToken().then(function (token) {\r\n                        return {\r\n                            gatewayToken: token\r\n                        };\r\n                    });\r\n                }\r\n                else {\r\n                    authPromise = Promise.reject(\"You need to provide auth information\");\r\n                }\r\n            }\r\n        }\r\n        return authPromise\r\n            .then(function (authConfig) {\r\n            var authRequest;\r\n            if (typeof authConfig === \"string\" || typeof authConfig === \"number\") {\r\n                authRequest = {\r\n                    token: authConfig\r\n                };\r\n            }\r\n            else if (Object.prototype.toString.call(authConfig) === \"[object Object]\") {\r\n                authRequest = authConfig;\r\n            }\r\n            else {\r\n                throw new Error(\"Invalid auth object - \" + JSON.stringify(authConfig));\r\n            }\r\n            return authRequest;\r\n        })\r\n            .then(function (authRequest) {\r\n            return _connection.login(authRequest);\r\n        })\r\n            .then(function (identity) {\r\n            if (identity) {\r\n                if (identity.machine) {\r\n                    internalConfig.agm.instance.machine = identity.machine;\r\n                }\r\n                if (identity.user) {\r\n                    internalConfig.agm.instance.user = identity.user;\r\n                }\r\n            }\r\n            registerLib(\"connection\", _connection, initTimer);\r\n            return internalConfig;\r\n        })\r\n            .catch(function (e) {\r\n            if (_connection) {\r\n                _connection.logout();\r\n            }\r\n            throw e;\r\n        });\r\n    }\r\n    function setupLogger() {\r\n        var initTimer = timer_1.default();\r\n        var loggerConfig = {\r\n            identity: internalConfig.identity,\r\n            getConnection: function () {\r\n                return _connection || dummyConnection_1.default;\r\n            },\r\n            publish: internalConfig.logger.publish || \"off\",\r\n            console: internalConfig.logger.console || \"info\",\r\n            metrics: (internalConfig.metrics && internalConfig.logger.metrics) || \"off\"\r\n        };\r\n        _logger = main_3.default(loggerConfig);\r\n        registerLib(\"logger\", _logger, initTimer);\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupMetrics() {\r\n        if (internalConfig.metrics) {\r\n            var initTimer = timer_1.default();\r\n            _rootMetrics = main_1.default({\r\n                identity: internalConfig.metrics.identity,\r\n                connection: internalConfig.metrics ? _connection : dummyConnection_1.default,\r\n                logger: _logger.subLogger(\"metrics\")\r\n            });\r\n            _metrics = _rootMetrics.subSystem(\"App\");\r\n            var reportingSystem_1 = _metrics.subSystem(\"reporting\");\r\n            var def_1 = {\r\n                name: \"features\",\r\n                conflation: 1,\r\n            };\r\n            var _featureMetric_1;\r\n            _metrics.featureMetric = function (name, action, payload) {\r\n                if (typeof name === \"undefined\" || name === \"\") {\r\n                    throw new Error(\"name is mandatory\");\r\n                }\r\n                else if (typeof action === \"undefined\" || action === \"\") {\r\n                    throw new Error(\"action is mandatory\");\r\n                }\r\n                else if (typeof payload === \"undefined\" || payload === \"\") {\r\n                    throw new Error(\"payload is mandatory\");\r\n                }\r\n                if (!_featureMetric_1) {\r\n                    _featureMetric_1 = reportingSystem_1.objectMetric(def_1, { name: name, action: action, payload: payload });\r\n                }\r\n                else {\r\n                    _featureMetric_1.update({\r\n                        name: name,\r\n                        action: action,\r\n                        payload: payload\r\n                    });\r\n                }\r\n            };\r\n            _logger.metricsLevel(\"warn\", _metrics.parent.subSystem(\"LogEvents\"));\r\n            registerLib(\"metrics\", _metrics, initTimer);\r\n        }\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupAGM() {\r\n        var initTimer = timer_1.default();\r\n        var agmConfig = {\r\n            instance: internalConfig.agm.instance,\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"agm\"),\r\n            forceGW: internalConfig.connection && internalConfig.connection.force,\r\n            gdVersion: gdVersion,\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            main_4.default(agmConfig)\r\n                .then(function (agmLib) {\r\n                _agm = agmLib;\r\n                registerLib(\"agm\", _agm, initTimer);\r\n                resolve(internalConfig);\r\n            })\r\n                .catch(function (err) {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    function setupContexts() {\r\n        var hasActivities = (internalConfig.activities && dummyConnection_2.default.protocolVersion === 3);\r\n        var needsContexts = internalConfig.contexts || hasActivities;\r\n        if (needsContexts) {\r\n            var initTimer = timer_1.default();\r\n            _contexts = new main_6.ContextsModule({\r\n                connection: _connection,\r\n                logger: _logger.subLogger(\"contexts\"),\r\n                gdMajorVersion: gdVersion\r\n            });\r\n            registerLib(\"contexts\", _contexts, initTimer);\r\n            return _contexts;\r\n        }\r\n        else {\r\n            var replayer = dummyConnection_2.default.replayer;\r\n            if (replayer) {\r\n                replayer.drain(contextMessageReplaySpec_1.ContextMessageReplaySpec.name, null);\r\n            }\r\n        }\r\n    }\r\n    function setupExternalLibs(externalLibs) {\r\n        try {\r\n            externalLibs.forEach(function (lib) {\r\n                setupExternalLib(lib.name, lib.create);\r\n            });\r\n            return Promise.resolve();\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    function setupExternalLib(name, createCallback) {\r\n        var initTimer = timer_1.default();\r\n        var lib = createCallback(libs);\r\n        if (lib) {\r\n            registerLib(name, lib, initTimer);\r\n        }\r\n    }\r\n    function waitForLibs() {\r\n        var libsReadyPromises = Object.keys(libs).map(function (key) {\r\n            var lib = libs[key];\r\n            return lib.ready ?\r\n                lib.ready() : Promise.resolve();\r\n        });\r\n        return Promise.all(libsReadyPromises);\r\n    }\r\n    function constructGlueObject() {\r\n        var feedbackFunc = function () {\r\n            if (!_agm) {\r\n                return;\r\n            }\r\n            _agm.invoke(\"T42.ACS.Feedback\", {}, \"best\");\r\n        };\r\n        var info = { glueVersion: internalConfig.version };\r\n        glueInitTimer.stop();\r\n        var glue = {\r\n            feedback: feedbackFunc,\r\n            info: info,\r\n            version: internalConfig.version,\r\n            userConfig: userConfig,\r\n            done: function () {\r\n                _connection.logout();\r\n                return Promise.resolve();\r\n            }\r\n        };\r\n        glue.performance = {\r\n            get browser() {\r\n                return window.performance.timing.toJSON();\r\n            },\r\n            get memory() {\r\n                return window.performance.memory;\r\n            },\r\n            get initTimes() {\r\n                var result = Object.keys(glue)\r\n                    .filter(function (key) {\r\n                    if (key === \"initTimes\") {\r\n                        return false;\r\n                    }\r\n                    return glue[key].initTime;\r\n                })\r\n                    .map(function (key) {\r\n                    return {\r\n                        name: key,\r\n                        time: glue[key].initTime,\r\n                        startTime: glue[key].initStartTime,\r\n                        endTime: glue[key].initEndTime\r\n                    };\r\n                });\r\n                result.push({\r\n                    name: \"glue\",\r\n                    startTime: glueInitTimer.startTime,\r\n                    endTime: glueInitTimer.endTime,\r\n                    time: glueInitTimer.period\r\n                });\r\n                return result;\r\n            }\r\n        };\r\n        Object.keys(libs).forEach(function (key) {\r\n            var lib = libs[key];\r\n            glue[key] = lib;\r\n            info[key] = lib.version;\r\n        });\r\n        if (hc && hc.perfDataNeeded && hc.updatePerfData) {\r\n            var delay = hc.perfDataDelay || 100;\r\n            setTimeout(function () {\r\n                hc.updatePerfData(glue.performance);\r\n            }, delay);\r\n        }\r\n        if (glue42gd && glue42gd.updatePerfData) {\r\n            glue42gd.updatePerfData(glue.performance);\r\n        }\r\n        glue.config = {};\r\n        if (ext.enrichGlue) {\r\n            ext.enrichGlue(glue);\r\n        }\r\n        Object.keys(internalConfig).forEach(function (k) {\r\n            glue.config[k] = internalConfig[k];\r\n        });\r\n        if (ext.extOptions) {\r\n            Object.keys(ext.extOptions).forEach(function (k) {\r\n                glue.config[k] = ext.extOptions[k];\r\n            });\r\n        }\r\n        return glue;\r\n    }\r\n    function setupBus() {\r\n        if (!internalConfig.bus) {\r\n            return Promise.resolve(undefined);\r\n        }\r\n        var initTimer = timer_1.default();\r\n        var busSettings = {\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"bus\")\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            main_5.default(busSettings)\r\n                .then(function (busLib) {\r\n                _bus = busLib;\r\n                registerLib(\"bus\", _bus, initTimer);\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    return setupLogger()\r\n        .then(setupConnection)\r\n        .then(function () { return Promise.all([setupMetrics(), setupAGM(), setupContexts(), setupBus()]); })\r\n        .then(function () {\r\n        return setupExternalLibs(internalConfig.libs || []);\r\n    })\r\n        .then(waitForLibs)\r\n        .then(constructGlueObject)\r\n        .catch(function (err) {\r\n        return Promise.reject({\r\n            err: err,\r\n            libs: libs\r\n        });\r\n    });\r\n};\r\nexports.default = GlueCore;\r\n//# sourceMappingURL=glue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/glue.js\n// module id = 28\n// module chunks = 0","/**\n * Secure random string generator with custom alphabet.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * @param {generator} random The random bytes generator.\n * @param {string} alphabet Symbols to be used in new random string.\n * @param {size} size The number of symbols in new random string.\n *\n * @return {string} Random string.\n *\n * @example\n * const format = require('nanoid/format')\n *\n * function random (size) {\n *   const result = []\n *   for (let i = 0; i < size; i++) {\n *     result.push(randomByte())\n *   }\n *   return result\n * }\n *\n * format(random, \"abcdef\", 5) //=> \"fbaef\"\n *\n * @name format\n * @function\n */\nmodule.exports = function (random, alphabet, size) {\n  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1\n  var step = Math.ceil(1.6 * mask * size / alphabet.length)\n\n  var id = ''\n  while (true) {\n    var bytes = random(step)\n    for (var i = 0; i < step; i++) {\n      var byte = bytes[i] & mask\n      if (alphabet[byte]) {\n        id += alphabet[byte]\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\n/**\n * @callback generator\n * @param {number} bytes The number of bytes to generate.\n * @return {number[]} Random bytes.\n */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nanoid/format.js\n// module id = 29\n// module chunks = 0","var crypto = require('crypto')\n\nif (crypto.randomFillSync) {\n  var buffers = { }\n  module.exports = function (bytes) {\n    var buffer = buffers[bytes]\n    if (!buffer) {\n      buffer = Buffer.allocUnsafe(bytes)\n      if (bytes <= 255) buffers[bytes] = buffer\n    }\n    return crypto.randomFillSync(buffer)\n  }\n} else {\n  module.exports = crypto.randomBytes\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nanoid/random.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nvar generate = require('./generate');\nvar alphabet = require('./alphabet');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction build(clusterWorkerId) {\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + generate(version);\n    str = str + generate(clusterWorkerId);\n    if (counter > 0) {\n        str = str + generate(counter);\n    }\n    str = str + generate(seconds);\n    return str;\n}\n\nmodule.exports = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/build.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nvar alphabet = require('./alphabet');\nvar random = require('./random/random-byte');\nvar format = require('nanoid/format');\n\nfunction generate(number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + format(random, alphabet.get(), 1);\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = generate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/generate.js\n// module id = 32\n// module chunks = 0","'use strict';\n\nvar alphabet = require('./alphabet');\nvar build = require('./build');\nvar isValid = require('./is-valid');\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n  return build(clusterWorkerId);\n}\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.isValid = isValid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/index.js\n// module id = 33\n// module chunks = 0","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var nonAlphabetic = new RegExp('[^' +\n      alphabet.get().replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&') +\n    ']');\n    return !nonAlphabetic.test(id);\n}\n\nmodule.exports = isShortId;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/is-valid.js\n// module id = 34\n// module chunks = 0","module.exports = require('nanoid/random');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/random/random-byte.js\n// module id = 35\n// module chunks = 0","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/random/random-from-seed.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nvar cluster = require('cluster');\n\nvar clusterId = 0;\nif (!cluster.isMaster && cluster.worker) {\n    clusterId = cluster.worker.id;\n}\nmodule.exports = parseInt(process.env.NODE_UNIQUE_ID || clusterId, 10);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/util/cluster-worker-id.js\n// module id = 37\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments\n    , event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    args = [];\n\n    for (event in this.ee._events) {\n      if (has.call(this.ee._events, event)) args.push(event);\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = this.ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n        delete event.listener.__ultron;\n      } else {\n        if (event.__ultron !== this.id) continue;\n        delete event.__ultron;\n      }\n\n      this.ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n\n  this.remove();\n  this.ee = null;\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ultron/index.js\n// module id = 38\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar WS = module.exports = require('./lib/WebSocket');\n\nWS.Server = require('./lib/WebSocketServer');\nWS.Sender = require('./lib/Sender');\nWS.Receiver = require('./lib/Receiver');\n\n/**\n * Create a new WebSocket server.\n *\n * @param {Object} options Server options\n * @param {Function} fn Optional connection listener.\n * @returns {WS.Server}\n * @api public\n */\nWS.createServer = function createServer(options, fn) {\n  var server = new WS.Server(options);\n\n  if (typeof fn === 'function') {\n    server.on('connection', fn);\n  }\n\n  return server;\n};\n\n/**\n * Create a new WebSocket connection.\n *\n * @param {String} address The URL/address we need to connect to.\n * @param {Function} fn Open listener.\n * @returns {WS}\n * @api public\n */\nWS.connect = WS.createConnection = function connect(address, fn) {\n  var client = new WS(address);\n\n  if (typeof fn === 'function') {\n    client.on('open', fn);\n  }\n\n  return client;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/index.js\n// module id = 39\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util');\n\nfunction BufferPool(initialSize, growStrategy, shrinkStrategy) {\n  if (typeof initialSize === 'function') {\n    shrinkStrategy = growStrategy;\n    growStrategy = initialSize;\n    initialSize = 0;\n  }\n  else if (typeof initialSize === 'undefined') {\n    initialSize = 0;\n  }\n  this._growStrategy = (growStrategy || function(db, size) {\n    return db.used + size;\n  }).bind(null, this);\n  this._shrinkStrategy = (shrinkStrategy || function(db) {\n    return initialSize;\n  }).bind(null, this);\n  this._buffer = initialSize ? new Buffer(initialSize) : null;\n  this._offset = 0;\n  this._used = 0;\n  this._changeFactor = 0;\n  this.__defineGetter__('size', function(){\n    return this._buffer == null ? 0 : this._buffer.length;\n  });\n  this.__defineGetter__('used', function(){\n    return this._used;\n  });\n}\n\nBufferPool.prototype.get = function(length) {\n  if (this._buffer == null || this._offset + length > this._buffer.length) {\n    var newBuf = new Buffer(this._growStrategy(length));\n    this._buffer = newBuf;\n    this._offset = 0;\n  }\n  this._used += length;\n  var buf = this._buffer.slice(this._offset, this._offset + length);\n  this._offset += length;\n  return buf;\n}\n\nBufferPool.prototype.reset = function(forceNewBuffer) {\n  var len = this._shrinkStrategy();\n  if (len < this.size) this._changeFactor -= 1;\n  if (forceNewBuffer || this._changeFactor < -2) {\n    this._changeFactor = 0;\n    this._buffer = len ? new Buffer(len) : null;\n  }\n  this._offset = 0;\n  this._used = 0;\n}\n\nmodule.exports = BufferPool;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/BufferPool.js\n// module id = 40\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports.BufferUtil = {\n  merge: function(mergedBuffer, buffers) {\n    var offset = 0;\n    for (var i = 0, l = buffers.length; i < l; ++i) {\n      var buf = buffers[i];\n      buf.copy(mergedBuffer, offset);\n      offset += buf.length;\n    }\n  },\n  mask: function(source, mask, output, offset, length) {\n    var maskNum = mask.readUInt32LE(0, true);\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ source.readUInt32LE(i, true);\n      if (num < 0) num = 4294967296 + num;\n      output.writeUInt32LE(num, offset + i, true);\n    }\n    switch (length % 4) {\n      case 3: output[offset + i + 2] = source[i + 2] ^ mask[2];\n      case 2: output[offset + i + 1] = source[i + 1] ^ mask[1];\n      case 1: output[offset + i] = source[i] ^ mask[0];\n      case 0:;\n    }\n  },\n  unmask: function(data, mask) {\n    var maskNum = mask.readUInt32LE(0, true);\n    var length = data.length;\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ data.readUInt32LE(i, true);\n      if (num < 0) num = 4294967296 + num;\n      data.writeUInt32LE(num, i, true);\n    }\n    switch (length % 4) {\n      case 3: data[i + 2] = data[i + 2] ^ mask[2];\n      case 2: data[i + 1] = data[i + 1] ^ mask[1];\n      case 1: data[i] = data[i] ^ mask[0];\n      case 0:;\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/BufferUtil.fallback.js\n// module id = 41\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util');\n\n/**\n * State constants\n */\n\nvar EMPTY = 0\n  , BODY = 1;\nvar BINARYLENGTH = 2\n  , BINARYBODY = 3;\n\n/**\n * Hixie Receiver implementation\n */\n\nfunction Receiver () {\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n  this.dead = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  var self = this;\n  function doAdd() {\n    if (self.state === EMPTY) {\n      if (data.length == 2 && data[0] == 0xFF && data[1] == 0x00) {\n        self.reset();\n        self.onclose();\n        return;\n      }\n      if (data[0] === 0x80) {\n        self.messageEnd = 0;\n        self.state = BINARYLENGTH;\n        data = data.slice(1);\n      } else {\n\n      if (data[0] !== 0x00) {\n        self.error('payload must start with 0x00 byte', true);\n        return;\n      }\n      data = data.slice(1);\n      self.state = BODY;\n\n      }\n    }\n    if (self.state === BINARYLENGTH) {\n      var i = 0;\n      while ((i < data.length) && (data[i] & 0x80)) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        ++i;\n      }\n      if (i < data.length) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        self.state = BINARYBODY;\n        ++i;\n      }\n      if (i > 0)\n        data = data.slice(i);\n    }\n    if (self.state === BINARYBODY) {\n      var dataleft = self.messageEnd - self.spanLength;\n      if (data.length >= dataleft) {\n        // consume the whole buffer to finish the frame\n        self.buffers.push(data);\n        self.spanLength += dataleft;\n        self.messageEnd = dataleft;\n        return self.parse();\n      }\n      // frame's not done even if we consume it all\n      self.buffers.push(data);\n      self.spanLength += data.length;\n      return;\n    }\n    self.buffers.push(data);\n    if ((self.messageEnd = bufferIndex(data, 0xFF)) != -1) {\n      self.spanLength += self.messageEnd;\n      return self.parse();\n    }\n    else self.spanLength += data.length;\n  }\n  while(data) data = doAdd();\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.state = EMPTY;\n  this.buffers = [];\n};\n\n/**\n * Process buffered data.\n *\n * @api public\n */\n\nReceiver.prototype.parse = function() {\n  var output = new Buffer(this.spanLength);\n  var outputIndex = 0;\n  for (var bi = 0, bl = this.buffers.length; bi < bl - 1; ++bi) {\n    var buffer = this.buffers[bi];\n    buffer.copy(output, outputIndex);\n    outputIndex += buffer.length;\n  }\n  var lastBuffer = this.buffers[this.buffers.length - 1];\n  if (this.messageEnd > 0) lastBuffer.copy(output, outputIndex, 0, this.messageEnd);\n  if (this.state !== BODY) --this.messageEnd;\n  var tail = null;\n  if (this.messageEnd < lastBuffer.length - 1) {\n    tail = lastBuffer.slice(this.messageEnd + 1);\n  }\n  this.reset();\n  this.ontext(output.toString('utf8'));\n  return tail;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, terminate) {\n  this.reset();\n  this.onerror(reason, terminate);\n  return this;\n};\n\n/**\n * Reset parser state\n *\n * @api private\n */\n\nReceiver.prototype.reset = function (reason) {\n  if (this.dead) return;\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n};\n\n/**\n * Internal api\n */\n\nfunction bufferIndex(buffer, byte) {\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    if (buffer[i] === byte) return i;\n  }\n  return -1;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Receiver.hixie.js\n// module id = 42\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = require('events')\n  , util = require('util')\n  , EventEmitter = events.EventEmitter;\n\n/**\n * Hixie Sender implementation\n */\n\nfunction Sender(socket) {\n  events.EventEmitter.call(this);\n\n  this.socket = socket;\n  this.continuationFrame = false;\n  this.isClosed = false;\n}\n\nmodule.exports = Sender;\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Frames and writes data.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  if (this.isClosed) return;\n\n  var isString = typeof data == 'string'\n    , length = isString ? Buffer.byteLength(data) : data.length\n    , lengthbytes = (length > 127) ? 2 : 1 // assume less than 2**14 bytes\n    , writeStartMarker = this.continuationFrame == false\n    , writeEndMarker = !options || !(typeof options.fin != 'undefined' && !options.fin)\n    , buffer = new Buffer((writeStartMarker ? ((options && options.binary) ? (1 + lengthbytes) : 1) : 0) + length + ((writeEndMarker && !(options && options.binary)) ? 1 : 0))\n    , offset = writeStartMarker ? 1 : 0;\n\n  if (writeStartMarker) {\n    if (options && options.binary) {\n      buffer.write('\\x80', 'binary');\n      // assume length less than 2**14 bytes\n      if (lengthbytes > 1)\n        buffer.write(String.fromCharCode(128+length/128), offset++, 'binary');\n      buffer.write(String.fromCharCode(length&0x7f), offset++, 'binary');\n    } else\n      buffer.write('\\x00', 'binary');\n  }\n\n  if (isString) buffer.write(data, offset, 'utf8');\n  else data.copy(buffer, offset, 0);\n\n  if (writeEndMarker) {\n    if (options && options.binary) {\n      // sending binary, not writing end marker\n    } else\n      buffer.write('\\xff', offset + length, 'binary');\n    this.continuationFrame = false;\n  }\n  else this.continuationFrame = true;\n\n  try {\n    this.socket.write(buffer, 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (this.isClosed) return;\n  this.isClosed = true;\n  try {\n    if (this.continuationFrame) this.socket.write(new Buffer([0xff], 'binary'));\n    this.socket.write(new Buffer([0xff, 0x00]), 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a ping message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {};\n\n/**\n * Sends a pong message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nSender.prototype.error = function (reason) {\n  this.emit('error', reason);\n  return this;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Sender.hixie.js\n// module id = 43\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n \nmodule.exports.Validation = {\n  isValidUTF8: function(buffer) {\n    return true;\n  }\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Validation.fallback.js\n// module id = 44\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = require('utf-8-validate');\n} catch (e) {\n  module.exports = require('./Validation.fallback');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Validation.js\n// module id = 45\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util')\n  , events = require('events')\n  , http = require('http')\n  , crypto = require('crypto')\n  , Options = require('options')\n  , WebSocket = require('./WebSocket')\n  , Extensions = require('./Extensions')\n  , PerMessageDeflate = require('./PerMessageDeflate')\n  , tls = require('tls')\n  , url = require('url');\n\n/**\n * WebSocket Server implementation\n */\n\nfunction WebSocketServer(options, callback) {\n  events.EventEmitter.call(this);\n\n  options = new Options({\n    host: '0.0.0.0',\n    port: null,\n    server: null,\n    verifyClient: null,\n    handleProtocols: null,\n    path: null,\n    noServer: false,\n    disableHixie: false,\n    clientTracking: true,\n    perMessageDeflate: true\n  }).merge(options);\n\n  if (!options.isDefinedAndNonNull('port') && !options.isDefinedAndNonNull('server') && !options.value.noServer) {\n    throw new TypeError('`port` or a `server` must be provided');\n  }\n\n  var self = this;\n\n  if (options.isDefinedAndNonNull('port')) {\n    this._server = http.createServer(function (req, res) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Not implemented');\n    });\n    this._server.listen(options.value.port, options.value.host, callback);\n    this._closeServer = function() { if (self._server) self._server.close(); };\n  }\n  else if (options.value.server) {\n    this._server = options.value.server;\n    if (options.value.path) {\n      // take note of the path, to avoid collisions when multiple websocket servers are\n      // listening on the same http server\n      if (this._server._webSocketPaths && options.value.server._webSocketPaths[options.value.path]) {\n        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');\n      }\n      if (typeof this._server._webSocketPaths !== 'object') {\n        this._server._webSocketPaths = {};\n      }\n      this._server._webSocketPaths[options.value.path] = 1;\n    }\n  }\n  if (this._server) this._server.once('listening', function() { self.emit('listening'); });\n\n  if (typeof this._server != 'undefined') {\n    this._server.on('error', function(error) {\n      self.emit('error', error)\n    });\n    this._server.on('upgrade', function(req, socket, upgradeHead) {\n      //copy upgradeHead to avoid retention of large slab buffers used in node core\n      var head = new Buffer(upgradeHead.length);\n      upgradeHead.copy(head);\n\n      self.handleUpgrade(req, socket, head, function(client) {\n        self.emit('connection'+req.url, client);\n        self.emit('connection', client);\n      });\n    });\n  }\n\n  this.options = options.value;\n  this.path = options.value.path;\n  this.clients = [];\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(WebSocketServer, events.EventEmitter);\n\n/**\n * Immediately shuts down the connection.\n *\n * @api public\n */\n\nWebSocketServer.prototype.close = function() {\n  // terminate all associated clients\n  var error = null;\n  try {\n    for (var i = 0, l = this.clients.length; i < l; ++i) {\n      this.clients[i].terminate();\n    }\n  }\n  catch (e) {\n    error = e;\n  }\n\n  // remove path descriptor, if any\n  if (this.path && this._server._webSocketPaths) {\n    delete this._server._webSocketPaths[this.path];\n    if (Object.keys(this._server._webSocketPaths).length == 0) {\n      delete this._server._webSocketPaths;\n    }\n  }\n\n  // close the http server if it was internally created\n  try {\n    if (typeof this._closeServer !== 'undefined') {\n      this._closeServer();\n    }\n  }\n  finally {\n    delete this._server;\n  }\n  if (error) throw error;\n}\n\n/**\n * Handle a HTTP Upgrade request.\n *\n * @api public\n */\n\nWebSocketServer.prototype.handleUpgrade = function(req, socket, upgradeHead, cb) {\n  // check for wrong path\n  if (this.options.path) {\n    var u = url.parse(req.url);\n    if (u && u.pathname !== this.options.path) return;\n  }\n\n  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);\n  else handleHybiUpgrade.apply(this, arguments);\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\n\nfunction handleHybiUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify version\n  var version = parseInt(req.headers['sec-websocket-version']);\n  if ([8, 13].indexOf(version) === -1) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify protocol\n  var protocols = req.headers['sec-websocket-protocol'];\n\n  // verify client\n  var origin = version < 13 ?\n    req.headers['sec-websocket-origin'] :\n    req.headers['origin'];\n\n  // handle extensions offer\n  var extensionsOffer = Extensions.parse(req.headers['sec-websocket-extensions']);\n\n  // handler to call when the connection sequence completes\n  var self = this;\n  var completeHybiUpgrade2 = function(protocol) {\n\n    // calc key\n    var key = req.headers['sec-websocket-key'];\n    var shasum = crypto.createHash('sha1');\n    shasum.update(key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    key = shasum.digest('base64');\n\n    var headers = [\n        'HTTP/1.1 101 Switching Protocols'\n      , 'Upgrade: websocket'\n      , 'Connection: Upgrade'\n      , 'Sec-WebSocket-Accept: ' + key\n    ];\n\n    if (typeof protocol != 'undefined') {\n      headers.push('Sec-WebSocket-Protocol: ' + protocol);\n    }\n\n    var extensions = {};\n    try {\n      extensions = acceptExtensions.call(self, extensionsOffer);\n    } catch (err) {\n      abortConnection(socket, 400, 'Bad Request');\n      return;\n    }\n\n    if (Object.keys(extensions).length) {\n      var serverExtensions = {};\n      Object.keys(extensions).forEach(function(token) {\n        serverExtensions[token] = [extensions[token].params]\n      });\n      headers.push('Sec-WebSocket-Extensions: ' + Extensions.format(serverExtensions));\n    }\n\n    // allows external modification/inspection of handshake headers\n    self.emit('headers', headers);\n\n    socket.setTimeout(0);\n    socket.setNoDelay(true);\n    try {\n      socket.write(headers.concat('', '').join('\\r\\n'));\n    }\n    catch (e) {\n      // if the upgrade write fails, shut the connection down hard\n      try { socket.destroy(); } catch (e) {}\n      return;\n    }\n\n    var client = new WebSocket([req, socket, upgradeHead], {\n      protocolVersion: version,\n      protocol: protocol,\n      extensions: extensions\n    });\n\n    if (self.options.clientTracking) {\n      self.clients.push(client);\n      client.on('close', function() {\n        var index = self.clients.indexOf(client);\n        if (index != -1) {\n          self.clients.splice(index, 1);\n        }\n      });\n    }\n\n    // signal upgrade complete\n    socket.removeListener('error', errorHandler);\n    cb(client);\n  }\n\n  // optionally call external protocol selection handler before\n  // calling completeHybiUpgrade2\n  var completeHybiUpgrade1 = function() {\n    // choose from the sub-protocols\n    if (typeof self.options.handleProtocols == 'function') {\n        var protList = (protocols || \"\").split(/, */);\n        var callbackCalled = false;\n        var res = self.options.handleProtocols(protList, function(result, protocol) {\n          callbackCalled = true;\n          if (!result) abortConnection(socket, 401, 'Unauthorized');\n          else completeHybiUpgrade2(protocol);\n        });\n        if (!callbackCalled) {\n            // the handleProtocols handler never called our callback\n            abortConnection(socket, 501, 'Could not process protocols');\n        }\n        return;\n    } else {\n        if (typeof protocols !== 'undefined') {\n            completeHybiUpgrade2(protocols.split(/, */)[0]);\n        }\n        else {\n            completeHybiUpgrade2();\n        }\n    }\n  }\n\n  // optionally call external client verification handler\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else completeHybiUpgrade1();\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  completeHybiUpgrade1();\n}\n\nfunction handleHixieUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // bail if options prevent hixie\n  if (this.options.disableHixie) {\n    abortConnection(socket, 401, 'Hixie support disabled');\n    return;\n  }\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key2']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  var origin = req.headers['origin']\n    , self = this;\n\n  // setup handshake completion to run after client has been verified\n  var onClientVerified = function() {\n    var wshost;\n    if (!req.headers['x-forwarded-host'])\n        wshost = req.headers.host;\n    else\n        wshost = req.headers['x-forwarded-host'];\n    var location = ((req.headers['x-forwarded-proto'] === 'https' || socket.encrypted) ? 'wss' : 'ws') + '://' + wshost + req.url\n      , protocol = req.headers['sec-websocket-protocol'];\n\n    // handshake completion code to run once nonce has been successfully retrieved\n    var completeHandshake = function(nonce, rest) {\n      // calculate key\n      var k1 = req.headers['sec-websocket-key1']\n        , k2 = req.headers['sec-websocket-key2']\n        , md5 = crypto.createHash('md5');\n\n      [k1, k2].forEach(function (k) {\n        var n = parseInt(k.replace(/[^\\d]/g, ''))\n          , spaces = k.replace(/[^ ]/g, '').length;\n        if (spaces === 0 || n % spaces !== 0){\n          abortConnection(socket, 400, 'Bad Request');\n          return;\n        }\n        n /= spaces;\n        md5.update(String.fromCharCode(\n          n >> 24 & 0xFF,\n          n >> 16 & 0xFF,\n          n >> 8  & 0xFF,\n          n       & 0xFF));\n      });\n      md5.update(nonce.toString('binary'));\n\n      var headers = [\n          'HTTP/1.1 101 Switching Protocols'\n        , 'Upgrade: WebSocket'\n        , 'Connection: Upgrade'\n        , 'Sec-WebSocket-Location: ' + location\n      ];\n      if (typeof protocol != 'undefined') headers.push('Sec-WebSocket-Protocol: ' + protocol);\n      if (typeof origin != 'undefined') headers.push('Sec-WebSocket-Origin: ' + origin);\n\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n      try {\n        // merge header and hash buffer\n        var headerBuffer = new Buffer(headers.concat('', '').join('\\r\\n'));\n        var hashBuffer = new Buffer(md5.digest('binary'), 'binary');\n        var handshakeBuffer = new Buffer(headerBuffer.length + hashBuffer.length);\n        headerBuffer.copy(handshakeBuffer, 0);\n        hashBuffer.copy(handshakeBuffer, headerBuffer.length);\n\n        // do a single write, which - upon success - causes a new client websocket to be setup\n        socket.write(handshakeBuffer, 'binary', function(err) {\n          if (err) return; // do not create client if an error happens\n          var client = new WebSocket([req, socket, rest], {\n            protocolVersion: 'hixie-76',\n            protocol: protocol\n          });\n          if (self.options.clientTracking) {\n            self.clients.push(client);\n            client.on('close', function() {\n              var index = self.clients.indexOf(client);\n              if (index != -1) {\n                self.clients.splice(index, 1);\n              }\n            });\n          }\n\n          // signal upgrade complete\n          socket.removeListener('error', errorHandler);\n          cb(client);\n        });\n      }\n      catch (e) {\n        try { socket.destroy(); } catch (e) {}\n        return;\n      }\n    }\n\n    // retrieve nonce\n    var nonceLength = 8;\n    if (upgradeHead && upgradeHead.length >= nonceLength) {\n      var nonce = upgradeHead.slice(0, nonceLength);\n      var rest = upgradeHead.length > nonceLength ? upgradeHead.slice(nonceLength) : null;\n      completeHandshake.call(self, nonce, rest);\n    }\n    else {\n      // nonce not present in upgradeHead, so we must wait for enough data\n      // data to arrive before continuing\n      var nonce = new Buffer(nonceLength);\n      upgradeHead.copy(nonce, 0);\n      var received = upgradeHead.length;\n      var rest = null;\n      var handler = function (data) {\n        var toRead = Math.min(data.length, nonceLength - received);\n        if (toRead === 0) return;\n        data.copy(nonce, received, 0, toRead);\n        received += toRead;\n        if (received == nonceLength) {\n          socket.removeListener('data', handler);\n          if (toRead < data.length) rest = data.slice(toRead);\n          completeHandshake.call(self, nonce, rest);\n        }\n      }\n      socket.on('data', handler);\n    }\n  }\n\n  // verify client\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      var self = this;\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else onClientVerified.apply(self);\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  // no client verification required\n  onClientVerified();\n}\n\nfunction acceptExtensions(offer) {\n  var extensions = {};\n  var options = this.options.perMessageDeflate;\n  if (options && offer[PerMessageDeflate.extensionName]) {\n    var perMessageDeflate = new PerMessageDeflate(options !== true ? options : {}, true);\n    perMessageDeflate.accept(offer[PerMessageDeflate.extensionName]);\n    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n  }\n  return extensions;\n}\n\nfunction abortConnection(socket, code, name) {\n  try {\n    var response = [\n      'HTTP/1.1 ' + code + ' ' + name,\n      'Content-type: text/html'\n    ];\n    socket.write(response.concat('', '').join('\\r\\n'));\n  }\n  catch (e) { /* ignore errors - we've aborted this connection */ }\n  finally {\n    // ensure that an early aborted connection is shut down completely\n    try { socket.destroy(); } catch (e) {}\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/WebSocketServer.js\n// module id = 46\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar client_1 = require(\"./client/client\");\r\nvar server_1 = require(\"./server/server\");\r\nvar AGMImpl = (function () {\r\n    function AGMImpl(protocol, clientRepository, serverRepository, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.client = new client_1.default(protocol, clientRepository, instance, configuration);\r\n        this.server = new server_1.default(protocol, serverRepository, instance, configuration);\r\n    }\r\n    AGMImpl.prototype.serverRemoved = function (callback) {\r\n        return this.client.serverRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.serverAdded = function (callback) {\r\n        return this.client.serverAdded(callback);\r\n    };\r\n    AGMImpl.prototype.serverMethodRemoved = function (callback) {\r\n        return this.client.serverMethodRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.serverMethodAdded = function (callback) {\r\n        return this.client.serverMethodAdded(callback);\r\n    };\r\n    AGMImpl.prototype.methodRemoved = function (callback) {\r\n        return this.client.methodRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.methodAdded = function (callback) {\r\n        return this.client.methodAdded(callback);\r\n    };\r\n    AGMImpl.prototype.methodsForInstance = function (instance) {\r\n        return this.client.methodsForInstance(instance);\r\n    };\r\n    AGMImpl.prototype.methods = function (methodFilter) {\r\n        return this.client.methods(methodFilter);\r\n    };\r\n    AGMImpl.prototype.servers = function (methodFilter) {\r\n        return this.client.servers(methodFilter);\r\n    };\r\n    AGMImpl.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        return this.client.subscribe(method, options, successCallback, errorCallback);\r\n    };\r\n    AGMImpl.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);\r\n    };\r\n    AGMImpl.prototype.unregister = function (methodFilter) {\r\n        return this.server.unregister(methodFilter);\r\n    };\r\n    AGMImpl.prototype.registerAsync = function (methodDefinition, callback) {\r\n        return this.server.registerAsync(methodDefinition, callback);\r\n    };\r\n    AGMImpl.prototype.register = function (methodDefinition, callback) {\r\n        return this.server.register(methodDefinition, callback);\r\n    };\r\n    AGMImpl.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n    };\r\n    AGMImpl.prototype.updateInstance = function (newInstance) {\r\n        if (this.instance.machine === undefined) {\r\n            this.instance.machine = newInstance.MachineName || newInstance.machine;\r\n        }\r\n        if (this.instance.user === undefined) {\r\n            this.instance.user = newInstance.UserName || newInstance.user;\r\n        }\r\n        if (this.instance.environment === undefined) {\r\n            this.instance.environment = newInstance.Environment || newInstance.environment;\r\n        }\r\n        if (this.instance.region === undefined) {\r\n            this.instance.region = newInstance.Region || newInstance.region;\r\n        }\r\n    };\r\n    return AGMImpl;\r\n}());\r\nexports.default = AGMImpl;\r\n//# sourceMappingURL=agm.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/agm.js\n// module id = 47\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar invoke_1 = require(\"./invoke\");\r\nvar promisify_1 = require(\"../helpers/promisify\");\r\nvar Client = (function () {\r\n    function Client(protocol, repo, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.repo = repo;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.clientInvocations = new invoke_1.default(protocol);\r\n    }\r\n    Client.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var callProtocolSubscribe = function (targetServers, stream, successProxy, errorProxy) {\r\n            _this.protocol.client.subscribe(stream, options.arguments, targetServers, { methodResponseTimeout: options.waitTimeoutMs }, successProxy, errorProxy);\r\n        };\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (sub) {\r\n                resolve(sub);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            var methodDef;\r\n            if (typeof method === \"string\") {\r\n                methodDef = { name: method };\r\n            }\r\n            else {\r\n                methodDef = method;\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            var target = options.target;\r\n            if (target === undefined) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject({ message: '\"' + target + '\" is not a valid target. Valid targets are \"all\", \"best\", or an instance.' });\r\n            }\r\n            if (options.methodResponseTimeout === undefined) {\r\n                options.methodResponseTimeout = options.method_response_timeout;\r\n                if (options.methodResponseTimeout === undefined) {\r\n                    options.methodResponseTimeout = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (options.waitTimeoutMs === undefined) {\r\n                options.waitTimeoutMs = options.wait_for_method_timeout;\r\n                if (options.waitTimeoutMs === undefined) {\r\n                    options.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            var delayStep = 500;\r\n            var delayTillNow = 0;\r\n            var currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n            if (currentServers.length > 0) {\r\n                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);\r\n            }\r\n            else {\r\n                var retry_1 = function () {\r\n                    delayTillNow += delayStep;\r\n                    currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n                    if (currentServers.length > 0) {\r\n                        var streamInfo = currentServers[0].methods[0];\r\n                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);\r\n                    }\r\n                    else if (delayTillNow >= options.waitTimeoutMs) {\r\n                        var def = typeof method === \"string\" ? { name: method } : method;\r\n                        var info = {\r\n                            id: undefined,\r\n                            info: def,\r\n                            getInfoForUser: function () {\r\n                                return methodDef;\r\n                            },\r\n                            protocolState: undefined,\r\n                        };\r\n                        callProtocolSubscribe(currentServers, info, successProxy, errorProxy);\r\n                    }\r\n                    else {\r\n                        setTimeout(retry_1, delayStep);\r\n                    }\r\n                };\r\n                setTimeout(retry_1, delayStep);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    Client.prototype.servers = function (methodFilter) {\r\n        return this.getServers(methodFilter).map(function (serverMethodMap) {\r\n            return serverMethodMap.server.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methods = function (methodFilter) {\r\n        return this.getMethods(methodFilter).map(function (m) {\r\n            return m.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methodsForInstance = function (instance) {\r\n        return this.getMethodsForInstance(instance).map(function (m) {\r\n            return m.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methodAdded = function (callback) {\r\n        return this.repo.onMethodAdded(function (method) {\r\n            callback(method.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.methodRemoved = function (callback) {\r\n        return this.repo.onMethodRemoved(function (method) {\r\n            callback(method.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.serverAdded = function (callback) {\r\n        return this.repo.onServerAdded(function (server) {\r\n            callback(server.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.serverRemoved = function (callback) {\r\n        return this.repo.onServerRemoved(function (server, reason) {\r\n            callback(server.getInfoForUser(), reason);\r\n        });\r\n    };\r\n    Client.prototype.serverMethodAdded = function (callback) {\r\n        return this.repo.onServerMethodAdded(function (server, method) {\r\n            callback({ server: server.getInfoForUser(), method: method.getInfoForUser() });\r\n        });\r\n    };\r\n    Client.prototype.serverMethodRemoved = function (callback) {\r\n        return this.repo.onServerMethodRemoved(function (server, method) {\r\n            callback({ server: server.getInfoForUser(), method: method.getInfoForUser() });\r\n        });\r\n    };\r\n    Client.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (args) {\r\n                resolve(args);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            if (!argumentObj) {\r\n                argumentObj = {};\r\n            }\r\n            if (!target) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject({ message: '\"' + target + '\" is not a valid target. Valid targets are \"all\" and \"best\".' });\r\n            }\r\n            if (!additionalOptions) {\r\n                additionalOptions = {};\r\n            }\r\n            if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                additionalOptions.methodResponseTimeoutMs = additionalOptions.method_response_timeout;\r\n                if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                    additionalOptions.methodResponseTimeoutMs = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (additionalOptions.waitTimeoutMs === undefined) {\r\n                additionalOptions.waitTimeoutMs = additionalOptions.wait_for_method_timeout;\r\n                if (additionalOptions.waitTimeoutMs === undefined) {\r\n                    additionalOptions.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== \"number\") {\r\n                reject({ message: '\"' + additionalOptions.waitTimeoutMs + '\" is not a valid number for \\'waitTimeoutMs\\'' });\r\n                return;\r\n            }\r\n            if (typeof argumentObj !== \"object\") {\r\n                reject({ message: \"The method arguments must be an object.\" });\r\n                return;\r\n            }\r\n            if (typeof methodFilter === \"string\") {\r\n                methodFilter = { name: methodFilter };\r\n            }\r\n            var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodFilter, target);\r\n            if (serversMethodMap.length === 0) {\r\n                _this.invokeUnExisting(methodFilter, argumentObj, target, additionalOptions, successProxy, errorProxy);\r\n            }\r\n            else if (serversMethodMap.length === 1) {\r\n                var serverMethodPair = serversMethodMap[0];\r\n                _this.clientInvocations.invoke(serverMethodPair.methods[0], argumentObj, serverMethodPair.server, additionalOptions, successProxy, errorProxy);\r\n            }\r\n            else {\r\n                _this.invokeOnAll(serversMethodMap, argumentObj, additionalOptions, successProxy, errorProxy);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, success, error);\r\n    };\r\n    Client.prototype.invokeUnExisting = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var callError = function () {\r\n            error({\r\n                method: methodFilter,\r\n                called_with: argumentObj,\r\n                message: \"Can not find a method matching \" + JSON.stringify(methodFilter) + \" with server filter \" + JSON.stringify(target),\r\n                executed_by: undefined,\r\n                returned: undefined,\r\n                status: undefined,\r\n            });\r\n        };\r\n        if (additionalOptions.waitTimeoutMs === 0) {\r\n            callError();\r\n        }\r\n        else {\r\n            var delayStep_1 = 500;\r\n            var delayTillNow_1 = 0;\r\n            var retry_2 = function () {\r\n                delayTillNow_1 += delayStep_1;\r\n                var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodFilter, target);\r\n                if (serversMethodMap.length > 0) {\r\n                    _this.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n                }\r\n                else if (delayTillNow_1 >= additionalOptions.waitTimeoutMs) {\r\n                    callError();\r\n                }\r\n                else {\r\n                    setTimeout(retry_2, delayStep_1);\r\n                }\r\n            };\r\n            setTimeout(retry_2, delayStep_1);\r\n        }\r\n    };\r\n    Client.prototype.invokeOnAll = function (serverMethodsMap, argumentObj, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var successes = [];\r\n        var errors = [];\r\n        var successCallback = function (result) {\r\n            successes.push(result);\r\n            sendResponse();\r\n        };\r\n        var errorCallback = function (err) {\r\n            errors.push(err);\r\n            sendResponse();\r\n        };\r\n        var sendResponse = function () {\r\n            if (successes.length + errors.length < serverMethodsMap.length) {\r\n                return;\r\n            }\r\n            if (successes.length !== 0) {\r\n                var result_1 = successes.reduce(function (obj, invResult) {\r\n                    obj.method = invResult.method;\r\n                    obj.called_with = invResult.called_with;\r\n                    obj.returned = invResult.returned;\r\n                    obj.all_return_values.push({\r\n                        executed_by: invResult.executed_by,\r\n                        returned: invResult.returned,\r\n                        called_with: invResult.called_with,\r\n                        method: invResult.method,\r\n                        message: undefined,\r\n                        status: undefined,\r\n                    });\r\n                    obj.executed_by = invResult.executed_by;\r\n                    return obj;\r\n                }, { all_return_values: [] });\r\n                if (errors.length !== 0) {\r\n                    result_1.all_errors = [];\r\n                    errors.forEach(function (obj) {\r\n                        result_1.all_errors.push({\r\n                            executed_by: obj.executed_by,\r\n                            called_with: obj.called_with,\r\n                            name: obj.method.name,\r\n                            message: obj.message,\r\n                        });\r\n                    });\r\n                }\r\n                success(result_1);\r\n            }\r\n            else if (errors.length !== 0) {\r\n                error(errors.reduce(function (obj, currentError) {\r\n                    obj.method = currentError.method;\r\n                    obj.called_with = currentError.called_with;\r\n                    obj.message = currentError.message;\r\n                    obj.all_errors.push({\r\n                        executed_by: currentError.executed_by,\r\n                        message: currentError.message,\r\n                    });\r\n                    return obj;\r\n                }, { all_errors: [] }));\r\n            }\r\n        };\r\n        serverMethodsMap.forEach(function (serverMethodsPair) {\r\n            _this.clientInvocations.invoke(serverMethodsPair.methods[0], argumentObj, serverMethodsPair.server, additionalOptions, successCallback, errorCallback);\r\n        });\r\n    };\r\n    Client.prototype.filterByTarget = function (target, serverMethodMap) {\r\n        var _this = this;\r\n        var targetServerMethod = [];\r\n        if (typeof target === \"string\") {\r\n            if (target === \"all\") {\r\n                targetServerMethod = serverMethodMap;\r\n            }\r\n            else if (target === \"best\") {\r\n                var matchingMachine = serverMethodMap.filter(function (serverMethodPair) {\r\n                    var serverInfo = serverMethodPair.server.info;\r\n                    return serverInfo.machine === _this.instance.machine;\r\n                })[0];\r\n                if (matchingMachine) {\r\n                    return [matchingMachine];\r\n                }\r\n                targetServerMethod = serverMethodMap[0] !== undefined ? [serverMethodMap[0]] : [];\r\n            }\r\n        }\r\n        else {\r\n            if (!Array.isArray(target)) {\r\n                target = [target];\r\n            }\r\n            if (Array.isArray(target)) {\r\n                targetServerMethod = target.reduce(function (matches, filter) {\r\n                    var myMatches = serverMethodMap.filter(function (serverMethodPair) {\r\n                        return _this.instanceMatch(filter, serverMethodPair.server.info);\r\n                    });\r\n                    return matches.concat(myMatches);\r\n                }, []);\r\n            }\r\n        }\r\n        return targetServerMethod;\r\n    };\r\n    Client.prototype.instanceMatch = function (instanceFilter, instanceDefinition) {\r\n        return this.containsProps(instanceFilter, instanceDefinition);\r\n    };\r\n    Client.prototype.methodMatch = function (methodFilter, methodDefinition) {\r\n        return this.containsProps(methodFilter, methodDefinition);\r\n    };\r\n    Client.prototype.containsProps = function (filter, object) {\r\n        return Object.keys(filter).reduce(function (match, prop) {\r\n            if (!filter[prop] || typeof filter[prop] === \"function\") {\r\n                return match;\r\n            }\r\n            if (filter[prop].constructor === RegExp) {\r\n                if (!filter[prop].test(object[prop])) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    return match;\r\n                }\r\n            }\r\n            else {\r\n                if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    return match;\r\n                }\r\n            }\r\n        }, true);\r\n    };\r\n    Client.prototype.getMethods = function (methodFilter) {\r\n        var _this = this;\r\n        if (methodFilter === undefined) {\r\n            return this.repo.getMethods();\r\n        }\r\n        if (typeof methodFilter === \"string\") {\r\n            methodFilter = { name: methodFilter };\r\n        }\r\n        return this.repo.getMethods().filter(function (method) {\r\n            return _this.methodMatch(methodFilter, method.info);\r\n        });\r\n    };\r\n    Client.prototype.getMethodsForInstance = function (instanceFilter) {\r\n        var _this = this;\r\n        var allServers = this.repo.getServers();\r\n        var matchingServers = allServers.filter(function (server) {\r\n            return _this.instanceMatch(instanceFilter, server.info);\r\n        });\r\n        if (matchingServers.length === 0) {\r\n            return [];\r\n        }\r\n        var resultMethodsObject = {};\r\n        if (matchingServers.length === 1) {\r\n            resultMethodsObject = matchingServers[0].methods;\r\n        }\r\n        else {\r\n            matchingServers.forEach(function (server) {\r\n                Object.keys(server.methods).forEach(function (methodKey) {\r\n                    var method = server.methods[methodKey];\r\n                    resultMethodsObject[method.id] = method;\r\n                });\r\n            });\r\n        }\r\n        return Object.keys(resultMethodsObject)\r\n            .map(function (key) {\r\n            return resultMethodsObject[key];\r\n        });\r\n    };\r\n    Client.prototype.getServers = function (methodFilter) {\r\n        var _this = this;\r\n        var servers = this.repo.getServers();\r\n        if (methodFilter === undefined) {\r\n            return servers.map(function (server) {\r\n                return { server: server };\r\n            });\r\n        }\r\n        var methods = this.getMethods(methodFilter);\r\n        if (methods === undefined) {\r\n            return [];\r\n        }\r\n        return servers.reduce(function (prev, current) {\r\n            var methodsForServer = _this.repo.getServerMethodsById(current.id);\r\n            var matchingMethods = methodsForServer.filter(function (method) {\r\n                return _this.methodMatch(methodFilter, method.info);\r\n            });\r\n            if (matchingMethods.length > 0) {\r\n                prev.push({ server: current, methods: matchingMethods });\r\n            }\r\n            return prev;\r\n        }, []);\r\n    };\r\n    Client.prototype.getServerMethodsByFilterAndTarget = function (methodFilter, target) {\r\n        var serversMethodMap = this.getServers(methodFilter);\r\n        return this.filterByTarget(target, serversMethodMap);\r\n    };\r\n    return Client;\r\n}());\r\nexports.default = Client;\r\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/client/client.js\n// module id = 48\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"../helpers/random\");\r\nvar ClientInvocations = (function () {\r\n    function ClientInvocations(_protocol) {\r\n        var _this = this;\r\n        this._protocol = _protocol;\r\n        this._pendingCallbacks = {};\r\n        _protocol.client.onInvocationResult(function (invocationId, executedBy, status, result, resultMessage) {\r\n            return _this.processInvocationResult(invocationId, executedBy, status, result, resultMessage);\r\n        });\r\n    }\r\n    ClientInvocations.prototype.invoke = function (method, argumentsObj, target, stuff, success, error) {\r\n        var invocationId = random_1.default();\r\n        this.registerInvocation(invocationId, {\r\n            method: method,\r\n            calledWith: argumentsObj,\r\n        }, success, error, stuff.methodResponseTimeoutMs);\r\n        this._protocol.client.invoke(invocationId, method, argumentsObj, target, stuff);\r\n    };\r\n    ClientInvocations.prototype.registerInvocation = function (invocationId, invocationInfo, success, error, timeout) {\r\n        var _this = this;\r\n        this._pendingCallbacks[invocationId] = { invocationInfo: invocationInfo, success: success, error: error };\r\n        setTimeout(function () {\r\n            if (_this._pendingCallbacks[invocationId] === undefined) {\r\n                return;\r\n            }\r\n            error({\r\n                method: invocationInfo.method.getInfoForUser(),\r\n                called_with: invocationInfo.calledWith,\r\n                executed_by: undefined,\r\n                status: undefined,\r\n                returned: undefined,\r\n                message: \"Invocation timeout (\" + timeout + \" ms) reached\",\r\n            });\r\n            delete _this._pendingCallbacks[invocationId];\r\n        }, timeout);\r\n    };\r\n    ClientInvocations.prototype.processInvocationResult = function (invocationId, executedBy, status, result, resultMessage) {\r\n        var callback = this._pendingCallbacks[invocationId];\r\n        if (callback === undefined) {\r\n            return;\r\n        }\r\n        if (status === 0 && typeof callback.success === \"function\") {\r\n            callback.success({\r\n                method: callback.invocationInfo.method.getInfoForUser(),\r\n                called_with: callback.invocationInfo.calledWith,\r\n                executed_by: executedBy,\r\n                returned: result,\r\n                message: resultMessage,\r\n                status: status,\r\n            });\r\n        }\r\n        else if (typeof callback.error === \"function\") {\r\n            callback.error({\r\n                method: callback.invocationInfo.method.getInfoForUser(),\r\n                called_with: callback.invocationInfo.calledWith,\r\n                executed_by: executedBy,\r\n                message: resultMessage,\r\n                status: status,\r\n                returned: result,\r\n            });\r\n        }\r\n        delete this._pendingCallbacks[invocationId];\r\n    };\r\n    return ClientInvocations;\r\n}());\r\nexports.default = ClientInvocations;\r\n//# sourceMappingURL=invoke.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/client/invoke.js\n// module id = 49\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar ClientRepository = (function () {\r\n    function ClientRepository() {\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n        this.callbacks = callback_registry_1.default();\r\n    }\r\n    ClientRepository.prototype.addServer = function (info, serverId) {\r\n        var _this = this;\r\n        var current = this.servers[serverId];\r\n        if (current) {\r\n            return current.id;\r\n        }\r\n        var serverEntry = {\r\n            id: serverId,\r\n            info: info,\r\n            methods: {},\r\n            getInfoForUser: function () {\r\n                var serverInfo = _this.createUserServerInfo(serverEntry.info);\r\n                serverInfo.getMethods = function () {\r\n                    return _this.getServerMethodsById(serverEntry.id).map(function (m) {\r\n                        return m.getInfoForUser();\r\n                    });\r\n                };\r\n                serverInfo.getStreams = function () {\r\n                    return _this.getServerMethodsById(serverEntry.id)\r\n                        .filter(function (method) {\r\n                        return method.info.supportsStreaming;\r\n                    })\r\n                        .map(function (m) {\r\n                        return m.getInfoForUser();\r\n                    });\r\n                };\r\n                return serverInfo;\r\n            },\r\n        };\r\n        this.servers[serverId] = serverEntry;\r\n        this.callbacks.execute(\"onServerAdded\", serverEntry);\r\n        return serverId;\r\n    };\r\n    ClientRepository.prototype.removeServerById = function (id, reason) {\r\n        var _this = this;\r\n        var server = this.servers[id];\r\n        Object.keys(server.methods).forEach(function (methodId) {\r\n            _this.removeServerMethod(id, methodId);\r\n        });\r\n        delete this.servers[id];\r\n        this.callbacks.execute(\"onServerRemoved\", server, reason);\r\n    };\r\n    ClientRepository.prototype.addServerMethod = function (serverId, method, protocolState) {\r\n        if (!protocolState) {\r\n            protocolState = {};\r\n        }\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var methodId = this.createMethodId(method);\r\n        if (server.methods[methodId]) {\r\n            return;\r\n        }\r\n        var that = this;\r\n        var methodEntity = {\r\n            id: methodId,\r\n            info: method,\r\n            getInfoForUser: function () {\r\n                var result = that.createUserMethodInfo(methodEntity.info);\r\n                result.getServers = function () {\r\n                    return that.getServersByMethod(methodId);\r\n                };\r\n                return result;\r\n            },\r\n            protocolState: protocolState,\r\n        };\r\n        server.methods[methodId] = methodEntity;\r\n        if (!this.methodsCount[methodId]) {\r\n            this.methodsCount[methodId] = 0;\r\n            this.callbacks.execute(\"onMethodAdded\", methodEntity);\r\n        }\r\n        this.methodsCount[methodId] = this.methodsCount[methodId] + 1;\r\n        this.callbacks.execute(\"onServerMethodAdded\", server, methodEntity);\r\n    };\r\n    ClientRepository.prototype.createMethodId = function (methodInfo) {\r\n        var accepts = methodInfo.accepts !== undefined ? methodInfo.accepts : \"\";\r\n        var returns = methodInfo.returns !== undefined ? methodInfo.returns : \"\";\r\n        return (methodInfo.name + accepts + returns).toLowerCase();\r\n    };\r\n    ClientRepository.prototype.removeServerMethod = function (serverId, methodId) {\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var method = server.methods[methodId];\r\n        delete server.methods[methodId];\r\n        this.methodsCount[methodId] = this.methodsCount[methodId] - 1;\r\n        if (this.methodsCount[methodId] === 0) {\r\n            this.callbacks.execute(\"onMethodRemoved\", method);\r\n        }\r\n        this.callbacks.execute(\"onServerMethodRemoved\", server, method);\r\n    };\r\n    ClientRepository.prototype.getMethods = function () {\r\n        var _this = this;\r\n        var allMethods = {};\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            Object.keys(server.methods).forEach(function (methodId) {\r\n                var method = server.methods[methodId];\r\n                allMethods[method.id] = method;\r\n            });\r\n        });\r\n        var methodsAsArray = Object.keys(allMethods).map(function (id) {\r\n            return allMethods[id];\r\n        });\r\n        return methodsAsArray;\r\n    };\r\n    ClientRepository.prototype.getServers = function () {\r\n        var _this = this;\r\n        var allServers = [];\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            allServers.push(server);\r\n        });\r\n        return allServers;\r\n    };\r\n    ClientRepository.prototype.getServerMethodsById = function (serverId) {\r\n        var server = this.servers[serverId];\r\n        return Object.keys(server.methods).map(function (id) {\r\n            return server.methods[id];\r\n        });\r\n    };\r\n    ClientRepository.prototype.onServerAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerAdded\", callback);\r\n        this.getServers().forEach(function (server) {\r\n            callback(server);\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodAdded\", callback);\r\n        this.getMethods().forEach(function (method) {\r\n            callback(method);\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodAdded\", callback);\r\n        this.getServers().forEach(function (server) {\r\n            var methods = server.methods;\r\n            Object.keys(methods).forEach(function (methodId) {\r\n                callback(server, methods[methodId]);\r\n            });\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.getServerById = function (id) {\r\n        return this.servers[id];\r\n    };\r\n    ClientRepository.prototype.reset = function () {\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n    };\r\n    ClientRepository.prototype.createUserServerInfo = function (serverInfo) {\r\n        return {\r\n            machine: serverInfo.machine,\r\n            pid: serverInfo.pid,\r\n            user: serverInfo.user,\r\n            application: serverInfo.application,\r\n            environment: serverInfo.environment,\r\n            region: serverInfo.region,\r\n            instance: serverInfo.instance,\r\n            windowId: serverInfo.windowId,\r\n            peerId: serverInfo.peerId,\r\n        };\r\n    };\r\n    ClientRepository.prototype.createUserMethodInfo = function (methodInfo) {\r\n        var result = {\r\n            name: methodInfo.name,\r\n            accepts: methodInfo.accepts,\r\n            returns: methodInfo.returns,\r\n            description: methodInfo.description,\r\n            displayName: methodInfo.displayName,\r\n            objectTypes: methodInfo.objectTypes,\r\n            supportsStreaming: methodInfo.supportsStreaming,\r\n        };\r\n        result.object_types = methodInfo.objectTypes;\r\n        result.display_name = methodInfo.displayName;\r\n        result.version = methodInfo.version;\r\n        return result;\r\n    };\r\n    ClientRepository.prototype.getServersByMethod = function (id) {\r\n        var _this = this;\r\n        var allServers = [];\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            Object.keys(server.methods).forEach(function (methodId) {\r\n                if (methodId === id) {\r\n                    allServers.push(server.getInfoForUser());\r\n                }\r\n            });\r\n        });\r\n        return allServers;\r\n    };\r\n    return ClientRepository;\r\n}());\r\nexports.default = ClientRepository;\r\n//# sourceMappingURL=repository.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/client/repository.js\n// module id = 50\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar promisify_1 = require(\"../helpers/promisify\");\r\nvar NativeAGM = (function () {\r\n    function NativeAGM(instance, helpers, agmFacade) {\r\n        this.instance = instance;\r\n        this.helpers = helpers;\r\n        this.agmFacade = agmFacade;\r\n        this.protocolVersion = this.agmFacade.protocolVersion;\r\n    }\r\n    NativeAGM.prototype.register = function (name, handler) {\r\n        var methodInfoAsObject = this.helpers.stringToObject(name, \"name\");\r\n        this.helpers.validateMethodInfo(methodInfoAsObject);\r\n        if (this.protocolVersion && this.protocolVersion >= 3) {\r\n            this.agmFacade.register(JSON.stringify(methodInfoAsObject), handler, true);\r\n        }\r\n        else {\r\n            this.agmFacade.register(JSON.stringify(methodInfoAsObject), function (arg, caller) {\r\n                var methodResult = handler(JSON.parse(arg), caller);\r\n                return JSON.stringify(methodResult);\r\n            });\r\n        }\r\n    };\r\n    NativeAGM.prototype.registerAsync = function (name, handler) {\r\n        if (!this.agmFacade.registerAsync) {\r\n            throw new Error(\"not supported in that version of HtmlContainer\");\r\n        }\r\n        var methodInfoAsObject = this.helpers.stringToObject(name, \"name\");\r\n        this.helpers.validateMethodInfo(methodInfoAsObject);\r\n        this.agmFacade.registerAsync(methodInfoAsObject, function (args, instance, tracker) {\r\n            handler(args, instance, function (successArgs) {\r\n                tracker.success(successArgs);\r\n            }, function (error) {\r\n                tracker.error(error);\r\n            });\r\n        });\r\n    };\r\n    NativeAGM.prototype.unregister = function (definition) {\r\n        this.agmFacade.unregister(JSON.stringify(this.helpers.stringToObject(definition, \"name\")));\r\n    };\r\n    NativeAGM.prototype.invoke = function (method, argumentObj, target, options, success, error) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (argumentObj === undefined) {\r\n                argumentObj = {};\r\n            }\r\n            if (typeof argumentObj !== \"object\") {\r\n                reject({ message: \"The method arguments must be an object.\" });\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            target = _this.helpers.targetArgToObject(target);\r\n            if (_this.agmFacade.invoke2) {\r\n                _this.agmFacade.invoke2(JSON.stringify(_this.helpers.stringToObject(method, \"name\")), argumentObj, JSON.stringify(target), JSON.stringify(options), function (a) {\r\n                    resolve(a);\r\n                }, function (err) {\r\n                    reject(err);\r\n                });\r\n            }\r\n            else {\r\n                var successProxy = void 0;\r\n                var errorProxy = void 0;\r\n                successProxy = function (args) {\r\n                    var parsed = JSON.parse(args);\r\n                    resolve(parsed);\r\n                };\r\n                errorProxy = function (args) {\r\n                    var parsed = JSON.parse(args);\r\n                    reject(parsed);\r\n                };\r\n                _this.agmFacade.invoke(JSON.stringify(_this.helpers.stringToObject(method, \"name\")), JSON.stringify(argumentObj), JSON.stringify(target), JSON.stringify(options), successProxy, errorProxy);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, success, error);\r\n    };\r\n    NativeAGM.prototype.createStream = function (methodDefinition, options, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof methodDefinition === \"string\") {\r\n                methodDefinition = {\r\n                    name: methodDefinition,\r\n                    getServers: function () { return []; },\r\n                };\r\n            }\r\n            if (!options) {\r\n                options = {\r\n                    subscriptionRequestHandler: undefined,\r\n                    subscriptionAddedHandler: undefined,\r\n                    subscriptionRemovedHandler: undefined,\r\n                };\r\n            }\r\n            _this.agmFacade.createStream2(JSON.stringify(methodDefinition), options.subscriptionRequestHandler, options.subscriptionAddedHandler, options.subscriptionRemovedHandler, function (stream) {\r\n                resolve(stream);\r\n            }, function (error) {\r\n                reject(error);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    NativeAGM.prototype.subscribe = function (methodDefinition, parameters, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof methodDefinition === \"undefined\") {\r\n                reject(\"method definition param is required\");\r\n            }\r\n            if (parameters === undefined) {\r\n                parameters = {};\r\n            }\r\n            parameters.args = JSON.stringify(parameters.arguments || {});\r\n            parameters.target = _this.helpers.targetArgToObject(parameters.target);\r\n            var name;\r\n            if (typeof methodDefinition === \"string\") {\r\n                name = methodDefinition;\r\n            }\r\n            else {\r\n                name = methodDefinition.name;\r\n            }\r\n            _this.agmFacade.subscribe2(name, JSON.stringify(parameters), function (sub) {\r\n                resolve(sub);\r\n            }, function (error) {\r\n                reject(error);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    NativeAGM.prototype.servers = function (filter) {\r\n        var _this = this;\r\n        var jsonResult = this.agmFacade.servers(JSON.stringify(this.helpers.stringToObject(filter, \"name\")));\r\n        var parsedResult = this.helpers.agmParse(jsonResult);\r\n        return parsedResult.map(function (server) {\r\n            return _this.transformServerObject(server);\r\n        });\r\n    };\r\n    NativeAGM.prototype.methods = function (filter) {\r\n        var _this = this;\r\n        var jsonResult = this.agmFacade.methods(JSON.stringify(this.helpers.stringToObject(filter, \"name\")));\r\n        var parsedResult = this.helpers.agmParse(jsonResult);\r\n        return parsedResult.map(function (method) {\r\n            return _this.transformMethodObject(method);\r\n        });\r\n    };\r\n    NativeAGM.prototype.methodAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.methodAdded(function (method) {\r\n            if (subscribed) {\r\n                callback(_this.transformMethodObject(method));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.methodRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.methodRemoved(function (method) {\r\n            if (subscribed) {\r\n                callback(_this.transformMethodObject(method));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverAdded(function (server) {\r\n            if (subscribed) {\r\n                callback(_this.transformServerObject(server));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverRemoved(function (server) {\r\n            if (subscribed) {\r\n                callback(_this.transformServerObject(server));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverMethodAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverMethodAdded(function (info) {\r\n            if (subscribed) {\r\n                callback({\r\n                    server: _this.transformServerObject(info.server),\r\n                    method: _this.transformMethodObject(info.method),\r\n                });\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverMethodRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverMethodRemoved(function (info) {\r\n            if (subscribed) {\r\n                callback({\r\n                    server: _this.transformServerObject(info.server),\r\n                    method: _this.transformMethodObject(info.method),\r\n                });\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.methodsForInstance = function (server) {\r\n        var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(server));\r\n        var methods = this.helpers.agmParse(jsonResult);\r\n        return methods.map(this.transformMethodObject);\r\n    };\r\n    NativeAGM.prototype.transformMethodObject = function (method) {\r\n        var _this = this;\r\n        if (!method) {\r\n            return undefined;\r\n        }\r\n        if (!method.displayName) {\r\n            method.displayName = method.display_name;\r\n        }\r\n        if (!method.objectTypes) {\r\n            method.objectTypes = method.object_types;\r\n        }\r\n        method.getServers = function () {\r\n            return _this.servers(method.name);\r\n        };\r\n        return method;\r\n    };\r\n    NativeAGM.prototype.transformServerObject = function (server) {\r\n        var _this = this;\r\n        if (!server) {\r\n            return undefined;\r\n        }\r\n        server.getMethods = function () {\r\n            return _this.methodsForInstance(server);\r\n        };\r\n        server.getStreams = function () {\r\n            return _this.methodsForInstance(server).filter(function (method) {\r\n                return method.supportsStreaming;\r\n            });\r\n        };\r\n        return server;\r\n    };\r\n    return NativeAGM;\r\n}());\r\nexports.NativeAGM = NativeAGM;\r\n//# sourceMappingURL=agm.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/hc/agm.js\n// module id = 51\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Helpers = (function () {\r\n    function Helpers(facade) {\r\n        this.facade = facade;\r\n        this.dateTimeIdentifier = facade.jsonValueDatePrefix;\r\n        this.lenOfIdentifier = this.dateTimeIdentifier.length;\r\n    }\r\n    Helpers.prototype.agmParse = function (str) {\r\n        var _this = this;\r\n        return JSON.parse(str, function (k, v) {\r\n            if (typeof v !== \"string\") {\r\n                return v;\r\n            }\r\n            if (v[0] !== _this.dateTimeIdentifier[0]) {\r\n                return v;\r\n            }\r\n            if (v.indexOf(_this.dateTimeIdentifier) !== 0) {\r\n                return v;\r\n            }\r\n            var unixTimestampMs = v.substr(_this.lenOfIdentifier);\r\n            return new Date(parseFloat(unixTimestampMs));\r\n        });\r\n    };\r\n    Helpers.prototype.targetArgToObject = function (target) {\r\n        var _this = this;\r\n        target = target || \"best\";\r\n        if (typeof target === \"string\") {\r\n            if (target !== \"all\" && target !== \"best\") {\r\n                throw new Error(target + \" is not a valid target. Valid targets are 'all' and 'best'\");\r\n            }\r\n            return { target: target };\r\n        }\r\n        else {\r\n            if (!Array.isArray(target)) {\r\n                target = [target];\r\n            }\r\n            target = target.map(function (e) {\r\n                return _this.convertInstanceToRegex(e);\r\n            });\r\n            return { serverFilter: target };\r\n        }\r\n    };\r\n    Helpers.prototype.convertInstanceToRegex = function (instance) {\r\n        var instanceConverted = {};\r\n        Object.keys(instance).forEach(function (key) {\r\n            var propValue = instance[key];\r\n            instanceConverted[key] = propValue;\r\n            if (typeof propValue === \"undefined\" || propValue === null) {\r\n                return;\r\n            }\r\n            if (typeof propValue === \"string\" && propValue !== \"\") {\r\n                instanceConverted[key] = \"^\" + instance[key] + \"$\";\r\n            }\r\n            else if (instance[key].constructor === RegExp) {\r\n                instanceConverted[key] = instance[key].source;\r\n            }\r\n            else {\r\n                instanceConverted[key] = instance[key];\r\n            }\r\n        });\r\n        return instanceConverted;\r\n    };\r\n    Helpers.prototype.validateMethodInfo = function (methodInfo) {\r\n        if (typeof methodInfo === \"undefined\") {\r\n            throw Error(\"methodInfo is required argument\");\r\n        }\r\n        if (!methodInfo.name) {\r\n            throw Error(\"methodInfo object must contain name property\");\r\n        }\r\n        if (methodInfo.objectTypes) {\r\n            methodInfo.object_types = methodInfo.objectTypes;\r\n        }\r\n        if (methodInfo.displayName) {\r\n            methodInfo.display_name = methodInfo.displayName;\r\n        }\r\n    };\r\n    Helpers.prototype.stringToObject = function (param, stringPropName) {\r\n        if (typeof param === \"string\") {\r\n            var obj = {};\r\n            obj[stringPropName] = param;\r\n            return obj;\r\n        }\r\n        return param;\r\n    };\r\n    return Helpers;\r\n}());\r\nexports.Helpers = Helpers;\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/hc/helpers.js\n// module id = 52\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar agm_1 = require(\"./agm\");\r\nvar helpers_1 = require(\"./helpers\");\r\nfunction default_1(configuration) {\r\n    var facade = window.htmlContainer.jsAgmFacade;\r\n    var cfgAsString = createConfig(configuration);\r\n    return new Promise(function (resolve, reject) {\r\n        var successInit = function (instance) {\r\n            var nativeAGM = new agm_1.NativeAGM(instance, new helpers_1.Helpers(facade), facade);\r\n            nativeAGM.create_stream = nativeAGM.createStream;\r\n            nativeAGM.methods_for_instance = nativeAGM.methodsForInstance;\r\n            nativeAGM.method_added = nativeAGM.methodAdded;\r\n            nativeAGM.method_removed = nativeAGM.methodRemoved;\r\n            nativeAGM.server_added = nativeAGM.serverAdded;\r\n            nativeAGM.server_removed = nativeAGM.serverRemoved;\r\n            nativeAGM.server_method_added = nativeAGM.serverMethodAdded;\r\n            nativeAGM.server_method_removed = nativeAGM.serverMethodRemoved;\r\n            resolve(nativeAGM);\r\n        };\r\n        if (facade.protocolVersion && facade.protocolVersion >= 5 && facade.initAsync) {\r\n            facade.initAsync(cfgAsString, successInit, function (err) {\r\n                reject(err);\r\n            });\r\n        }\r\n        else {\r\n            var instance = facade.init(cfgAsString);\r\n            successInit(instance);\r\n        }\r\n    });\r\n}\r\nexports.default = default_1;\r\nvar createConfig = function (configuration) {\r\n    if (configuration !== undefined && configuration.metrics !== undefined) {\r\n        configuration.metrics.metricsIdentity = configuration.metrics.identity;\r\n        var metricsConfig = {\r\n            metricsIdentity: configuration.metrics.metricsIdentity,\r\n            path: configuration.metrics.path,\r\n        };\r\n        configuration.metrics = metricsConfig;\r\n    }\r\n    delete configuration.logger;\r\n    return JSON.stringify(configuration);\r\n};\r\n//# sourceMappingURL=native.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/hc/native.js\n// module id = 53\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"./helpers/random\");\r\nfunction createOwnInstance(userSubmittedProperties, resolvedIdentity, peerId) {\r\n    var document = global.document || global.process;\r\n    var instance = {\r\n        application: document.title + random_1.default(),\r\n        pid: Math.floor(Math.random() * 10000000000),\r\n    };\r\n    instance.peerId = peerId;\r\n    if (typeof userSubmittedProperties === \"object\") {\r\n        if (userSubmittedProperties.application !== undefined) {\r\n            instance.application = userSubmittedProperties.application;\r\n        }\r\n        instance.machine = userSubmittedProperties.machine;\r\n        instance.user = userSubmittedProperties.user;\r\n        instance.environment = userSubmittedProperties.environment;\r\n        instance.region = userSubmittedProperties.region;\r\n    }\r\n    if (typeof resolvedIdentity !== \"undefined\") {\r\n        instance.user = resolvedIdentity.user;\r\n        instance.instance = resolvedIdentity.instance;\r\n        instance.application = resolvedIdentity.application;\r\n        instance.pid = resolvedIdentity.process;\r\n        instance.machine = resolvedIdentity.machine;\r\n        instance.environment = resolvedIdentity.environment;\r\n        instance.region = resolvedIdentity.region;\r\n        instance.windowId = resolvedIdentity.windowId;\r\n    }\r\n    return instance;\r\n}\r\nexports.createOwnInstance = createOwnInstance;\r\n//# sourceMappingURL=instance.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/instance.js\n// module id = 54\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar instance_1 = require(\"./instance\");\r\nvar native_1 = require(\"./hc/native\");\r\nvar factory_1 = require(\"./protocols/gw1/factory\");\r\nvar factory_2 = require(\"./protocols/gw3/factory\");\r\nvar agm_1 = require(\"./agm\");\r\nvar repository_1 = require(\"./client/repository\");\r\nvar repository_2 = require(\"./server/repository\");\r\nexports.default = (function (configuration) {\r\n    if (!configuration.forceGW && configuration.gdVersion === 2) {\r\n        return native_1.default(configuration);\r\n    }\r\n    if (typeof configuration === \"undefined\") {\r\n        throw new Error(\"configuration is required\");\r\n    }\r\n    if (typeof configuration.connection === \"undefined\") {\r\n        throw new Error(\"configuration.connections is required\");\r\n    }\r\n    var connection = configuration.connection;\r\n    if (typeof configuration.methodResponseTimeout !== \"number\") {\r\n        configuration.methodResponseTimeout = 3000;\r\n    }\r\n    if (typeof configuration.waitTimeoutMs !== \"number\") {\r\n        configuration.waitTimeoutMs = 3000;\r\n    }\r\n    var myIdentity = connection.resolvedIdentity;\r\n    var myInstance = instance_1.createOwnInstance(configuration.instance, myIdentity, connection.peerId);\r\n    var clientRepository = new repository_1.default();\r\n    var serverRepository = new repository_2.default();\r\n    var protocolPromise;\r\n    var agmImpl;\r\n    if (connection.protocolVersion === 3) {\r\n        protocolPromise = factory_2.default(myInstance, connection, clientRepository, serverRepository, configuration, function () { return agmImpl; });\r\n    }\r\n    else {\r\n        protocolPromise = factory_1.default(myInstance, connection, clientRepository, serverRepository, configuration, function () { return agmImpl; });\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n        protocolPromise.then(function (protocol) {\r\n            agmImpl = new agm_1.default(protocol, clientRepository, serverRepository, myInstance, configuration);\r\n            resolve(agmImpl);\r\n        }).catch(function (err) {\r\n            reject(err);\r\n        });\r\n    });\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/main.js\n// module id = 55\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"./../../helpers/random\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(configuration, instance, sendRequest, nextResponseSubject) {\r\n        this.configuration = configuration;\r\n        this.instance = instance;\r\n        this.sendRequest = sendRequest;\r\n        this.nextResponseSubject = nextResponseSubject;\r\n        this.subscriptionsList = {};\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: stream.getInfoForUser(),\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n                called_with: args,\r\n            });\r\n            return;\r\n        }\r\n        var subscriptionId = \"subscriptionId_\" + random_1.default();\r\n        var pendingSub = this.registerSubscription(subscriptionId, stream, args, success, error, options.methodResponseTimeout);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: stream.getInfoForUser(),\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n                called_with: args,\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var responseSubject = _this.nextResponseSubject();\r\n            var requestSubject = stream.info.requestSubject;\r\n            pendingSub.trackedServers.push({\r\n                server: undefined,\r\n                streamId: undefined,\r\n                streamSubjects: {\r\n                    global: undefined,\r\n                    private: undefined,\r\n                },\r\n                methodRequestSubject: requestSubject,\r\n                methodResponseSubject: responseSubject,\r\n            });\r\n            var message = {\r\n                EventStreamAction: 1,\r\n                MethodRequestSubject: requestSubject,\r\n                MethodResponseSubject: responseSubject,\r\n                Client: helpers_1.convertInstance(_this.instance),\r\n                Context: {\r\n                    ArgumentsJson: args,\r\n                    InvocationId: subscriptionId,\r\n                    MethodName: stream.info.name,\r\n                    ExecutionServer: target.server.info,\r\n                    Timeout: options.methodResponseTimeout,\r\n                },\r\n            };\r\n            _this.sendRequest(message);\r\n        });\r\n    };\r\n    ClientStreaming.prototype.processPublisherMsg = function (msg) {\r\n        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {\r\n            return;\r\n        }\r\n        if (msg.EventStreamAction === 2) {\r\n            this.serverIsKickingASubscriber(msg);\r\n        }\r\n        else if (msg.EventStreamAction === 3) {\r\n            this.serverAcknowledgesGoodSubscription(msg);\r\n        }\r\n        else if (msg.EventStreamAction === 5) {\r\n            this.serverHasPushedSomeDataIntoTheStream(msg);\r\n        }\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subscriptionId, method, args, success, error, timeout) {\r\n        var _this = this;\r\n        this.subscriptionsList[subscriptionId] = {\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            arguments: args,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: [],\r\n                onClosed: [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n        };\r\n        this.subscriptionsList[subscriptionId].timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subscriptionId] === undefined) {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subscriptionId];\r\n            if (subscription.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method,\r\n                    called_with: args,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \"ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subscriptionId];\r\n            }\r\n            else if (subscription.status === STATUS_SUBSCRIBED &&\r\n                subscription.trackedServers.length > 0) {\r\n                subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                    return (typeof server.streamId === \"string\" && server.streamId !== \"\");\r\n                });\r\n                subscription.timeoutId = undefined;\r\n                if (subscription.trackedServers.length === 0) {\r\n                    var closersCount = subscription.queued.closers.length;\r\n                    var closingServer_1 = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n                    subscription.handlers.onClosed.forEach(function (callback) {\r\n                        if (typeof callback === \"function\") {\r\n                            callback({\r\n                                message: ON_CLOSE_MSG_SERVER_INIT,\r\n                                requestArguments: subscription.arguments,\r\n                                server: closingServer_1,\r\n                                stream: subscription.method,\r\n                            });\r\n                        }\r\n                    });\r\n                    delete _this.subscriptionsList[subscriptionId];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return this.subscriptionsList[subscriptionId];\r\n    };\r\n    ClientStreaming.prototype.serverIsKickingASubscriber = function (msg) {\r\n        var _this = this;\r\n        var keys = Object.keys(this.subscriptionsList);\r\n        if (typeof msg.InvocationId === \"string\" && msg.InvocationId !== \"\") {\r\n            keys = keys.filter(function (k) { return k === msg.InvocationId; });\r\n        }\r\n        var deletionsList = [];\r\n        keys.forEach(function (key) {\r\n            if (typeof _this.subscriptionsList[key] !== \"object\") {\r\n                return;\r\n            }\r\n            _this.subscriptionsList[key].trackedServers = _this.subscriptionsList[key].trackedServers.filter(function (server) {\r\n                var isRejecting = (server.methodRequestSubject === msg.MethodRequestSubject && server.methodResponseSubject === msg.MethodResponseSubject);\r\n                var isKicking = (server.streamId === msg.StreamId &&\r\n                    (server.streamSubjects.global === msg.EventStreamSubject || server.streamSubjects.private === msg.EventStreamSubject));\r\n                var isRejectingOrKicking = isRejecting || isKicking;\r\n                return !isRejectingOrKicking;\r\n            });\r\n            if (_this.subscriptionsList[key].trackedServers.length === 0) {\r\n                deletionsList.push(key);\r\n            }\r\n        });\r\n        deletionsList.forEach(function (key) {\r\n            if (typeof _this.subscriptionsList[key] !== \"object\") {\r\n                return;\r\n            }\r\n            if (_this.subscriptionsList[key].status === STATUS_AWAITING_ACCEPT &&\r\n                typeof _this.subscriptionsList[key].timeoutId === \"number\") {\r\n                var reason = (typeof msg.ResultMessage === \"string\" && msg.ResultMessage !== \"\") ?\r\n                    ' Publisher said \"' + msg.ResultMessage + '\".' :\r\n                    \" No reason given.\";\r\n                var callArgs = typeof _this.subscriptionsList[key].arguments === \"object\" ?\r\n                    JSON.stringify(_this.subscriptionsList[key].arguments) :\r\n                    \"{}\";\r\n                _this.subscriptionsList[key].error(ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs);\r\n                clearTimeout(_this.subscriptionsList[key].timeoutId);\r\n            }\r\n            else {\r\n                _this.subscriptionsList[key].handlers.onClosed.forEach(function (callback) {\r\n                    if (typeof callback !== \"function\") {\r\n                        return;\r\n                    }\r\n                    callback({\r\n                        message: ON_CLOSE_MSG_SERVER_INIT,\r\n                        requestArguments: _this.subscriptionsList[key].arguments,\r\n                        server: helpers_1.convertInfoToInstance(msg.Server),\r\n                        stream: _this.subscriptionsList[key].method,\r\n                    });\r\n                });\r\n            }\r\n            delete _this.subscriptionsList[key];\r\n        });\r\n    };\r\n    ClientStreaming.prototype.serverAcknowledgesGoodSubscription = function (msg) {\r\n        var _this = this;\r\n        var subscriptionId = msg.InvocationId;\r\n        var subscription = this.subscriptionsList[subscriptionId];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        var acceptingServer = subscription.trackedServers.filter(function (server) {\r\n            return (server.methodRequestSubject === msg.MethodRequestSubject &&\r\n                server.methodResponseSubject === msg.MethodResponseSubject);\r\n        })[0];\r\n        if (typeof acceptingServer !== \"object\") {\r\n            return;\r\n        }\r\n        var isFirstResponse = (subscription.status === STATUS_AWAITING_ACCEPT);\r\n        subscription.status = STATUS_SUBSCRIBED;\r\n        var privateStreamSubject = this.generatePrivateStreamSubject(subscription.method.name);\r\n        if (typeof acceptingServer.streamId === \"string\" && acceptingServer.streamId !== \"\") {\r\n            return;\r\n        }\r\n        acceptingServer.server = helpers_1.convertInfoToInstance(msg.Server);\r\n        acceptingServer.streamId = msg.StreamId;\r\n        acceptingServer.streamSubjects.global = msg.EventStreamSubject;\r\n        acceptingServer.streamSubjects.private = privateStreamSubject;\r\n        var confirmatoryRequest = {\r\n            EventStreamAction: 3,\r\n            EventStreamSubject: privateStreamSubject,\r\n            StreamId: msg.StreamId,\r\n            MethodRequestSubject: msg.MethodRequestSubject,\r\n            MethodResponseSubject: acceptingServer.methodResponseSubject,\r\n            Client: helpers_1.convertInstance(this.instance),\r\n            Context: {\r\n                ArgumentsJson: subscription.arguments,\r\n                MethodName: subscription.method.name,\r\n            },\r\n        };\r\n        this.sendRequest(confirmatoryRequest);\r\n        if (isFirstResponse) {\r\n            subscription.success({\r\n                onData: function (dataCallback) {\r\n                    if (typeof dataCallback !== \"function\") {\r\n                        throw new TypeError(\"The data callback must be a function.\");\r\n                    }\r\n                    this.handlers.onData.push(dataCallback);\r\n                    if (this.handlers.onData.length === 1 && this.queued.data.length > 0) {\r\n                        this.queued.data.forEach(function (dataItem) {\r\n                            dataCallback(dataItem);\r\n                        });\r\n                    }\r\n                }.bind(subscription),\r\n                onClosed: function (closedCallback) {\r\n                    if (typeof closedCallback !== \"function\") {\r\n                        throw new TypeError(\"The callback must be a function.\");\r\n                    }\r\n                    this.handlers.onClosed.push(closedCallback);\r\n                }.bind(subscription),\r\n                onFailed: function () { },\r\n                close: function () { return _this.closeSubscription(subscription, subscriptionId); },\r\n                requestArguments: subscription.arguments,\r\n                serverInstance: helpers_1.convertInfoToInstance(msg.Server),\r\n                stream: subscription.method,\r\n            });\r\n        }\r\n    };\r\n    ClientStreaming.prototype.serverHasPushedSomeDataIntoTheStream = function (msg) {\r\n        var _loop_1 = function (key) {\r\n            if (this_1.subscriptionsList.hasOwnProperty(key) && typeof this_1.subscriptionsList[key] === \"object\") {\r\n                var isPrivateData = void 0;\r\n                var trackedServersFound = this_1.subscriptionsList[key].trackedServers.filter(function (ls) {\r\n                    return (ls.streamId === msg.StreamId &&\r\n                        (ls.streamSubjects.global === msg.EventStreamSubject ||\r\n                            ls.streamSubjects.private === msg.EventStreamSubject));\r\n                });\r\n                if (trackedServersFound.length === 0) {\r\n                    isPrivateData = undefined;\r\n                }\r\n                else if (trackedServersFound[0].streamSubjects.global === msg.EventStreamSubject) {\r\n                    isPrivateData = false;\r\n                }\r\n                else if (trackedServersFound[0].streamSubjects.private === msg.EventStreamSubject) {\r\n                    isPrivateData = true;\r\n                }\r\n                if (isPrivateData !== undefined) {\r\n                    var receivedStreamData_1 = {\r\n                        data: msg.ResultContextJson,\r\n                        server: helpers_1.convertInfoToInstance(msg.Server),\r\n                        requestArguments: this_1.subscriptionsList[key].arguments || {},\r\n                        message: msg.ResultMessage,\r\n                        private: isPrivateData,\r\n                    };\r\n                    var onDataHandlers = this_1.subscriptionsList[key].handlers.onData;\r\n                    var queuedData = this_1.subscriptionsList[key].queued.data;\r\n                    if (Array.isArray(onDataHandlers)) {\r\n                        if (onDataHandlers.length > 0) {\r\n                            onDataHandlers.forEach(function (callback) {\r\n                                if (typeof callback === \"function\") {\r\n                                    callback(receivedStreamData_1);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            queuedData.push(receivedStreamData_1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var key in this.subscriptionsList) {\r\n            _loop_1(key);\r\n        }\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (sub, subId) {\r\n        var _this = this;\r\n        var responseSubject = this.nextResponseSubject();\r\n        sub.trackedServers.forEach(function (server) {\r\n            _this.sendRequest({\r\n                EventStreamAction: 2,\r\n                Client: helpers_1.convertInstance(_this.instance),\r\n                MethodRequestSubject: server.methodRequestSubject,\r\n                MethodResponseSubject: responseSubject,\r\n                StreamId: server.streamId,\r\n                EventStreamSubject: server.streamSubjects.private,\r\n            });\r\n        });\r\n        sub.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback === \"function\") {\r\n                callback({\r\n                    message: ON_CLOSE_MSG_CLIENT_INIT,\r\n                    requestArguments: sub.arguments || {},\r\n                    server: sub.trackedServers[sub.trackedServers.length - 1].server,\r\n                    stream: sub.method,\r\n                });\r\n            }\r\n        });\r\n        delete this.subscriptionsList[subId];\r\n    };\r\n    ClientStreaming.prototype.generatePrivateStreamSubject = function (methodName) {\r\n        var appInfo = helpers_1.convertInstance(this.instance);\r\n        return \"ESSpriv-jsb_\" +\r\n            appInfo.ApplicationName +\r\n            \"_on_\" +\r\n            methodName +\r\n            \"_\" +\r\n            random_1.default();\r\n    };\r\n    return ClientStreaming;\r\n}());\r\nexports.default = ClientStreaming;\r\n//# sourceMappingURL=client-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/client-streaming.js\n// module id = 56\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"../../helpers/random\");\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar client_streaming_1 = require(\"./client-streaming\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar numberMissingHeartbeatsToRemove = 3;\r\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(connection, instance, configuration, repository) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.repository = repository;\r\n        this.respCounter = 0;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.timers = {};\r\n        this.timers = {};\r\n        this.streaming = new client_streaming_1.default(configuration, instance, function (msg) {\r\n            connection.send(\"agm\", \"MethodInvocationRequestMessage\", msg);\r\n        }, function () { return _this.nextResponseSubject(); });\r\n        this.listenForEvents();\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        this.streaming.subscribe(stream, args, targetServers, options, success, error);\r\n    };\r\n    ClientProtocol.prototype.onInvocationResult = function (callback) {\r\n        this.callbacks.add(\"onResult\", callback);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target, stuff) {\r\n        var methodInfo = method.info;\r\n        var message = {\r\n            MethodRequestSubject: methodInfo.requestSubject,\r\n            MethodResponseSubject: this.nextResponseSubject(),\r\n            Client: helpers_1.convertInstance(this.instance),\r\n            Context: {\r\n                ArgumentsJson: args,\r\n                InvocationId: id,\r\n                MethodName: methodInfo.name,\r\n                ExecutionServer: target.info,\r\n                Timeout: stuff.methodResponseTimeoutMs,\r\n            },\r\n        };\r\n        this.connection.send(\"agm\", \"MethodInvocationRequestMessage\", message);\r\n    };\r\n    ClientProtocol.prototype.nextResponseSubject = function () {\r\n        return \"resp_\" + (this.respCounter++) + \"_\" + random_1.default();\r\n    };\r\n    ClientProtocol.prototype.createServerInfo = function (instance) {\r\n        return {\r\n            machine: instance.MachineName,\r\n            pid: instance.ProcessId,\r\n            user: instance.UserName,\r\n            application: instance.ApplicationName,\r\n            environment: instance.Environment,\r\n            region: instance.Region,\r\n        };\r\n    };\r\n    ClientProtocol.prototype.createMethod = function (methodInfo) {\r\n        var method = methodInfo.Method;\r\n        return {\r\n            name: method.Name,\r\n            accepts: method.InputSignature,\r\n            returns: method.ResultSignature,\r\n            requestSubject: methodInfo.MethodRequestSubject,\r\n            description: method.Description,\r\n            displayName: method.DisplayName,\r\n            version: method.Version,\r\n            objectTypes: method.ObjectTypeRestrictions,\r\n            supportsStreaming: helpers_1.isStreamingFlagSet(method.Flags),\r\n        };\r\n    };\r\n    ClientProtocol.prototype.createServerId = function (serverInfo) {\r\n        if (serverInfo === undefined) {\r\n            return undefined;\r\n        }\r\n        return [serverInfo.application,\r\n            serverInfo.user,\r\n            serverInfo.machine,\r\n            serverInfo.started,\r\n            serverInfo.pid].join(\"/\").toLowerCase();\r\n    };\r\n    ClientProtocol.prototype.processServerPresence = function (presence, isPresence) {\r\n        var instance = presence.Instance;\r\n        var serverInfo = this.createServerInfo(instance);\r\n        var serverId = this.createServerId(serverInfo);\r\n        if (isPresence) {\r\n            serverId = this.repository.addServer(serverInfo, serverId);\r\n            if (presence.PublishingInterval) {\r\n                this.scheduleTimeout(serverId, presence.PublishingInterval);\r\n            }\r\n        }\r\n        else if (presence.PublishingInterval === 0) {\r\n            var server = this.repository.getServerById(serverId);\r\n            if (typeof server !== \"undefined\") {\r\n                this.repository.removeServerById(serverId);\r\n            }\r\n        }\r\n        if (presence.MethodDefinitions !== undefined) {\r\n            this.updateServerMethods(serverId, presence.MethodDefinitions);\r\n        }\r\n    };\r\n    ClientProtocol.prototype.scheduleTimeout = function (serverId, duration) {\r\n        var _this = this;\r\n        if (duration === -1) {\r\n            return;\r\n        }\r\n        var timer = this.timers[serverId];\r\n        if (timer !== undefined) {\r\n            clearTimeout(timer);\r\n        }\r\n        this.timers[serverId] = setTimeout(function () {\r\n            _this.repository.removeServerById(serverId);\r\n        }, duration * (numberMissingHeartbeatsToRemove + 1));\r\n    };\r\n    ClientProtocol.prototype.updateServerMethods = function (serverId, newMethods) {\r\n        var _this = this;\r\n        var oldMethods = this.repository.getServerMethodsById(serverId);\r\n        var newMethodsReduced = newMethods\r\n            .map(function (nm) { return _this.createMethod(nm); })\r\n            .reduce(function (obj, method) {\r\n            var methodId = _this.repository.createMethodId(method);\r\n            obj[methodId] = method;\r\n            return obj;\r\n        }, {});\r\n        oldMethods.forEach(function (method) {\r\n            if (newMethodsReduced[method.id] === undefined) {\r\n                _this.repository.removeServerMethod(serverId, method.id);\r\n            }\r\n            else {\r\n                delete newMethodsReduced[method.id];\r\n            }\r\n        });\r\n        Object.keys(newMethodsReduced).forEach(function (key) {\r\n            var method = newMethodsReduced[key];\r\n            _this.repository.addServerMethod(serverId, method);\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleInvokeResultMessage = function (message) {\r\n        if (message && message.EventStreamAction && message.EventStreamAction !== 0) {\r\n            this.streaming.processPublisherMsg(message);\r\n            return;\r\n        }\r\n        var server = message.Server ? this.createServerInfo(message.Server) : undefined;\r\n        var result = message.ResultContextJson;\r\n        if (result && Object.keys(result).length === 0) {\r\n            result = undefined;\r\n        }\r\n        this.callbacks.execute(\"onResult\", message.InvocationId, server, message.Status, result, message.ResultMessage);\r\n    };\r\n    ClientProtocol.prototype.listenForEvents = function () {\r\n        var _this = this;\r\n        this.connection.on(\"agm\", \"ServerPresenceMessage\", function (msg) {\r\n            _this.processServerPresence(msg, true);\r\n        });\r\n        this.connection.on(\"agm\", \"ServerHeartbeatMessage\", function (msg) {\r\n            _this.processServerPresence(msg, false);\r\n        });\r\n        this.connection.on(\"agm\", \"MethodInvocationResultMessage\", function (msg) {\r\n            _this.handleInvokeResultMessage(msg);\r\n        });\r\n    };\r\n    return ClientProtocol;\r\n}());\r\nexports.default = ClientProtocol;\r\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/client.js\n// module id = 57\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar server_1 = require(\"./server\");\r\nvar client_1 = require(\"./client\");\r\nfunction default_1(instance, connection, clientRepository, serverRepository, configuration, getAGM) {\r\n    var unsubscribe = connection.on(\"agm\", \"Instance\", function (newInstance) {\r\n        getAGM().updateInstance(newInstance);\r\n        connection.off(unsubscribe);\r\n    });\r\n    var server = new server_1.default(connection, instance, configuration, serverRepository);\r\n    var client = new client_1.default(connection, instance, configuration, clientRepository);\r\n    return new Promise(function (resolve) {\r\n        resolve({\r\n            server: server,\r\n            client: client,\r\n        });\r\n    });\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=factory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/factory.js\n// module id = 58\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"./../../helpers/random\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(connection, instance) {\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n    }\r\n    ServerStreaming.prototype.isStreamMsg = function (msg, method) {\r\n        return (msg &&\r\n            msg.EventStreamAction &&\r\n            msg.EventStreamAction !== 0 &&\r\n            typeof method === \"object\" &&\r\n            method.definition.supportsStreaming === true);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = null;\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            return (branches === null || (Boolean(br) && typeof br.key === \"string\" && branches.indexOf(br.key) >= 0));\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        var server = helpers_1.convertInstance(this.instance);\r\n        streamIdList.forEach(function (streamId) {\r\n            _this.sendResult({\r\n                EventStreamAction: 5,\r\n                EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                ResultContextJson: data,\r\n                Server: server,\r\n                StreamId: streamId,\r\n            });\r\n        });\r\n    };\r\n    ServerStreaming.prototype.closeAllSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        var streamList = streamingMethod.protocolState.branchKeyToStreamIdMap;\r\n        if (typeof branchKey === \"string\") {\r\n            streamList = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (br) {\r\n                return (typeof br === \"object\" && br.key === branchKey);\r\n            });\r\n        }\r\n        streamList.forEach(function (br) {\r\n            var streamId = br.streamId;\r\n            _this.sendResult({\r\n                EventStreamAction: 2,\r\n                EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                Server: helpers_1.convertInstance(_this.instance),\r\n                StreamId: streamId,\r\n                Status: 0,\r\n            });\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        return this.getUniqueBranchNames(streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = streamingMethod.protocolState.subscriptions;\r\n        }\r\n        else {\r\n            subscriptions = streamingMethod.protocolState.subscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.subAddedHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.subRemovedHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.requestHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.generateNewStreamId = function (streamingMethodName) {\r\n        var appInfo = helpers_1.convertInstance(this.instance);\r\n        return \"streamId-jsb_of_\" +\r\n            streamingMethodName +\r\n            \"__by_\" +\r\n            appInfo.ApplicationName +\r\n            \"_\" +\r\n            random_1.default();\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        var msg = requestContext.msg;\r\n        this.sendResult({\r\n            EventStreamAction: 2,\r\n            EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            MethodResponseSubject: msg.MethodResponseSubject,\r\n            MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n            ResultMessage: reason,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: \"default_rejection_streamId\",\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (streamingMethod, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this.sendResult({\r\n            EventStreamAction: 5,\r\n            EventStreamSubject: subscription.privateEventStreamSubject,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            ResultContextJson: data,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: subscription.streamId,\r\n        });\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        this.closeIndividualSubscription(streamingMethod, subscription.streamId, subscription.privateEventStreamSubject, true);\r\n    };\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var msg = requestContext.msg;\r\n        this.sendResult({\r\n            EventStreamAction: 3,\r\n            EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n            InvocationId: msg.Context.InvocationId,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            MethodResponseSubject: msg.MethodResponseSubject,\r\n            MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n            ResultMessage: \"Accepted\",\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: streamId,\r\n        });\r\n    };\r\n    ServerStreaming.prototype.processSubscriberMsg = function (msg, streamingMethod) {\r\n        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {\r\n            return;\r\n        }\r\n        if (msg.EventStreamAction === 1) {\r\n            this.clientWishesToSubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 2) {\r\n            this.clientWishesToUnsubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 3) {\r\n            this.clientAcknowledgesItDidSubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 4) {\r\n            this.clientPerSubHeartbeat(msg);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.sendResult = function (message) {\r\n        if (typeof message !== \"object\") {\r\n            throw new Error(\"Invalid message.\");\r\n        }\r\n        if (typeof message.Status !== \"number\") {\r\n            message.Status = 0;\r\n        }\r\n        this.connection.send(\"agm\", \"MethodInvocationResultMessage\", message);\r\n    };\r\n    ServerStreaming.prototype.clientWishesToSubscribe = function (msg, streamingMethod) {\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.Context.ArgumentsJson || {},\r\n            instance: helpers_1.convertInfoToInstance(msg.Client),\r\n        };\r\n        if (typeof this.requestHandler === \"function\") {\r\n            this.requestHandler(requestContext, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.clientWishesToUnsubscribe = function (msg, streamingMethod) {\r\n        if (!(streamingMethod &&\r\n            Array.isArray(streamingMethod.protocolState.subscriptions) &&\r\n            streamingMethod.protocolState.subscriptions.length > 0)) {\r\n            return;\r\n        }\r\n        this.closeIndividualSubscription(streamingMethod, msg.StreamId, msg.EventStreamSubject, false);\r\n    };\r\n    ServerStreaming.prototype.clientAcknowledgesItDidSubscribe = function (msg, streamingMethod) {\r\n        if (typeof msg.StreamId !== \"string\" || msg.StreamId === \"\") {\r\n            return;\r\n        }\r\n        var branchKey = this.getBranchKey(streamingMethod, msg.StreamId);\r\n        if (typeof branchKey !== \"string\") {\r\n            return;\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.subscriptions)) {\r\n            return;\r\n        }\r\n        var subscription = {\r\n            branchKey: branchKey,\r\n            instance: helpers_1.convertInfoToInstance(msg.Client),\r\n            arguments: msg.Context.ArgumentsJson,\r\n            streamId: msg.StreamId,\r\n            privateEventStreamSubject: msg.EventStreamSubject,\r\n            methodResponseSubject: msg.MethodResponseSubject,\r\n        };\r\n        streamingMethod.protocolState.subscriptions.push(subscription);\r\n        if (typeof this.subAddedHandler === \"function\") {\r\n            this.subAddedHandler(subscription, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.clientPerSubHeartbeat = function (msg) {\r\n    };\r\n    ServerStreaming.prototype.getBranchKey = function (streamingMethod, streamId) {\r\n        if (typeof streamId !== \"string\" || typeof streamingMethod !== \"object\") {\r\n            return;\r\n        }\r\n        var needle = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.streamId === streamId;\r\n        })[0];\r\n        if (typeof needle !== \"object\" || typeof needle.key !== \"string\") {\r\n            return;\r\n        }\r\n        return needle.key;\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.generateNewStreamId(streamingMethod.protocolState.method.Method.Name);\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    ServerStreaming.prototype.closeIndividualSubscription = function (streamingMethod, streamId, privateEventStreamSubject, sendKickMessage) {\r\n        var subscription = streamingMethod.protocolState.subscriptions.filter(function (subItem) {\r\n            return (subItem.privateEventStreamSubject === privateEventStreamSubject &&\r\n                subItem.streamId === streamId);\r\n        })[0];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        var initialLength = streamingMethod.protocolState.subscriptions.length;\r\n        streamingMethod.protocolState.subscriptions = streamingMethod.protocolState.subscriptions.filter(function (subItem) {\r\n            return !(subItem.privateEventStreamSubject === subscription.privateEventStreamSubject &&\r\n                subItem.streamId === subscription.streamId);\r\n        });\r\n        var filteredLength = streamingMethod.protocolState.subscriptions.length;\r\n        if (filteredLength !== (initialLength - 1)) {\r\n            return;\r\n        }\r\n        if (sendKickMessage === true) {\r\n            this.sendResult({\r\n                EventStreamAction: 2,\r\n                EventStreamSubject: privateEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                MethodResponseSubject: subscription.methodResponseSubject,\r\n                MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n                ResponseContextJson: {},\r\n                Server: helpers_1.convertInstance(this.instance),\r\n                StreamId: subscription.streamId,\r\n                Status: 0,\r\n            });\r\n        }\r\n        if (typeof this.subRemovedHandler === \"function\") {\r\n            this.subRemovedHandler(subscription, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.getUniqueBranchNames = function (streamingMethod) {\r\n        var keysWithDuplicates = streamingMethod.protocolState.subscriptions.map(function (sub) {\r\n            var result = null;\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                result = sub.branchKey;\r\n            }\r\n            return result;\r\n        });\r\n        var seen = [];\r\n        var branchArray = keysWithDuplicates.filter(function (bKey) {\r\n            if (bKey === null || seen.indexOf(bKey) >= 0) {\r\n                return false;\r\n            }\r\n            seen.push(bKey);\r\n            return true;\r\n        });\r\n        return branchArray;\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=server-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/server-streaming.js\n// module id = 59\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"../../helpers/random\");\r\nvar server_streaming_1 = require(\"./server-streaming\");\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar HeartbeatInterval = 5000;\r\nvar PresenceInterval = 10000;\r\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(connection, instance, configuration, serverRepository) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n        this.serverRepository = serverRepository;\r\n        this.invocationMessagesMap = {};\r\n        this.reqCounter = 0;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.streaming = new server_streaming_1.default(connection, instance);\r\n        connection.on(\"agm\", \"MethodInvocationRequestMessage\", function (msg) { return _this.handleMethodInvocationMessage(msg); });\r\n        connection.disconnected(this.stopTimers.bind(this));\r\n        this.sendHeartbeat();\r\n        if (this.heartbeatTimer === undefined) {\r\n            this.heartbeatTimer = setInterval(function () { return _this.sendHeartbeat(); }, HeartbeatInterval);\r\n        }\r\n        this.getBranchList = this.streaming.getBranchList;\r\n        this.getSubscriptionList = this.streaming.getSubscriptionList;\r\n        this.closeAllSubscriptions = this.streaming.closeAllSubscriptions;\r\n        this.closeSingleSubscription = this.streaming.closeSingleSubscription;\r\n        this.pushDataToSingle = this.streaming.pushDataToSingle;\r\n        this.pushData = this.streaming.pushData;\r\n        this.onSubRequest = this.streaming.onSubRequest;\r\n        this.acceptRequestOnBranch = this.streaming.acceptRequestOnBranch;\r\n        this.rejectRequest = this.streaming.rejectRequest;\r\n        this.onSubAdded = this.streaming.onSubAdded;\r\n        this.onSubRemoved = this.streaming.onSubRemoved;\r\n    }\r\n    ServerProtocol.prototype.stopTimers = function () {\r\n        clearInterval(this.presenceTimer);\r\n        clearInterval(this.heartbeatTimer);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (info) {\r\n        this.sendPresence();\r\n        return Promise.resolve();\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, success, error) {\r\n        var reqSubj = this.nextRequestSubject();\r\n        repoMethod.protocolState.method = this.createNewMethodMessage(repoMethod.definition, reqSubj, false);\r\n        this.announceNewMethod();\r\n        success();\r\n        return Promise.resolve();\r\n    };\r\n    ServerProtocol.prototype.createStream = function (repoMethod, success, error) {\r\n        var reqSubj = this.nextRequestSubject();\r\n        var streamConverted = this.createNewMethodMessage(repoMethod.definition, reqSubj, true);\r\n        repoMethod.protocolState.method = streamConverted;\r\n        repoMethod.protocolState.globalEventStreamSubject = repoMethod.definition.name + \".jsStream.\" + random_1.default();\r\n        repoMethod.protocolState.subscriptions = [];\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        this.announceNewMethod();\r\n        success();\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (executedMethod, invocationId, err, result) {\r\n        var message = this.invocationMessagesMap[invocationId];\r\n        if (!message) {\r\n            return;\r\n        }\r\n        if (message.MethodResponseSubject === \"null\") {\r\n            return;\r\n        }\r\n        if (executedMethod === undefined) {\r\n            return;\r\n        }\r\n        var resultMessage = {\r\n            MethodRequestSubject: message.MethodRequestSubject,\r\n            MethodResponseSubject: message.MethodResponseSubject,\r\n            MethodName: executedMethod.protocolState.method.Method.Name,\r\n            InvocationId: invocationId,\r\n            ResultContextJson: result,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            ResultMessage: err,\r\n            Status: err ? 1 : 0,\r\n        };\r\n        this.connection.send(\"agm\", \"MethodInvocationResultMessage\", resultMessage);\r\n        delete this.invocationMessagesMap[invocationId];\r\n    };\r\n    ServerProtocol.prototype.nextRequestSubject = function () {\r\n        return \"req_\" + (this.reqCounter++) + \"_\" + random_1.default();\r\n    };\r\n    ServerProtocol.prototype.sendHeartbeat = function () {\r\n        this.connection.send(\"agm\", \"ServerHeartbeatMessage\", this.constructHeartbeat());\r\n    };\r\n    ServerProtocol.prototype.constructHeartbeat = function () {\r\n        return {\r\n            PublishingInterval: HeartbeatInterval,\r\n            Instance: helpers_1.convertInstance(this.instance),\r\n        };\r\n    };\r\n    ServerProtocol.prototype.constructPresence = function () {\r\n        var methods = this.serverRepository.getList();\r\n        return {\r\n            PublishingInterval: PresenceInterval,\r\n            Instance: helpers_1.convertInstance(this.instance),\r\n            MethodDefinitions: methods.map(function (m) { return m.protocolState.method; }),\r\n        };\r\n    };\r\n    ServerProtocol.prototype.sendPresence = function () {\r\n        this.connection.send(\"agm\", \"ServerPresenceMessage\", this.constructPresence());\r\n    };\r\n    ServerProtocol.prototype.announceNewMethod = function () {\r\n        var _this = this;\r\n        this.sendPresence();\r\n        if (this.presenceTimer === undefined) {\r\n            this.presenceTimer = setInterval(function () { return _this.sendPresence(); }, PresenceInterval);\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleMethodInvocationMessage = function (message) {\r\n        var subject = message.MethodRequestSubject;\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.protocolState.method.MethodRequestSubject === subject;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        if (this.streaming.isStreamMsg(message, method)) {\r\n            this.streaming.processSubscriberMsg(message, method);\r\n            return;\r\n        }\r\n        var invocationId = message.Context.InvocationId;\r\n        this.invocationMessagesMap[invocationId] = message;\r\n        var invocationArgs = {\r\n            args: message.Context.ArgumentsJson,\r\n            instance: helpers_1.convertInfoToInstance(message.Client),\r\n        };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    ServerProtocol.prototype.createNewMethodMessage = function (methodIdentifier, subject, stream) {\r\n        if (typeof methodIdentifier === \"string\") {\r\n            methodIdentifier = { name: methodIdentifier };\r\n        }\r\n        if (typeof methodIdentifier.version !== \"number\") {\r\n            methodIdentifier.version = 0;\r\n        }\r\n        return {\r\n            Method: {\r\n                Name: methodIdentifier.name,\r\n                InputSignature: methodIdentifier.accepts,\r\n                ResultSignature: methodIdentifier.returns,\r\n                Description: methodIdentifier.description,\r\n                DisplayName: methodIdentifier.displayName,\r\n                Version: methodIdentifier.version,\r\n                ObjectTypeRestrictions: methodIdentifier.objectTypes,\r\n                Flags: stream ? 32 : undefined,\r\n            },\r\n            MethodRequestSubject: subject,\r\n        };\r\n    };\r\n    return ServerProtocol;\r\n}());\r\nexports.default = ServerProtocol;\r\n//# sourceMappingURL=server.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/server.js\n// module id = 60\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(instance, session, repository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        this.nextSubLocalKey = 0;\r\n        this.handleErrorSubscribing = function (errorResponse) {\r\n            var tag = errorResponse._tag;\r\n            var subLocalKey = tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                return server.serverId !== tag.serverId;\r\n            });\r\n            if (pendingSub.trackedServers.length <= 0) {\r\n                clearTimeout(pendingSub.timeoutId);\r\n                if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                    var reason = (typeof errorResponse.reason === \"string\" && errorResponse.reason !== \"\") ?\r\n                        ' Publisher said \"' + errorResponse.reason + '\".' :\r\n                        \" No reason given.\";\r\n                    var callArgs = typeof pendingSub.arguments === \"object\" ?\r\n                        JSON.stringify(pendingSub.arguments) :\r\n                        \"{}\";\r\n                    pendingSub.error({\r\n                        message: ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs,\r\n                        called_with: pendingSub.arguments,\r\n                        method: pendingSub.method.getInfoForUser(),\r\n                    });\r\n                }\r\n                else if (pendingSub.status === STATUS_SUBSCRIBED) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                }\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n        };\r\n        this.handleSubscribed = function (msg) {\r\n            var subLocalKey = msg._tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            var serverId = msg._tag.serverId;\r\n            var acceptingServer = pendingSub.trackedServers\r\n                .filter(function (server) {\r\n                return server.serverId === serverId;\r\n            })[0];\r\n            if (typeof acceptingServer !== \"object\") {\r\n                return;\r\n            }\r\n            acceptingServer.subscriptionId = msg.subscription_id;\r\n            _this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;\r\n            var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);\r\n            pendingSub.status = STATUS_SUBSCRIBED;\r\n            var that = _this;\r\n            if (isFirstResponse) {\r\n                pendingSub.success({\r\n                    onData: function (dataCallback) {\r\n                        if (typeof dataCallback !== \"function\") {\r\n                            throw new TypeError(\"The data callback must be a function.\");\r\n                        }\r\n                        pendingSub.handlers.onData.push(dataCallback);\r\n                        if (pendingSub.handlers.onData.length === 1 && pendingSub.queued.data.length > 0) {\r\n                            pendingSub.queued.data.forEach(function (dataItem) {\r\n                                dataCallback(dataItem);\r\n                            });\r\n                        }\r\n                    },\r\n                    onClosed: function (closedCallback) {\r\n                        if (typeof closedCallback !== \"function\") {\r\n                            throw new TypeError(\"The callback must be a function.\");\r\n                        }\r\n                        pendingSub.handlers.onClosed.push(closedCallback);\r\n                    },\r\n                    onFailed: function () {\r\n                    },\r\n                    close: function () { return that.closeSubscription(subLocalKey); },\r\n                    requestArguments: pendingSub.arguments,\r\n                    serverInstance: that.repository.getServerById(serverId).getInfoForUser(),\r\n                    stream: pendingSub.method.info,\r\n                });\r\n            }\r\n        };\r\n        this.handleEventData = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var trackedServersFound = subscription.trackedServers.filter(function (server) {\r\n                return server.subscriptionId === msg.subscription_id;\r\n            });\r\n            if (trackedServersFound.length !== 1) {\r\n                return;\r\n            }\r\n            var isPrivateData = msg.oob && msg.snapshot;\r\n            var sendingServerId = trackedServersFound[0].serverId;\r\n            var receivedStreamData = function () {\r\n                return {\r\n                    data: msg.data,\r\n                    server: _this.repository.getServerById(sendingServerId).getInfoForUser(),\r\n                    requestArguments: subscription.arguments || {},\r\n                    message: null,\r\n                    private: isPrivateData,\r\n                };\r\n            };\r\n            var onDataHandlers = subscription.handlers.onData;\r\n            var queuedData = subscription.queued.data;\r\n            if (onDataHandlers.length > 0) {\r\n                onDataHandlers.forEach(function (callback) {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(receivedStreamData());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                queuedData.push(receivedStreamData());\r\n            }\r\n        };\r\n        this.handleSubscriptionCancelled = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var expectedNewLength = subscription.trackedServers.length - 1;\r\n            subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                if (server.subscriptionId === msg.subscription_id) {\r\n                    subscription.queued.closers.push(server.serverId);\r\n                    return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            });\r\n            if (subscription.trackedServers.length !== expectedNewLength) {\r\n                return;\r\n            }\r\n            if (subscription.trackedServers.length <= 0) {\r\n                clearTimeout(subscription.timeoutId);\r\n                _this.callOnClosedHandlers(subscription);\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            delete _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n        };\r\n        session.on(\"subscribed\", this.handleSubscribed);\r\n        session.on(\"event\", this.handleEventData);\r\n        session.on(\"subscription-cancelled\", this.handleSubscriptionCancelled);\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (streamingMethod, argumentObj, targetServers, stuff, success, error) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: streamingMethod.getInfoForUser(),\r\n                called_with: argumentObj,\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n            });\r\n            return;\r\n        }\r\n        var subLocalKey = this.getNextSubscriptionLocalKey();\r\n        var pendingSub = this.registerSubscription(subLocalKey, streamingMethod, argumentObj, success, error, stuff.methodResponseTimeout);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: streamingMethod.getInfoForUser(),\r\n                called_with: argumentObj,\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var serverId = target.server.id;\r\n            pendingSub.trackedServers.push({\r\n                serverId: serverId,\r\n                subscriptionId: undefined,\r\n            });\r\n            var msg = {\r\n                type: \"subscribe\",\r\n                server_id: serverId,\r\n                method_id: streamingMethod.protocolState.id,\r\n                arguments_kv: argumentObj,\r\n            };\r\n            _this.session.send(msg, { serverId: serverId, subLocalKey: subLocalKey })\r\n                .then(function (m) { return _this.handleSubscribed(m); })\r\n                .catch(function (err) { return _this.handleErrorSubscribing(err); });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.getNextSubscriptionLocalKey = function () {\r\n        var current = this.nextSubLocalKey;\r\n        this.nextSubLocalKey += 1;\r\n        return current;\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subLocalKey, method, args, success, error, timeout) {\r\n        var _this = this;\r\n        this.subscriptionsList[subLocalKey] = {\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            arguments: args,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: [],\r\n                onClosed: [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n        };\r\n        this.subscriptionsList[subLocalKey].timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subLocalKey] === undefined) {\r\n                return;\r\n            }\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method.getInfoForUser(),\r\n                    called_with: args,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \" ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {\r\n                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                    return (typeof server.subscriptionId !== \"undefined\");\r\n                });\r\n                delete pendingSub.timeoutId;\r\n                if (pendingSub.trackedServers.length <= 0) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                    delete _this.subscriptionsList[subLocalKey];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return this.subscriptionsList[subLocalKey];\r\n    };\r\n    ClientStreaming.prototype.callOnClosedHandlers = function (subscription, reason) {\r\n        var closersCount = subscription.queued.closers.length;\r\n        var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n        var closingServer = null;\r\n        if (typeof closingServerId === \"number\") {\r\n            closingServer = this.repository.getServerById(closingServerId).getInfoForUser();\r\n        }\r\n        subscription.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback !== \"function\") {\r\n                return;\r\n            }\r\n            callback({\r\n                message: reason || ON_CLOSE_MSG_SERVER_INIT,\r\n                requestArguments: subscription.arguments,\r\n                server: closingServer,\r\n                stream: subscription.method,\r\n            });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (subLocalKey) {\r\n        var _this = this;\r\n        var subscription = this.subscriptionsList[subLocalKey];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        subscription.trackedServers.forEach(function (server) {\r\n            if (typeof server.subscriptionId === \"undefined\") {\r\n                return;\r\n            }\r\n            _this.session.sendFireAndForget({\r\n                type: \"unsubscribe\",\r\n                subscription_id: server.subscriptionId,\r\n                reason_uri: \"\",\r\n                reason: ON_CLOSE_MSG_CLIENT_INIT,\r\n            });\r\n            delete _this.subscriptionIdToLocalKeyMap[server.subscriptionId];\r\n        });\r\n        subscription.trackedServers = [];\r\n        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);\r\n        delete this.subscriptionsList[subLocalKey];\r\n    };\r\n    return ClientStreaming;\r\n}());\r\nexports.default = ClientStreaming;\r\n//# sourceMappingURL=client-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/client-streaming.js\n// module id = 61\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar client_streaming_1 = require(\"./client-streaming\");\r\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(instance, session, repository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.callbacks = callback_registry_1.default();\r\n        session.on(\"peer-added\", function (msg) { return _this.handlePeerAdded(msg); });\r\n        session.on(\"peer-removed\", function (msg) { return _this.handlePeerRemoved(msg); });\r\n        session.on(\"methods-added\", function (msg) { return _this.handleMethodsAddedMessage(msg); });\r\n        session.on(\"methods-removed\", function (msg) { return _this.handleMethodsRemovedMessage(msg); });\r\n        this.streaming = new client_streaming_1.default(instance, session, repository, logger);\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        this.streaming.subscribe(stream, args, targetServers, options, success, error);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target) {\r\n        var _this = this;\r\n        var serverId = target.id;\r\n        var methodId = method.protocolState.id;\r\n        var msg = {\r\n            type: \"call\",\r\n            server_id: serverId,\r\n            method_id: methodId,\r\n            arguments_kv: args,\r\n        };\r\n        this.session.send(msg, { invocationId: id, serverId: serverId })\r\n            .then(function (m) { return _this.handleResultMessage(m); })\r\n            .catch(function (err) { return _this.handleInvocationError(err); });\r\n    };\r\n    ClientProtocol.prototype.onInvocationResult = function (callback) {\r\n        this.callbacks.add(\"onResult\", callback);\r\n    };\r\n    ClientProtocol.prototype.handlePeerAdded = function (msg) {\r\n        var newPeerId = msg.new_peer_id;\r\n        var remoteId = msg.identity;\r\n        var pid = Number(remoteId.process);\r\n        var serverInfo = {\r\n            machine: remoteId.machine,\r\n            pid: isNaN(pid) ? remoteId.process : pid,\r\n            instance: remoteId.instance,\r\n            application: remoteId.application,\r\n            environment: remoteId.environment,\r\n            region: remoteId.region,\r\n            user: remoteId.user,\r\n            windowId: remoteId.windowId,\r\n            peerId: newPeerId,\r\n        };\r\n        this.repository.addServer(serverInfo, newPeerId);\r\n    };\r\n    ClientProtocol.prototype.handlePeerRemoved = function (msg) {\r\n        var removedPeerId = msg.removed_id;\r\n        var reason = msg.reason;\r\n        this.repository.removeServerById(removedPeerId, reason);\r\n    };\r\n    ClientProtocol.prototype.handleMethodsAddedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methods = msg.methods;\r\n        methods.forEach(function (method) {\r\n            var methodInfo = {\r\n                name: method.name,\r\n                displayName: method.display_name,\r\n                description: method.description,\r\n                version: method.version,\r\n                objectTypes: method.object_types || [],\r\n                accepts: method.input_signature,\r\n                returns: method.result_signature,\r\n                supportsStreaming: typeof method.flags !== \"undefined\" ? method.flags.streaming : false,\r\n            };\r\n            _this.repository.addServerMethod(serverId, methodInfo, { id: method.id });\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleMethodsRemovedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methodIdList = msg.methods;\r\n        var server = this.repository.getServerById(serverId);\r\n        var serverMethodKeys = Object.keys(server.methods);\r\n        serverMethodKeys.forEach(function (methodKey) {\r\n            var method = server.methods[methodKey];\r\n            if (methodIdList.indexOf(method.protocolState.id) > -1) {\r\n                _this.repository.removeServerMethod(serverId, methodKey);\r\n            }\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleResultMessage = function (msg) {\r\n        var invocationId = msg._tag.invocationId;\r\n        var result = msg.result;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        this.callbacks.execute(\"onResult\", invocationId, server.getInfoForUser(), 0, result, \"\");\r\n    };\r\n    ClientProtocol.prototype.handleInvocationError = function (msg) {\r\n        this.logger.debug(\"handle invocation error \" + JSON.stringify(msg));\r\n        var invocationId = msg._tag.invocationId;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        var message = msg.reason;\r\n        var context = msg.context;\r\n        this.callbacks.execute(\"onResult\", invocationId, server.getInfoForUser(), 1, context, message);\r\n    };\r\n    return ClientProtocol;\r\n}());\r\nexports.default = ClientProtocol;\r\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/client.js\n// module id = 62\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar server_1 = require(\"./server\");\r\nvar client_1 = require(\"./client\");\r\nfunction default_1(instance, connection, clientRepository, serverRepository, libConfig, getAGM) {\r\n    var logger = libConfig.logger.subLogger(\"gw3-protocol\");\r\n    var resolveReadyPromise;\r\n    var readyPromise = new Promise(function (resolve) {\r\n        resolveReadyPromise = resolve;\r\n    });\r\n    var session = connection.domain(\"agm\", logger.subLogger(\"domain\"), [\"subscribed\"]);\r\n    var server = new server_1.default(instance, session, clientRepository, serverRepository, logger.subLogger(\"server\"));\r\n    var client = new client_1.default(instance, session, clientRepository, logger.subLogger(\"client\"));\r\n    function handleReconnect() {\r\n        logger.info(\"reconnected - will replay registered methods and subscriptions\");\r\n        clientRepository.reset();\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        var registeredMethods = serverRepository.getList();\r\n        serverRepository.reset();\r\n        registeredMethods.forEach(function (method) {\r\n            var def = method.definition;\r\n            if (method.theFunction.userCallback) {\r\n                getAGM().register(def, method.theFunction.userCallback);\r\n            }\r\n            else if (method.theFunction.userCallbackAsync) {\r\n                getAGM().registerAsync(def, method.theFunction.userCallbackAsync);\r\n            }\r\n        });\r\n    }\r\n    function handleInitialJoin() {\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        resolveReadyPromise({\r\n            client: client,\r\n            server: server,\r\n        });\r\n        resolveReadyPromise = undefined;\r\n    }\r\n    session.onJoined(function (reconnect) {\r\n        if (reconnect) {\r\n            handleReconnect();\r\n        }\r\n        else {\r\n            handleInitialJoin();\r\n        }\r\n    });\r\n    session.join();\r\n    return readyPromise;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=factory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/factory.js\n// module id = 63\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar SUBSCRIPTION_REQUEST = \"onSubscriptionRequest\";\r\nvar SUBSCRIPTION_ADDED = \"onSubscriptionAdded\";\r\nvar SUBSCRIPTION_REMOVED = \"onSubscriptionRemoved\";\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(instance, session, repository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.ERR_URI_SUBSCRIPTION_FAILED = \"com.tick42.agm.errors.subscription.failure\";\r\n        this.callbacks = callback_registry_1.default();\r\n        this.nextStreamId = 0;\r\n        session.on(\"add-interest\", function (msg) { _this.handleAddInterest(msg); });\r\n        session.on(\"remove-interest\", function (msg) { _this.handleRemoveInterest(msg); });\r\n    }\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            throw new TypeError(\"The streaming method is missing its subscriptions.\");\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            throw new TypeError(\"The streaming method is missing its branches.\");\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var key = requestContext.msg.subscription_id;\r\n        var subscription = {\r\n            id: key,\r\n            arguments: requestContext.arguments,\r\n            instance: requestContext.instance,\r\n            branchKey: branch,\r\n            streamId: streamId,\r\n            subscribeMsg: requestContext.msg,\r\n        };\r\n        streamingMethod.protocolState.subscriptionsMap[key] = subscription;\r\n        this.session.sendFireAndForget({\r\n            type: \"accepted\",\r\n            subscription_id: key,\r\n            stream_id: streamId,\r\n        });\r\n        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        this.sendSubscriptionFailed(\"Subscription rejected by user. \" + reason, requestContext.msg.subscription_id);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = null;\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            return (branches === null || (Boolean(br) && typeof br.key === \"string\" && branches.indexOf(br.key) >= 0));\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        streamIdList.forEach(function (streamId) {\r\n            var publishMessage = {\r\n                type: \"publish\",\r\n                stream_id: streamId,\r\n                data: data,\r\n            };\r\n            _this.session.sendFireAndForget(publishMessage);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        var postMessage = {\r\n            type: \"post\",\r\n            subscription_id: subscription.id,\r\n            data: data,\r\n        };\r\n        this.session.sendFireAndForget(postMessage);\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n        var dropSubscriptionMessage = {\r\n            type: \"drop-subscription\",\r\n            subscription_id: subscription.id,\r\n            reason: \"Server dropping a single subscription\",\r\n        };\r\n        this.session.sendFireAndForget(dropSubscriptionMessage);\r\n        var subscriber = subscription.instance;\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.closeMultipleSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            return;\r\n        }\r\n        var subscriptionsToClose = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey === \"string\") {\r\n            subscriptionsToClose = subscriptionsToClose.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        subscriptionsToClose.forEach(function (subscription) {\r\n            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n            var drop = {\r\n                type: \"drop-subscription\",\r\n                subscription_id: subscription.id,\r\n                reason: \"Server dropping all subscriptions on stream_id: \" + subscription.streamId,\r\n            };\r\n            _this.session.sendFireAndForget(drop);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        var allSubscriptions = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = allSubscriptions;\r\n        }\r\n        else {\r\n            subscriptions = allSubscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var allSubscriptions = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        var keysWithDuplicates = allSubscriptions.map(function (sub) {\r\n            var result = null;\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                result = sub.branchKey;\r\n            }\r\n            return result;\r\n        });\r\n        var seen = [];\r\n        var branchArray = keysWithDuplicates.filter(function (bKey) {\r\n            if (bKey === null || seen.indexOf(bKey) >= 0) {\r\n                return false;\r\n            }\r\n            seen.push(bKey);\r\n            return true;\r\n        });\r\n        return branchArray;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);\r\n    };\r\n    ServerStreaming.prototype.handleRemoveInterest = function (msg) {\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (typeof msg.subscription_id !== \"string\" ||\r\n            typeof streamingMethod !== \"object\" ||\r\n            typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== \"object\") {\r\n            return;\r\n        }\r\n        var subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.onSubscriptionLifetimeEvent = function (eventName, handlerFunc) {\r\n        this.callbacks.add(eventName, handlerFunc);\r\n    };\r\n    ServerStreaming.prototype.getNextStreamId = function () {\r\n        return this.nextStreamId++ + \"\";\r\n    };\r\n    ServerStreaming.prototype.handleAddInterest = function (msg) {\r\n        var caller = this.repository.getServerById(msg.caller_id);\r\n        var instance = (typeof caller.getInfoForUser === \"function\") ? caller.getInfoForUser() : null;\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.arguments_kv || {},\r\n            instance: instance,\r\n        };\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (streamingMethod === undefined) {\r\n            var errorMsg = \"No method with id \" + msg.method_id + \" on this server.\";\r\n            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);\r\n            return;\r\n        }\r\n        if (streamingMethod.protocolState.subscriptionsMap &&\r\n            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {\r\n            this.sendSubscriptionFailed(\"A subscription with id \" + msg.subscription_id + \" already exists.\", msg.subscription_id);\r\n            return;\r\n        }\r\n        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.sendSubscriptionFailed = function (reason, subscriptionId) {\r\n        var errorMessage = {\r\n            type: \"error\",\r\n            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,\r\n            reason: reason,\r\n            request_id: subscriptionId,\r\n        };\r\n        this.session.sendFireAndForget(errorMessage);\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.getNextStreamId();\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=server-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/server-streaming.js\n// module id = 64\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar server_streaming_1 = require(\"./server-streaming\");\r\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(instance, session, clientRepository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.streaming = new server_streaming_1.default(instance, session, clientRepository, serverRepository, logger);\r\n        this.session.on(\"invoke\", function (msg) { return _this.handleInvokeMessage(msg); });\r\n    }\r\n    ServerProtocol.prototype.createStream = function (repoMethod, success, error) {\r\n        var isStreaming = true;\r\n        repoMethod.protocolState.subscriptionsMap = {};\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        this.register(repoMethod, success, error, isStreaming);\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, success, error, isStreaming) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDef, flags, registerMsg;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodDef = repoMethod.definition;\r\n                        repoMethod.protocolState.registrationCallbacks = {\r\n                            success: success,\r\n                            fail: error,\r\n                        };\r\n                        flags = { streaming: isStreaming || false };\r\n                        this.logger.debug('registering method \"' + methodDef.name + '\"');\r\n                        registerMsg = {\r\n                            type: \"register\",\r\n                            methods: [{\r\n                                    id: repoMethod.repoId,\r\n                                    name: methodDef.name,\r\n                                    display_name: methodDef.displayName,\r\n                                    description: methodDef.description,\r\n                                    version: methodDef.version,\r\n                                    flags: flags,\r\n                                    object_types: methodDef.objectTypes || methodDef.object_types,\r\n                                    input_signature: methodDef.accepts,\r\n                                    result_signature: methodDef.returns,\r\n                                    restrictions: undefined,\r\n                                }],\r\n                        };\r\n                        return [4, this.session.send(registerMsg, { methodId: repoMethod.repoId })\r\n                                .then(function (msg) { return _this.handleRegisteredMessage(msg); })\r\n                                .catch(function (err) { return _this.handleErrorRegister(err); })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (method, invocationId, err, result) {\r\n        var msg;\r\n        if (err) {\r\n            msg = {\r\n                type: \"error\",\r\n                request_id: invocationId,\r\n                reason_uri: \"agm.errors.client_error\",\r\n                reason: err,\r\n                context: result,\r\n                peer_id: undefined,\r\n            };\r\n        }\r\n        else {\r\n            msg = {\r\n                type: \"yield\",\r\n                invocation_id: invocationId,\r\n                peer_id: this.session.peerId,\r\n                result: result,\r\n                request_id: undefined,\r\n            };\r\n        }\r\n        this.session.sendFireAndForget(msg);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (method) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var msg;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        msg = {\r\n                            type: \"unregister\",\r\n                            methods: [method.repoId],\r\n                        };\r\n                        return [4, this.session.send(msg)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.getBranchList = function (method) {\r\n        return this.streaming.getBranchList(method);\r\n    };\r\n    ServerProtocol.prototype.getSubscriptionList = function (method, branchKey) {\r\n        return this.streaming.getSubscriptionList(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.closeAllSubscriptions = function (method, branchKey) {\r\n        this.streaming.closeMultipleSubscriptions(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.pushData = function (method, data, branches) {\r\n        this.streaming.pushData(method, data, branches);\r\n    };\r\n    ServerProtocol.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        this.streaming.pushDataToSingle(method, subscription, data);\r\n    };\r\n    ServerProtocol.prototype.closeSingleSubscription = function (method, subscription) {\r\n        this.streaming.closeSingleSubscription(method, subscription);\r\n    };\r\n    ServerProtocol.prototype.acceptRequestOnBranch = function (requestContext, method, branch) {\r\n        this.streaming.acceptRequestOnBranch(requestContext, method, branch);\r\n    };\r\n    ServerProtocol.prototype.rejectRequest = function (requestContext, method, reason) {\r\n        this.streaming.rejectRequest(requestContext, method, reason);\r\n    };\r\n    ServerProtocol.prototype.onSubRequest = function (callback) {\r\n        this.streaming.onSubRequest(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubAdded = function (callback) {\r\n        this.streaming.onSubAdded(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubRemoved = function (callback) {\r\n        this.streaming.onSubRemoved(callback);\r\n    };\r\n    ServerProtocol.prototype.handleRegisteredMessage = function (msg) {\r\n        var methodId = msg._tag.methodId;\r\n        var repoMethod = this.serverRepository.getById(methodId);\r\n        if (repoMethod && repoMethod.protocolState.registrationCallbacks) {\r\n            this.logger.debug(\"registered method \" + repoMethod.definition.name + \" with id \" + methodId);\r\n            repoMethod.protocolState.registrationCallbacks.success();\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleErrorRegister = function (msg) {\r\n        this.logger.warn(JSON.stringify(msg));\r\n        var methodId = msg._tag.methodId;\r\n        var repoMethod = this.serverRepository.getById(methodId);\r\n        if (repoMethod && repoMethod.protocolState.registrationCallbacks) {\r\n            this.logger.debug(\"failed to register method \" + repoMethod.definition.name + \" with id \" + methodId);\r\n            repoMethod.protocolState.registrationCallbacks.fail();\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleInvokeMessage = function (msg) {\r\n        var invocationId = msg.invocation_id;\r\n        var callerId = msg.caller_id;\r\n        var methodId = msg.method_id;\r\n        var args = msg.arguments_kv;\r\n        this.logger.debug('received invocation for method id \"' + methodId + '\" from peer ' + callerId);\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.repoId === methodId;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        var client = this.clientRepository.getServerById(callerId);\r\n        var invocationArgs = { args: args, instance: client.getInfoForUser() };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    return ServerProtocol;\r\n}());\r\nexports.default = ServerProtocol;\r\n//# sourceMappingURL=server.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/server.js\n// module id = 65\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = require(\"./subscription\");\r\nvar ServerBranch = (function () {\r\n    function ServerBranch(key, protocol, repoMethod) {\r\n        this.key = key;\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n    }\r\n    ServerBranch.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);\r\n        return subList.map(function (sub) {\r\n            return new subscription_1.default(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    ServerBranch.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);\r\n    };\r\n    ServerBranch.prototype.push = function (data) {\r\n        this.protocol.server.pushData(this.repoMethod, data, [this.key]);\r\n    };\r\n    return ServerBranch;\r\n}());\r\nexports.default = ServerBranch;\r\n//# sourceMappingURL=branch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/branch.js\n// module id = 66\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerRepository = (function () {\r\n    function ServerRepository() {\r\n        this.nextId = 0;\r\n        this.methods = [];\r\n    }\r\n    ServerRepository.prototype.add = function (method) {\r\n        if (typeof method !== \"object\") {\r\n            return;\r\n        }\r\n        if (method.repoId !== undefined) {\r\n            return;\r\n        }\r\n        method.repoId = String(this.nextId);\r\n        this.nextId += 1;\r\n        this.methods.push(method);\r\n        return method;\r\n    };\r\n    ServerRepository.prototype.remove = function (repoId) {\r\n        if (typeof repoId !== \"string\") {\r\n            return new TypeError(\"Expecting a string\");\r\n        }\r\n        this.methods = this.methods.filter(function (m) {\r\n            return m.repoId !== repoId;\r\n        });\r\n    };\r\n    ServerRepository.prototype.getById = function (id) {\r\n        if (typeof id !== \"string\") {\r\n            return undefined;\r\n        }\r\n        return this.methods.filter(function (m) {\r\n            return m.repoId === id;\r\n        })[0];\r\n    };\r\n    ServerRepository.prototype.getList = function () {\r\n        return this.methods.map(function (m) { return m; });\r\n    };\r\n    ServerRepository.prototype.length = function () {\r\n        return this.methods.length;\r\n    };\r\n    ServerRepository.prototype.reset = function () {\r\n        this.methods = [];\r\n    };\r\n    return ServerRepository;\r\n}());\r\nexports.default = ServerRepository;\r\n//# sourceMappingURL=repository.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/repository.js\n// module id = 67\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Request = (function () {\r\n    function Request(protocol, repoMethod, requestContext) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.requestContext = requestContext;\r\n        this.arguments = requestContext.arguments;\r\n        this.instance = requestContext.instance;\r\n    }\r\n    Request.prototype.accept = function () {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, \"\");\r\n    };\r\n    Request.prototype.acceptOnBranch = function (branch) {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);\r\n    };\r\n    Request.prototype.reject = function (reason) {\r\n        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);\r\n    };\r\n    return Request;\r\n}());\r\nexports.default = Request;\r\n//# sourceMappingURL=request.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/request.js\n// module id = 68\n// module chunks = 0","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar promisify_1 = require(\"../helpers/promisify\");\r\nvar streaming_1 = require(\"./streaming\");\r\nvar stream_1 = require(\"./stream\");\r\nvar Server = (function () {\r\n    function Server(protocol, serverRepository, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.serverRepository = serverRepository;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.invocations = 0;\r\n        this.streaming = new streaming_1.default(protocol, this);\r\n        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));\r\n    }\r\n    Server.prototype.register = function (methodDefinition, callback) {\r\n        if (methodDefinition === undefined) {\r\n            return Promise.reject(\"Please supply either a string of the Unique name or an object with property name\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be the callback function\");\r\n        }\r\n        var wrappedCallbackFunction = function (context, resultCallback) {\r\n            try {\r\n                var result = callback(context.args, context.instance);\r\n                resultCallback(null, result);\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, e);\r\n            }\r\n        };\r\n        wrappedCallbackFunction.userCallback = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallbackFunction);\r\n    };\r\n    Server.prototype.registerAsync = function (methodDefinition, callback) {\r\n        if (methodDefinition === undefined) {\r\n            return Promise.reject(\"Please supply either a string of the Unique name or an object with property name\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be the callback function\");\r\n        }\r\n        var wrappedCallback = function (context, resultCallback) {\r\n            try {\r\n                callback(context.args, context.instance, function (result) {\r\n                    resultCallback(null, result);\r\n                }, function (e) {\r\n                    resultCallback(e, e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, null);\r\n            }\r\n        };\r\n        wrappedCallback.userCallbackAsync = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallback);\r\n    };\r\n    Server.prototype.registerCore = function (method, theFunction) {\r\n        var _this = this;\r\n        var methodDefinition;\r\n        if (typeof method === \"string\") {\r\n            methodDefinition = { name: \"\" + method };\r\n        }\r\n        else {\r\n            methodDefinition = __assign({}, method);\r\n        }\r\n        var nameAlreadyExists = this.serverRepository.getList()\r\n            .some(function (serverMethod) { return serverMethod.definition.name === methodDefinition.name; });\r\n        if (nameAlreadyExists) {\r\n            return Promise.reject(\"Name already exists !\");\r\n        }\r\n        if (methodDefinition.supportsStreaming) {\r\n            return Promise.reject(\"supportsStreaming can not be true ! If you want to create a stream please use glue.agm.createStream\");\r\n        }\r\n        var repoMethod = this.serverRepository.add({\r\n            definition: methodDefinition,\r\n            theFunction: theFunction,\r\n            protocolState: {},\r\n        });\r\n        return this.protocol.server.register(repoMethod, function () {\r\n        }, function () {\r\n            _this.serverRepository.remove(repoMethod.repoId);\r\n        });\r\n    };\r\n    Server.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof streamDef === \"string\") {\r\n                if (streamDef === \"\") {\r\n                    reject(\"Invalid stream name - can not be empty\");\r\n                }\r\n                streamDef = { name: streamDef };\r\n            }\r\n            streamDef.supportsStreaming = true;\r\n            if (!callbacks) {\r\n                callbacks = {};\r\n            }\r\n            if (typeof callbacks.subscriptionRequestHandler !== \"function\") {\r\n                callbacks.subscriptionRequestHandler = function (request) {\r\n                    request.accept();\r\n                };\r\n            }\r\n            var repoMethod = {\r\n                definition: streamDef,\r\n                streamCallbacks: callbacks,\r\n                protocolState: {},\r\n            };\r\n            _this.serverRepository.add(repoMethod);\r\n            _this.protocol.server.createStream(repoMethod, function () {\r\n                var streamFrontObject = new stream_1.default(_this.protocol, repoMethod, _this);\r\n                repoMethod.stream = streamFrontObject;\r\n                resolve(streamFrontObject);\r\n            }, function (err) {\r\n                _this.serverRepository.remove(repoMethod.repoId);\r\n                reject(err);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    Server.prototype.unregister = function (methodFilter, forStream) {\r\n        if (forStream === void 0) { forStream = false; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDefinition, methodToBeRemoved;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (methodFilter === undefined) {\r\n                            return [2, Promise.reject(\"Please supply either a string of the Unique name or an object with property name\")];\r\n                        }\r\n                        if (!(typeof methodFilter === \"function\")) return [3, 2];\r\n                        return [4, this.unregisterWithPredicate(methodFilter, forStream)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                    case 2:\r\n                        if (typeof methodFilter === \"string\") {\r\n                            methodDefinition = { name: methodFilter };\r\n                        }\r\n                        else {\r\n                            methodDefinition = methodFilter;\r\n                        }\r\n                        if (methodDefinition.name === undefined) {\r\n                            return [2, Promise.reject(\"Method with undefined name does not exist !\")];\r\n                        }\r\n                        methodToBeRemoved = this.serverRepository.getList().find(function (serverMethod) {\r\n                            return serverMethod.definition.name === methodDefinition.name\r\n                                && (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodToBeRemoved) {\r\n                            return [2, Promise.reject(\"Method does not exist or it is not registered by your application !\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams([methodToBeRemoved])];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.unregisterWithPredicate = function (filterPredicate, forStream) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodsOrStreamsToRemove;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodsOrStreamsToRemove = this.serverRepository.getList()\r\n                            .filter(function (sm) { return filterPredicate(sm.definition); })\r\n                            .filter(function (serverMethod) {\r\n                            return (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {\r\n                            return [2, Promise.reject(\"No \" + (forStream ? \"stream\" : \"method\") + \" matches the condition !\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams(methodsOrStreamsToRemove)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.removeMethodsOrStreams = function (methodsToRemove) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, Promise.all(methodsToRemove.map(function (method) { return __awaiter(_this, void 0, void 0, function () {\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0: return [4, this.protocol.server.unregister(method)];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        this.serverRepository.remove(method.repoId);\r\n                                        return [2];\r\n                                }\r\n                            });\r\n                        }); }))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.containsProps = function (filter, methodDefinition) {\r\n        var filterProps = Object.keys(filter)\r\n            .filter(function (prop) {\r\n            return typeof filter[prop] !== \"function\"\r\n                && prop !== \"object_types\"\r\n                && prop !== \"display_name\";\r\n        });\r\n        var methodDefProps = Object.keys(methodDefinition);\r\n        var uniqProps = Array.from(new Set(filterProps.concat(methodDefProps)));\r\n        return uniqProps.reduce(function (isMatch, prop) {\r\n            var filterValue = filter[prop];\r\n            var methodDefValue = methodDefinition[prop];\r\n            if (prop === \"supportsStreaming\") {\r\n                methodDefValue = methodDefValue || false;\r\n                filterValue = filterValue || false;\r\n            }\r\n            if (prop === \"objectTypes\" && filterValue !== undefined && methodDefValue !== undefined) {\r\n                if (filterValue.length !== methodDefValue.length) {\r\n                    isMatch = false;\r\n                }\r\n                else {\r\n                    var firstObjType = filterValue.sort();\r\n                    var secondObjTypes_1 = methodDefValue.sort();\r\n                    var hasADifference = firstObjType.some(function (objType, index) { return objType !== secondObjTypes_1[index]; });\r\n                    if (hasADifference) {\r\n                        isMatch = false;\r\n                    }\r\n                }\r\n            }\r\n            else if (filterValue !== methodDefValue) {\r\n                isMatch = false;\r\n            }\r\n            return isMatch;\r\n        }, true);\r\n    };\r\n    Server.prototype.onMethodInvoked = function (methodToExecute, invocationId, invocationArgs) {\r\n        var _this = this;\r\n        if (!methodToExecute) {\r\n            return;\r\n        }\r\n        methodToExecute.theFunction(invocationArgs, function (err, result) {\r\n            if (err) {\r\n                if (typeof err.message === \"string\") {\r\n                    err = err.message;\r\n                }\r\n                else if (typeof err !== \"string\") {\r\n                    try {\r\n                        err = JSON.stringify(err);\r\n                    }\r\n                    catch (unStrException) {\r\n                        err = \"un-stringifyable error in onMethodInvoked ! Top level prop names: \" + Object.keys(err);\r\n                    }\r\n                }\r\n            }\r\n            if (!result || typeof result !== \"object\" || result.constructor === Array) {\r\n                result = { _result: result };\r\n            }\r\n            _this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);\r\n        });\r\n    };\r\n    return Server;\r\n}());\r\nexports.default = Server;\r\n//# sourceMappingURL=server.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/server.js\n// module id = 69\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = require(\"./subscription\");\r\nvar branch_1 = require(\"./branch\");\r\nvar ServerStream = (function () {\r\n    function ServerStream(protocol, repoMethod, server) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.server = server;\r\n        this.def = repoMethod.definition;\r\n    }\r\n    Object.defineProperty(ServerStream.prototype, \"name\", {\r\n        get: function () { return this.def.name; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.branches = function (key) {\r\n        var _this = this;\r\n        var bList = this.protocol.server.getBranchList(this.repoMethod);\r\n        if (key) {\r\n            if (bList.indexOf(key) > -1) {\r\n                return new branch_1.default(key, this.protocol, this.repoMethod);\r\n            }\r\n            return undefined;\r\n        }\r\n        else {\r\n            return bList.map(function (branchKey) {\r\n                return new branch_1.default(branchKey, _this.protocol, _this.repoMethod);\r\n            });\r\n        }\r\n    };\r\n    ServerStream.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod);\r\n        return subList.map(function (sub) {\r\n            return new subscription_1.default(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    Object.defineProperty(ServerStream.prototype, \"definition\", {\r\n        get: function () {\r\n            var def2 = this.def;\r\n            return {\r\n                accepts: def2.accepts,\r\n                description: def2.description,\r\n                displayName: def2.displayName,\r\n                name: def2.name,\r\n                objectTypes: def2.objectTypes,\r\n                returns: def2.returns,\r\n                supportsStreaming: def2.supportsStreaming,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod);\r\n        this.server.unregister(this.repoMethod.definition, true);\r\n    };\r\n    ServerStream.prototype.push = function (data, branches) {\r\n        if (typeof branches !== \"string\" && !Array.isArray(branches) && branches !== undefined) {\r\n            throw new Error(\"invalid branches should be string or string array\");\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this.protocol.server.pushData(this.repoMethod, data, branches);\r\n    };\r\n    return ServerStream;\r\n}());\r\nexports.default = ServerStream;\r\n//# sourceMappingURL=stream.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/stream.js\n// module id = 70\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = require(\"./subscription\");\r\nvar request_1 = require(\"./request\");\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(protocol, server) {\r\n        var _this = this;\r\n        this.protocol = protocol;\r\n        this.server = server;\r\n        protocol.server.onSubRequest(function (rc, rm) { return _this.handleSubRequest(rc, rm); });\r\n        protocol.server.onSubAdded(function (sub, rm) { return _this.handleSubAdded(sub, rm); });\r\n        protocol.server.onSubRemoved(function (sub, rm) { return _this.handleSubRemoved(sub, rm); });\r\n    }\r\n    ServerStreaming.prototype.handleSubRequest = function (requestContext, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var request = new request_1.default(this.protocol, repoMethod, requestContext);\r\n        repoMethod.streamCallbacks.subscriptionRequestHandler(request);\r\n    };\r\n    ServerStreaming.prototype.handleSubAdded = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new subscription_1.default(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);\r\n    };\r\n    ServerStreaming.prototype.handleSubRemoved = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new subscription_1.default(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/streaming.js\n// module id = 71\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar protocol_1 = require(\"./protocol\");\r\nvar successMessages = ['subscribed', 'success'];\r\nexports.default = (function (configuration) {\r\n    var connection = configuration.connection, logger = configuration.logger;\r\n    var session = connection.domain('bus', logger, successMessages);\r\n    return new Promise(function (resolve, reject) {\r\n        session.join()\r\n            .then(function () {\r\n            var protocol = protocol_1.default(connection, logger, session);\r\n            resolve(protocol);\r\n        })\r\n            .catch(reject);\r\n    });\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/bus/main.js\n// module id = 72\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = require(\"./utils\");\r\n;\r\nvar Protocol = (function () {\r\n    function Protocol(connection, logger, session) {\r\n        var _this = this;\r\n        this.publish = function (topic, data, options) {\r\n            var _a = options || {}, _b = _a.routingKey, routingKey = _b === void 0 ? undefined : _b, _c = _a.target, target = _c === void 0 ? undefined : _c;\r\n            var args = utils_1.removeEmptyValues({\r\n                type: 'publish',\r\n                topic: topic,\r\n                data: data,\r\n                peer_id: _this.peerId,\r\n                routing_key: routingKey,\r\n                target_identity: target\r\n            });\r\n            _this.session.send(args);\r\n        };\r\n        this.subscribe = function (topic, callback, options) {\r\n            return new Promise(function (resolve, reject) {\r\n                var _a = options || {}, _b = _a.routingKey, routingKey = _b === void 0 ? undefined : _b, _c = _a.target, target = _c === void 0 ? undefined : _c;\r\n                var args = utils_1.removeEmptyValues({\r\n                    type: 'subscribe',\r\n                    topic: topic,\r\n                    peer_id: _this.peerId,\r\n                    routing_key: routingKey,\r\n                    source: target\r\n                });\r\n                _this.session.send(args)\r\n                    .then(function (response) {\r\n                    var subscription_id = response.subscription_id;\r\n                    _this.subscriptions.push({ subscription_id: subscription_id, topic: topic, callback: callback, source: target });\r\n                    resolve({\r\n                        unsubscribe: function () {\r\n                            _this.session.send({ type: 'unsubscribe', subscription_id: subscription_id, peer_id: _this.peerId });\r\n                            _this.subscriptions = _this.subscriptions.filter(function (s) { return s.subscription_id !== subscription_id; });\r\n                            return Promise.resolve();\r\n                        }\r\n                    });\r\n                })\r\n                    .catch(function (error) { return reject(error); });\r\n            });\r\n        };\r\n        this.watchOnEvent = function () {\r\n            _this.session.on('event', function (args) {\r\n                var data = args.data, subscription_id = args.subscription_id;\r\n                var source = args['publisher-identity'];\r\n                var subscription = _this.subscriptions.find(function (s) { return s.subscription_id === subscription_id; });\r\n                if (subscription) {\r\n                    if (!subscription.source) {\r\n                        subscription.callback(data, subscription.topic, source);\r\n                    }\r\n                    else {\r\n                        if (utils_1.keysMatch(subscription.source, source)) {\r\n                            subscription.callback(data, subscription.topic, source);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        this.connection = connection;\r\n        this.logger = logger;\r\n        this.session = session;\r\n        this.peerId = connection.peerId;\r\n        this.subscriptions = [];\r\n    }\r\n    return Protocol;\r\n}());\r\nfunction default_1(connection, logger, session) {\r\n    var protocol = new Protocol(connection, logger, session);\r\n    protocol.watchOnEvent();\r\n    return protocol;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=protocol.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/bus/protocol.js\n// module id = 73\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction removeEmptyValues(obj) {\r\n    var cleaned = {};\r\n    Object.keys(obj).forEach(function (key) {\r\n        if (obj[key] !== undefined && obj[key] !== null) {\r\n            cleaned[key] = obj[key];\r\n        }\r\n    });\r\n    return cleaned;\r\n}\r\nexports.removeEmptyValues = removeEmptyValues;\r\nfunction keysMatch(obj1, obj2) {\r\n    var keysObj1 = Object.keys(obj1);\r\n    var allMatch = true;\r\n    keysObj1.forEach(function (key) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            allMatch = false;\r\n        }\r\n    });\r\n    return allMatch;\r\n}\r\nexports.keysMatch = keysMatch;\r\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/bus/utils.js\n// module id = 74\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar shortid_1 = require(\"shortid\");\r\nvar utils_1 = require(\"./utils\");\r\nvar contextMessageReplaySpec_1 = require(\"./contexts/contextMessageReplaySpec\");\r\nvar pjson = require(\"../package.json\");\r\nfunction default_1(configuration, ext, hc, glue42gd, gdVersion) {\r\n    if (typeof window !== \"undefined\") {\r\n        global = global || window;\r\n    }\r\n    global = global || {};\r\n    var uid = shortid_1.generate();\r\n    var masterConfig = global.GLUE_CONFIG || {};\r\n    var dynamicDefaults = global.GLUE_DEFAULT_CONFIG || {};\r\n    var hardDefaults = getHardDefaults();\r\n    var metricsIdentity = {\r\n        system: getConfigProp(\"metrics\", \"system\"),\r\n        service: getConfigProp(\"metrics\", \"service\"),\r\n        instance: getConfigProp(\"metrics\", \"instance\")\r\n    };\r\n    function getMetrics() {\r\n        return ifNotFalse(getConfigProp(\"metrics\"), {\r\n            identity: metricsIdentity\r\n        });\r\n    }\r\n    function getGateway() {\r\n        var force = getConfigProp(\"gateway\", \"force\");\r\n        var gw = hc === undefined || force;\r\n        if (gw) {\r\n            var gwConfig = getConfigProp(\"gateway\");\r\n            var protocolVersion = getConfigProp(\"gateway\", \"protocolVersion\");\r\n            var reconnectInterval = getConfigProp(\"gateway\", \"reconnectInterval\");\r\n            var reconnectAttempts = getConfigProp(\"gateway\", \"reconnectAttempts\");\r\n            var ws = gwConfig.ws;\r\n            var http = gwConfig.http;\r\n            var inproc = gwConfig.inproc;\r\n            if (!ws && !http && !inproc) {\r\n                if (utils_1.default.isNode() || (\"WebSocket\" in window && window.WebSocket.CLOSING === 2)) {\r\n                    ws = getConfigProp(\"gateway\", \"ws\");\r\n                }\r\n                else {\r\n                    http = getConfigProp(\"gateway\", \"http\");\r\n                }\r\n            }\r\n            var windowId = void 0;\r\n            var pid = void 0;\r\n            if (hc) {\r\n                windowId = hc.windowId;\r\n            }\r\n            else if (typeof glue42gd !== \"undefined\") {\r\n                windowId = glue42gd.windowId;\r\n                pid = glue42gd.pid;\r\n            }\r\n            else if (utils_1.default.isNode()) {\r\n                pid = process.pid;\r\n            }\r\n            var replaySpecs = getConfigProp(\"gateway\", \"replaySpecs\") || [];\r\n            replaySpecs.push(contextMessageReplaySpec_1.ContextMessageReplaySpec);\r\n            return {\r\n                identity: {\r\n                    application: getApplication(),\r\n                    windowId: windowId,\r\n                    process: pid,\r\n                },\r\n                reconnectInterval: reconnectInterval,\r\n                ws: ws,\r\n                http: http,\r\n                gw: inproc,\r\n                protocolVersion: protocolVersion,\r\n                reconnectAttempts: reconnectAttempts,\r\n                force: true,\r\n                replaySpecs: replaySpecs,\r\n                gdVersion: gdVersion,\r\n            };\r\n        }\r\n        return { gdVersion: gdVersion };\r\n    }\r\n    function getLogger() {\r\n        return getConfigProp(\"logger\");\r\n    }\r\n    function getAgm() {\r\n        return ifNotFalse(configuration.agm, {\r\n            instance: {\r\n                application: getApplication()\r\n            }\r\n        });\r\n    }\r\n    function getContexts(connectionConfig) {\r\n        if (connectionConfig.protocolVersion < 3) {\r\n            return false;\r\n        }\r\n        var contextConfig = getConfigProp(\"contexts\");\r\n        if (typeof contextConfig === \"boolean\" && !contextConfig) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function getChannels(contextsEnabled) {\r\n        if (!contextsEnabled) {\r\n            return false;\r\n        }\r\n        var channelsConfig = getConfigProp(\"channels\");\r\n        if (typeof channelsConfig === \"boolean\" && !channelsConfig) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function getBus(connectionConfig) {\r\n        var contextConfig = getConfigProp(\"bus\");\r\n        if (typeof contextConfig === \"boolean\" && contextConfig) {\r\n            if (connectionConfig.protocolVersion && connectionConfig.protocolVersion < 3) {\r\n                return false;\r\n            }\r\n            if (gdVersion === 2) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getApplication() {\r\n        return getConfigProp(\"application\");\r\n    }\r\n    function getAuth() {\r\n        return getConfigProp(\"auth\");\r\n    }\r\n    function getHardDefaults() {\r\n        function getMetricsDefaults() {\r\n            var documentTitle = typeof document !== \"undefined\" ? document.title : \"unknown\";\r\n            documentTitle = documentTitle || \"none\";\r\n            if (typeof hc === \"undefined\") {\r\n                return {\r\n                    system: \"Connect.Browser\",\r\n                    service: configuration.application || documentTitle,\r\n                    instance: \"~\" + uid\r\n                };\r\n            }\r\n            if (typeof hc.metricsFacade.getIdentity !== \"undefined\") {\r\n                var identity = hc.metricsFacade.getIdentity();\r\n                return {\r\n                    system: identity.system,\r\n                    service: identity.service,\r\n                    instance: identity.instance\r\n                };\r\n            }\r\n            return {\r\n                system: \"HtmlContainer.\" + hc.containerName,\r\n                service: \"JS.\" + hc.browserWindowName,\r\n                instance: \"~\" + hc.machineName\r\n            };\r\n        }\r\n        function getGatewayDefaults() {\r\n            var defaultProtocol = 3;\r\n            var gatewayURL = \"localhost:8385\";\r\n            var defaultWs = \"ws://\" + gatewayURL;\r\n            var defaultHttp = \"http://\" + gatewayURL;\r\n            if (glue42gd) {\r\n                defaultProtocol = 3;\r\n                defaultWs = glue42gd.gwURL;\r\n            }\r\n            return {\r\n                ws: defaultWs,\r\n                http: defaultHttp,\r\n                protocolVersion: defaultProtocol,\r\n                reconnectInterval: 1000\r\n            };\r\n        }\r\n        function getDefaultApplicationName() {\r\n            if (hc) {\r\n                return hc.containerName + \".\" + hc.browserWindowName;\r\n            }\r\n            if (glue42gd) {\r\n                return glue42gd.appName;\r\n            }\r\n            if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n                return (window.agm_application || document.title) + uid;\r\n            }\r\n            else {\r\n                return \"NodeJS\" + uid;\r\n            }\r\n        }\r\n        function getDefaultLogger() {\r\n            return {\r\n                publish: \"off\",\r\n                console: \"info\",\r\n                metrics: \"off\",\r\n            };\r\n        }\r\n        return {\r\n            application: getDefaultApplicationName(),\r\n            metrics: getMetricsDefaults(),\r\n            agm: {},\r\n            gateway: getGatewayDefaults(),\r\n            logger: getDefaultLogger(),\r\n            bus: false\r\n        };\r\n    }\r\n    function getConfigProp(prop1, prop2) {\r\n        var masterConfigProp1 = masterConfig[prop1];\r\n        var userProp1 = configuration[prop1];\r\n        var dynamicDefaultsProp1 = dynamicDefaults[prop1];\r\n        var hardDefaultsProp1 = hardDefaults[prop1];\r\n        if (prop2) {\r\n            if (masterConfigProp1 && masterConfigProp1[prop2] !== undefined) {\r\n                return masterConfigProp1[prop2];\r\n            }\r\n            if (userProp1 && userProp1[prop2] !== undefined) {\r\n                return userProp1[prop2];\r\n            }\r\n            if (dynamicDefaultsProp1 && dynamicDefaultsProp1[prop2] !== undefined) {\r\n                return dynamicDefaultsProp1[prop2];\r\n            }\r\n            if (hardDefaultsProp1 && hardDefaultsProp1[prop2] !== undefined) {\r\n                return hardDefaultsProp1[prop2];\r\n            }\r\n        }\r\n        else {\r\n            if (masterConfigProp1 !== undefined) {\r\n                return masterConfigProp1;\r\n            }\r\n            if (userProp1 !== undefined) {\r\n                return userProp1;\r\n            }\r\n            if (dynamicDefaultsProp1 !== undefined) {\r\n                return dynamicDefaultsProp1;\r\n            }\r\n            if (hardDefaultsProp1 !== undefined) {\r\n                return hardDefaultsProp1;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    function ifNotFalse(what, then) {\r\n        if (typeof what === \"boolean\" && !what) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return then;\r\n        }\r\n    }\r\n    var connection = getGateway();\r\n    var contexts = getContexts(connection);\r\n    var channels = getChannels(contexts);\r\n    var bus = getBus(connection);\r\n    return {\r\n        bus: bus,\r\n        identity: metricsIdentity,\r\n        application: getApplication(),\r\n        auth: getAuth(),\r\n        logger: getLogger(),\r\n        connection: connection,\r\n        metrics: getMetrics(),\r\n        agm: getAgm(),\r\n        contexts: contexts,\r\n        channels: channels,\r\n        version: ext.version || pjson.version,\r\n        libs: ext.libs\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=config.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/config.js\n// module id = 75\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection_1 = require(\"./connection\");\r\nvar messageReplayer_1 = require(\"./messageReplayer\");\r\nvar GW3ConnectionImpl = (function (_super) {\r\n    __extends(GW3ConnectionImpl, _super);\r\n    function GW3ConnectionImpl(settings) {\r\n        var _this = _super.call(this, settings) || this;\r\n        if (settings.replaySpecs &&\r\n            settings.replaySpecs.length) {\r\n            _this.replayer = new messageReplayer_1.MessageReplayerImpl(settings.replaySpecs);\r\n        }\r\n        return _this;\r\n    }\r\n    GW3ConnectionImpl.prototype.init = function (transport, protocol) {\r\n        _super.prototype.init.call(this, transport, protocol);\r\n        if (this.replayer) {\r\n            this.replayer.init(this);\r\n        }\r\n        this.gw3Protocol = protocol;\r\n    };\r\n    GW3ConnectionImpl.prototype.toAPI = function () {\r\n        var that = this;\r\n        var superAPI = _super.prototype.toAPI.call(this);\r\n        return {\r\n            domain: that.domain.bind(that),\r\n            get peerId() { return that.peerId; },\r\n            get token() { return that.token; },\r\n            get info() { return that.info; },\r\n            get resolvedIdentity() { return that.resolvedIdentity; },\r\n            get availableDomains() { return that.availableDomains; },\r\n            get gatewayToken() { return that.gatewayToken; },\r\n            get replayer() { return that.replayer; },\r\n            on: superAPI.on,\r\n            send: superAPI.send,\r\n            off: superAPI.off,\r\n            login: superAPI.login,\r\n            logout: superAPI.logout,\r\n            loggedIn: superAPI.loggedIn,\r\n            connected: superAPI.connected,\r\n            disconnected: superAPI.disconnected,\r\n            authToken: that.authToken.bind(that),\r\n            get protocolVersion() { return superAPI.protocolVersion; },\r\n        };\r\n    };\r\n    GW3ConnectionImpl.prototype.domain = function (domain, logger, successMessages, errorMessages) {\r\n        return this.gw3Protocol.domain(domain, logger, successMessages, errorMessages);\r\n    };\r\n    GW3ConnectionImpl.prototype.authToken = function () {\r\n        return this.gw3Protocol.authToken();\r\n    };\r\n    return GW3ConnectionImpl;\r\n}(connection_1.default));\r\nexports.default = GW3ConnectionImpl;\r\n//# sourceMappingURL=gw3Connection.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/gw3Connection.js\n// module id = 76\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection_1 = require(\"./connection\");\r\nvar gw3_1 = require(\"./protocols/gw3\");\r\nvar hc_1 = require(\"./protocols/hc\");\r\nvar ws_1 = require(\"./transports/ws\");\r\nvar gw3Connection_1 = require(\"./gw3Connection\");\r\nvar gw1_1 = require(\"./protocols/gw1\");\r\nvar hc_2 = require(\"./transports/hc\");\r\nvar inproc_1 = require(\"./transports/inproc\");\r\nexports.default = (function (settings) {\r\n    settings = settings || {};\r\n    settings.reconnectAttempts = settings.reconnectAttempts || 10;\r\n    settings.reconnectInterval = settings.reconnectInterval || 500;\r\n    var connection = new connection_1.default(settings);\r\n    var logger = settings.logger;\r\n    if (!logger) {\r\n        throw new Error(\"please pass a logger object\");\r\n    }\r\n    var protocol = new hc_1.default();\r\n    var transport = new hc_2.default();\r\n    var outsideHC = settings.gdVersion !== 2 || settings.force;\r\n    if (outsideHC) {\r\n        if (settings.gw && settings.gw.facade && settings.gw.token && settings.protocolVersion === 3) {\r\n            transport = new inproc_1.default(settings.gw.token, settings.gw.facade, logger.subLogger(\"inproc\"));\r\n        }\r\n        else if (settings.ws !== undefined) {\r\n            transport = new ws_1.default(settings, logger.subLogger(\"ws\"));\r\n        }\r\n        else {\r\n            throw new Error(\"No connection information specified\");\r\n        }\r\n        if (settings.protocolVersion === 3) {\r\n            var gw3Connection = new gw3Connection_1.default(settings);\r\n            var gw3Port = gw3_1.default(gw3Connection, settings, logger.subLogger(\"gw3\"));\r\n            gw3Connection.init(transport, gw3Port);\r\n            return gw3Connection.toAPI();\r\n        }\r\n        else {\r\n            protocol = new gw1_1.default(connection, settings);\r\n        }\r\n    }\r\n    connection.init(transport, protocol);\r\n    return connection.toAPI();\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/main.js\n// module id = 77\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar MessageReplayerImpl = (function () {\r\n    function MessageReplayerImpl(specs) {\r\n        this.specsNames = [];\r\n        this.messages = {};\r\n        this.subs = {};\r\n        this.subsRefCount = {};\r\n        this.specs = {};\r\n        for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\r\n            var spec = specs_1[_i];\r\n            this.specs[spec.name] = spec;\r\n            this.specsNames.push(spec.name);\r\n        }\r\n    }\r\n    MessageReplayerImpl.prototype.init = function (connection) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var _loop_1 = function (type) {\r\n                var refCount = this_1.subsRefCount[type];\r\n                if (!refCount) {\r\n                    refCount = 0;\r\n                }\r\n                refCount += 1;\r\n                this_1.subsRefCount[type] = refCount;\r\n                if (refCount > 1) {\r\n                    return \"continue\";\r\n                }\r\n                var sub = connection.on(\"glue-core\", type, function (msg) { return _this.processMessage(type, msg); });\r\n                this_1.subs[type] = sub;\r\n            };\r\n            var this_1 = this;\r\n            for (var _b = 0, _c = this.specs[name_1].types; _b < _c.length; _b++) {\r\n                var type = _c[_b];\r\n                _loop_1(type);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.processMessage = function (type, msg) {\r\n        if (this.isDone || !msg) {\r\n            return;\r\n        }\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_2 = _a[_i];\r\n            if (this.specs[name_2].types.indexOf(type) !== -1) {\r\n                var messages = this.messages[name_2] || [];\r\n                this.messages[name_2] = messages;\r\n                messages.push(msg);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.drain = function (name, callback) {\r\n        if (callback) {\r\n            (this.messages[name] || []).forEach(callback);\r\n        }\r\n        delete this.messages[name];\r\n        for (var _i = 0, _a = this.specs[name].types; _i < _a.length; _i++) {\r\n            var type = _a[_i];\r\n            this.subsRefCount[type] -= 1;\r\n            if (this.subsRefCount[type] <= 0) {\r\n                this.connection.off(this.subs[type]);\r\n                delete this.subs[type];\r\n                delete this.subsRefCount[type];\r\n            }\r\n        }\r\n        delete this.specs[name];\r\n        if (!this.specs.length) {\r\n            this.isDone = true;\r\n        }\r\n    };\r\n    return MessageReplayerImpl;\r\n}());\r\nexports.MessageReplayerImpl = MessageReplayerImpl;\r\n//# sourceMappingURL=messageReplayer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/messageReplayer.js\n// module id = 78\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GW1Protocol = (function () {\r\n    function GW1Protocol(connection, settings) {\r\n        this._connection = connection;\r\n        this._settings = settings;\r\n    }\r\n    GW1Protocol.prototype.processStringMessage = function (message) {\r\n        var messageObj = JSON.parse(message);\r\n        return {\r\n            msg: messageObj.message,\r\n            msgType: messageObj.type,\r\n        };\r\n    };\r\n    GW1Protocol.prototype.createStringMessage = function (product, type, message, id) {\r\n        return JSON.stringify({\r\n            type: type,\r\n            message: message,\r\n            id: id,\r\n        });\r\n    };\r\n    GW1Protocol.prototype.login = function (message) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var sendOptions = {\r\n                retryInterval: _this._settings.reconnectInterval,\r\n                maxRetries: _this._settings.reconnectAttempts\r\n            };\r\n            _this._connection.send(\"hello\", \"hello\", {}, null, sendOptions)\r\n                .then(function () { return resolve({ application: undefined }); })\r\n                .catch(reject);\r\n        });\r\n    };\r\n    GW1Protocol.prototype.logout = function () {\r\n    };\r\n    GW1Protocol.prototype.loggedIn = function (callback) {\r\n        callback();\r\n        return function () {\r\n        };\r\n    };\r\n    GW1Protocol.prototype.processObjectMessage = function (message) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    GW1Protocol.prototype.createObjectMessage = function (product, type, message, id) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    return GW1Protocol;\r\n}());\r\nexports.default = GW1Protocol;\r\n//# sourceMappingURL=gw1.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/gw1.js\n// module id = 79\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3Domain_1 = require(\"./gw3Domain\");\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nfunction default_1(connection, settings, logger) {\r\n    var datePrefix = \"#T42_DATE#\";\r\n    var datePrefixLen = datePrefix.length;\r\n    var dateMinLen = datePrefixLen + 1;\r\n    var datePrefixFirstChar = datePrefix[0];\r\n    var registry = callback_registry_1.default();\r\n    var globalDomain;\r\n    var isLoggedIn = false;\r\n    var shouldTryLogin = true;\r\n    var initialLogin = true;\r\n    var initialLoginAttempts = 3;\r\n    var initialLoginAttemptsInterval = 500;\r\n    var pingTimer;\r\n    var sessions = [];\r\n    var loginConfig;\r\n    connection.disconnected(handleDisconnected.bind(this));\r\n    ping();\r\n    function processStringMessage(message) {\r\n        var msg = JSON.parse(message, function (key, value) {\r\n            if (typeof value !== \"string\") {\r\n                return value;\r\n            }\r\n            if (value.length < dateMinLen) {\r\n                return value;\r\n            }\r\n            if (value[0] !== datePrefixFirstChar) {\r\n                return value;\r\n            }\r\n            if (value.substring(0, datePrefixLen) !== datePrefix) {\r\n                return value;\r\n            }\r\n            try {\r\n                var milliseconds = parseInt(value.substring(datePrefixLen, value.length), 10);\r\n                if (isNaN(milliseconds)) {\r\n                    return value;\r\n                }\r\n                return new Date(milliseconds);\r\n            }\r\n            catch (ex) {\r\n                return value;\r\n            }\r\n        });\r\n        return {\r\n            msg: msg,\r\n            msgType: msg.type,\r\n        };\r\n    }\r\n    function createStringMessage(product, type, message, id) {\r\n        var oldToJson = Date.prototype.toJSON;\r\n        try {\r\n            Date.prototype.toJSON = function () {\r\n                return datePrefix + this.getTime();\r\n            };\r\n            var result = JSON.stringify(message);\r\n            return result;\r\n        }\r\n        finally {\r\n            Date.prototype.toJSON = oldToJson;\r\n        }\r\n    }\r\n    function processObjectMessage(message) {\r\n        if (!message.type) {\r\n            throw new Error(\"Object should have type property\");\r\n        }\r\n        return {\r\n            msg: message,\r\n            msgType: message.type,\r\n        };\r\n    }\r\n    function createObjectMessage(product, type, message, id) {\r\n        return message;\r\n    }\r\n    function login(config) {\r\n        logger.debug(\"logging in...\");\r\n        loginConfig = config;\r\n        if (!loginConfig) {\r\n            loginConfig = { username: \"\", password: \"\" };\r\n        }\r\n        shouldTryLogin = true;\r\n        return new Promise(function (resolve, reject) {\r\n            var authentication = {};\r\n            connection.gatewayToken = config.gatewayToken;\r\n            if (connection.gatewayToken) {\r\n                authentication.method = \"gateway-token\";\r\n                authentication.token = connection.gatewayToken;\r\n            }\r\n            else if (config.token) {\r\n                authentication.method = \"access-token\";\r\n                authentication.token = config.token;\r\n            }\r\n            else if (config.username) {\r\n                authentication.method = \"secret\";\r\n                authentication.login = config.username;\r\n                authentication.secret = config.password;\r\n            }\r\n            else {\r\n                throw new Error(\"invalid auth message\" + JSON.stringify(config));\r\n            }\r\n            var helloMsg = {\r\n                type: \"hello\",\r\n                identity: settings.identity,\r\n                authentication: authentication,\r\n            };\r\n            globalDomain = gw3Domain_1.default(\"global\", connection, logger, [\r\n                \"welcome\",\r\n                \"token\"\r\n            ]);\r\n            var sendOptions = { skipPeerId: true };\r\n            if (initialLogin) {\r\n                sendOptions.retryInterval = settings.reconnectInterval;\r\n                sendOptions.maxRetries = settings.reconnectAttempts;\r\n            }\r\n            globalDomain.send(helloMsg, undefined, sendOptions)\r\n                .then(function (msg) {\r\n                initialLogin = false;\r\n                logger.debug(\"login successful with PeerId \" + msg.peer_id);\r\n                connection.peerId = msg.peer_id;\r\n                connection.resolvedIdentity = msg.resolved_identity;\r\n                connection.availableDomains = msg.available_domains;\r\n                if (msg.options) {\r\n                    connection.token = msg.options.access_token;\r\n                    connection.info = msg.options.info;\r\n                }\r\n                setLoggedIn(true);\r\n                resolve(msg.resolved_identity);\r\n            })\r\n                .catch(function (err) {\r\n                logger.error(\"error sending hello message - \" + err);\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function logout() {\r\n        logger.debug(\"logging out...\");\r\n        shouldTryLogin = false;\r\n        if (pingTimer) {\r\n            clearTimeout(pingTimer);\r\n        }\r\n        sessions.forEach(function (session) {\r\n            session.leave();\r\n        });\r\n    }\r\n    function loggedIn(callback) {\r\n        if (isLoggedIn) {\r\n            callback();\r\n        }\r\n        return registry.add(\"onLoggedIn\", callback);\r\n    }\r\n    function domain(domainName, domainLogger, successMessages, errorMessages) {\r\n        var session = sessions.filter(function (s) { return s.domain === domainName; })[0];\r\n        if (!session) {\r\n            session = gw3Domain_1.default(domainName, connection, domainLogger, successMessages, errorMessages);\r\n            sessions.push(session);\r\n        }\r\n        return session;\r\n    }\r\n    function handleDisconnected() {\r\n        setLoggedIn(false);\r\n        var tryToLogin = shouldTryLogin;\r\n        if (tryToLogin && initialLogin) {\r\n            if (initialLoginAttempts <= 0) {\r\n                return;\r\n            }\r\n            initialLoginAttempts--;\r\n        }\r\n        logger.debug(\"disconnected - will try new login?\" + shouldTryLogin);\r\n        if (shouldTryLogin) {\r\n            connection.login(loginConfig)\r\n                .catch(function () {\r\n                setTimeout(handleDisconnected, 1000);\r\n            });\r\n        }\r\n    }\r\n    function setLoggedIn(value) {\r\n        isLoggedIn = value;\r\n        if (isLoggedIn) {\r\n            registry.execute(\"onLoggedIn\");\r\n        }\r\n    }\r\n    function ping() {\r\n        if (!shouldTryLogin) {\r\n            return;\r\n        }\r\n        if (isLoggedIn) {\r\n            connection.send(\"\", \"\", { type: \"ping\" });\r\n        }\r\n        pingTimer = setTimeout(ping, 30 * 1000);\r\n    }\r\n    function authToken() {\r\n        var createTokenReq = {\r\n            type: \"create-token\"\r\n        };\r\n        return globalDomain.send(createTokenReq)\r\n            .then(function (res) {\r\n            return res.token;\r\n        });\r\n    }\r\n    return {\r\n        processStringMessage: processStringMessage,\r\n        createStringMessage: createStringMessage,\r\n        createObjectMessage: createObjectMessage,\r\n        processObjectMessage: processObjectMessage,\r\n        login: login,\r\n        logout: logout,\r\n        loggedIn: loggedIn,\r\n        domain: domain,\r\n        authToken: authToken,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/gw3.js\n// module id = 80\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callbackRegistry = require(\"callback-registry\");\r\nvar shortid_1 = require(\"shortid\");\r\nfunction default_1(domain, connection, logger, successMessages, errorMessages) {\r\n    if (domain == null) {\r\n        domain = \"global\";\r\n    }\r\n    var isJoined = false;\r\n    var tryReconnecting = false;\r\n    var _latestOptions;\r\n    var _connectionOn = false;\r\n    var callbacks = callbackRegistry();\r\n    connection.disconnected(handleConnectionDisconnected);\r\n    connection.loggedIn(handleConnectionLoggedIn);\r\n    connection.on(domain, \"success\", function (msg) { return handleSuccessMessage(msg); });\r\n    connection.on(domain, \"error\", function (msg) { return handleErrorMessage(msg); });\r\n    connection.on(domain, \"result\", function (msg) { return handleSuccessMessage(msg); });\r\n    if (successMessages) {\r\n        successMessages.forEach(function (sm) {\r\n            connection.on(domain, sm, function (msg) { return handleSuccessMessage(msg); });\r\n        });\r\n    }\r\n    if (errorMessages) {\r\n        errorMessages.forEach(function (sm) {\r\n            connection.on(domain, sm, function (msg) { return handleErrorMessage(msg); });\r\n        });\r\n    }\r\n    var requestsMap = {};\r\n    function join(options) {\r\n        _latestOptions = options;\r\n        return new Promise(function (resolve, reject) {\r\n            if (isJoined) {\r\n                resolve();\r\n                return;\r\n            }\r\n            var joinPromise;\r\n            if (domain === \"global\") {\r\n                joinPromise = _connectionOn ? Promise.resolve({}) : Promise.reject(\"not connected to gateway\");\r\n            }\r\n            else {\r\n                logger.debug(\"joining \" + domain);\r\n                var joinMsg = {\r\n                    type: \"join\",\r\n                    destination: domain,\r\n                    domain: \"global\",\r\n                    options: options,\r\n                };\r\n                joinPromise = send(joinMsg);\r\n            }\r\n            joinPromise\r\n                .then(function () {\r\n                handleJoined();\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                logger.debug(\"error joining \" + domain + \" domain: \" + JSON.stringify(err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function leave() {\r\n        if (domain === \"global\") {\r\n            return;\r\n        }\r\n        logger.debug(\"stopping session \" + domain + \"...\");\r\n        var leaveMsg = {\r\n            type: \"leave\",\r\n            destination: domain,\r\n            domain: \"global\",\r\n        };\r\n        send(leaveMsg).then(function () {\r\n            isJoined = false;\r\n            callbacks.execute(\"onLeft\");\r\n        });\r\n    }\r\n    function handleJoined() {\r\n        logger.debug(\"did join \" + domain);\r\n        isJoined = true;\r\n        var wasReconnect = tryReconnecting;\r\n        tryReconnecting = false;\r\n        callbacks.execute(\"onJoined\", wasReconnect);\r\n    }\r\n    function handleConnectionDisconnected() {\r\n        _connectionOn = false;\r\n        logger.warn(\"connection is down\");\r\n        isJoined = false;\r\n        tryReconnecting = true;\r\n        callbacks.execute(\"onLeft\", { disconnected: true });\r\n    }\r\n    function handleConnectionLoggedIn() {\r\n        _connectionOn = true;\r\n        if (tryReconnecting) {\r\n            logger.info(\"connection is now up - trying to reconnect...\");\r\n            join(_latestOptions);\r\n        }\r\n    }\r\n    function onJoined(callback) {\r\n        if (isJoined) {\r\n            callback(false);\r\n        }\r\n        return callbacks.add(\"onJoined\", callback);\r\n    }\r\n    function onLeft(callback) {\r\n        if (!isJoined) {\r\n            callback();\r\n        }\r\n        return callbacks.add(\"onLeft\", callback);\r\n    }\r\n    function handleErrorMessage(msg) {\r\n        if (domain !== msg.domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.error(msg);\r\n    }\r\n    function handleSuccessMessage(msg) {\r\n        if (msg.domain !== domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.success(msg);\r\n    }\r\n    function getNextRequestId() {\r\n        return shortid_1.generate();\r\n    }\r\n    function send(msg, tag, options) {\r\n        options = options || {};\r\n        msg.request_id = msg.request_id || getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        if (!options.skipPeerId) {\r\n            msg.peer_id = connection.peerId;\r\n        }\r\n        var requestId = msg.request_id;\r\n        return new Promise(function (resolve, reject) {\r\n            requestsMap[requestId] = {\r\n                success: function (successMsg) {\r\n                    delete requestsMap[requestId];\r\n                    successMsg._tag = tag;\r\n                    resolve(successMsg);\r\n                },\r\n                error: function (errorMsg) {\r\n                    logger.warn(\"GW error - \" + JSON.stringify(errorMsg) + \" for request \" + JSON.stringify(msg));\r\n                    delete requestsMap[requestId];\r\n                    errorMsg._tag = tag;\r\n                    reject(errorMsg);\r\n                },\r\n            };\r\n            connection\r\n                .send(domain, domain, msg, undefined, options)\r\n                .catch(function (err) {\r\n                requestsMap[requestId].error({ err: err });\r\n            });\r\n        });\r\n    }\r\n    function sendFireAndForget(msg) {\r\n        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        msg.peer_id = connection.peerId;\r\n        connection.send(domain, domain, msg);\r\n    }\r\n    return {\r\n        join: join,\r\n        leave: leave,\r\n        onJoined: onJoined,\r\n        onLeft: onLeft,\r\n        send: send,\r\n        sendFireAndForget: sendFireAndForget,\r\n        on: function (type, callback) {\r\n            connection.on(domain, type, function (msg) {\r\n                if (msg.domain !== domain) {\r\n                    return;\r\n                }\r\n                try {\r\n                    callback(msg);\r\n                }\r\n                catch (e) {\r\n                    logger.error(\"Callback  failed: \" + e + \" \\n msg was: \" + JSON.stringify(msg));\r\n                }\r\n            });\r\n        },\r\n        loggedIn: function (callback) { return connection.loggedIn(callback); },\r\n        connected: function (callback) { return connection.connected(callback); },\r\n        disconnected: function (callback) { return connection.disconnected(callback); },\r\n        get peerId() {\r\n            return connection.peerId;\r\n        },\r\n        get domain() {\r\n            return domain;\r\n        },\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3Domain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/gw3Domain.js\n// module id = 81\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCProtocol = (function () {\r\n    function HCProtocol() {\r\n    }\r\n    HCProtocol.prototype.processStringMessage = function (message) {\r\n        var messageObj = JSON.parse(message);\r\n        return {\r\n            msg: messageObj,\r\n            msgType: messageObj.type,\r\n        };\r\n    };\r\n    HCProtocol.prototype.createStringMessage = function (product, type, message, id) {\r\n        return JSON.stringify(message);\r\n    };\r\n    HCProtocol.prototype.login = function (message) {\r\n        return Promise.resolve({ application: undefined });\r\n    };\r\n    HCProtocol.prototype.logout = function () {\r\n    };\r\n    HCProtocol.prototype.loggedIn = function (callback) {\r\n        callback();\r\n        return function () {\r\n        };\r\n    };\r\n    HCProtocol.prototype.processObjectMessage = function (message) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    HCProtocol.prototype.createObjectMessage = function (product, type, message, id) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    return HCProtocol;\r\n}());\r\nexports.default = HCProtocol;\r\n//# sourceMappingURL=hc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/hc.js\n// module id = 82\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCTransport = (function () {\r\n    function HCTransport() {\r\n        this.connectionId = Math.floor(1e10 * Math.random()).toString();\r\n    }\r\n    HCTransport.prototype.send = function (message, product, type) {\r\n        if (product === \"metrics\") {\r\n            window.htmlContainer.metricsFacade.send(type, message);\r\n        }\r\n        else if (product === \"log\") {\r\n            window.htmlContainer.loggingFacade.send(type, message);\r\n        }\r\n        return Promise.resolve(undefined);\r\n    };\r\n    HCTransport.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    HCTransport.prototype.onMessage = function (callback) {\r\n    };\r\n    HCTransport.prototype.close = function () {\r\n    };\r\n    HCTransport.prototype.open = function () {\r\n    };\r\n    return HCTransport;\r\n}());\r\nexports.default = HCTransport;\r\n//# sourceMappingURL=hc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/transports/hc.js\n// module id = 83\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar Inproc = (function () {\r\n    function Inproc(token, gw, logger) {\r\n        this.registry = callback_registry_1.default();\r\n        this.gw = gw;\r\n        this.gwToken = token;\r\n        this.logger = logger;\r\n        this.connectToken = this.gw.connect(this.gwToken, this.messageHandler.bind(this));\r\n    }\r\n    Object.defineProperty(Inproc.prototype, \"isObjectBasedTransport\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Inproc.prototype.sendObject = function (msg) {\r\n        this.logger.debug(JSON.stringify(msg));\r\n        this.gw.send(this.connectToken, msg);\r\n        return Promise.resolve(undefined);\r\n    };\r\n    Inproc.prototype.send = function (msg, product, type) {\r\n        return Promise.reject(\"not supported\");\r\n    };\r\n    Inproc.prototype.onMessage = function (callback) {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    };\r\n    Inproc.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    Inproc.prototype.close = function () {\r\n    };\r\n    Inproc.prototype.open = function () {\r\n    };\r\n    Inproc.prototype.messageHandler = function (msg) {\r\n        if (this.logger.consoleLevel() === \"trace\") {\r\n            this.logger.debug(JSON.stringify(msg));\r\n        }\r\n        this.registry.execute(\"onMessage\", msg);\r\n    };\r\n    return Inproc;\r\n}());\r\nexports.default = Inproc;\r\n//# sourceMappingURL=inproc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/transports/inproc.js\n// module id = 84\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar utils_1 = require(\"../../utils\");\r\nvar WebSocket = utils_1.default.isNode() ? require(\"ws\") : window.WebSocket;\r\nvar WS = (function () {\r\n    function WS(settings, logger) {\r\n        this._running = true;\r\n        this._initied = false;\r\n        this._registry = callback_registry_1.default();\r\n        this._settings = settings;\r\n        this._logger = logger;\r\n    }\r\n    WS.prototype.onMessage = function (callback) {\r\n        return this._registry.add(\"onMessage\", callback);\r\n    };\r\n    WS.prototype.send = function (msg, product, type, options) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            options = options || {};\r\n            _this.waitForSocketConnection(function () {\r\n                try {\r\n                    _this._ws.send(msg);\r\n                    resolve();\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, reject, options.maxRetries, options.retryInterval);\r\n        });\r\n    };\r\n    WS.prototype.open = function () {\r\n        this._running = true;\r\n    };\r\n    WS.prototype.close = function () {\r\n        this._running = false;\r\n        this._ws.close();\r\n    };\r\n    WS.prototype.onConnectedChanged = function (callback) {\r\n        return this._registry.add(\"onConnectedChanged\", callback);\r\n    };\r\n    WS.prototype.initiateSocket = function () {\r\n        var _this = this;\r\n        this._logger.debug(\"initiating _ws to \" + this._settings.ws + \"...\");\r\n        this._ws = new WebSocket(this._settings.ws);\r\n        this._ws.onerror = function (err) {\r\n            _this.notifyStatusChanged(false, err);\r\n        };\r\n        this._ws.onclose = function () {\r\n            _this._logger.debug(\"_ws closed\");\r\n            _this.notifyStatusChanged(false);\r\n        };\r\n        this._ws.onopen = function () {\r\n            _this._logger.debug(\"_ws opened\");\r\n            _this.notifyStatusChanged(true);\r\n        };\r\n        this._ws.onmessage = function (message) {\r\n            _this._registry.execute(\"onMessage\", message.data);\r\n        };\r\n    };\r\n    WS.prototype.waitForSocketConnection = function (callback, failed, retriesLeft, retryInterval) {\r\n        var _this = this;\r\n        if (!callback) {\r\n            callback = function () { };\r\n        }\r\n        if (!failed) {\r\n            failed = function () { };\r\n        }\r\n        if (retryInterval === undefined) {\r\n            retryInterval = this._settings.reconnectInterval;\r\n        }\r\n        if (retriesLeft !== undefined) {\r\n            if (retriesLeft === 0) {\r\n                failed(\"wait for socket on \" + this._settings.ws + \" failed - no more retries left\");\r\n                return;\r\n            }\r\n            this._logger.debug(\"will retry \" + retriesLeft + \" more times (every \" + retryInterval + \" ms)\");\r\n        }\r\n        if (!this._running) {\r\n            failed(\"wait for socket on \" + this._settings.ws + \" failed - socket closed by user\");\r\n            return;\r\n        }\r\n        if (!this._ws || this._ws.readyState > 1) {\r\n            this.initiateSocket();\r\n        }\r\n        else if (this._ws.readyState === 1) {\r\n            return callback();\r\n        }\r\n        setTimeout(function () {\r\n            var retries = retriesLeft === undefined ? undefined : retriesLeft - 1;\r\n            _this.waitForSocketConnection(callback, failed, retries, retryInterval);\r\n        }, retryInterval);\r\n    };\r\n    WS.prototype.notifyStatusChanged = function (status, reason) {\r\n        this._registry.execute(\"onConnectedChanged\", status, reason);\r\n    };\r\n    return WS;\r\n}());\r\nexports.default = WS;\r\n//# sourceMappingURL=ws.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/transports/ws.js\n// module id = 85\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3ContextData_1 = require(\"./gw3ContextData\");\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar msg = require(\"./gw3Messages\");\r\nvar contextMessageReplaySpec_1 = require(\"../../contextMessageReplaySpec\");\r\nvar GW3Bridge = (function () {\r\n    function GW3Bridge(config) {\r\n        var _this = this;\r\n        this._contextNameToData = {};\r\n        this._gw3Subscriptions = [];\r\n        this._nextCallbackSubscriptionNumber = 0;\r\n        this._contextNameToId = {};\r\n        this._contextIdToName = {};\r\n        this._connection = config.connection;\r\n        this._logger = config.logger;\r\n        this._gw3Session = this._connection.domain(\"global\", this._logger, [\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n        ]);\r\n        this.subscribeToContextCreatedMessages();\r\n        this.subscribeToContextUpdatedMessages();\r\n        this.subscribeToContextDestroyedMessages();\r\n        this._connection.replayer.drain(contextMessageReplaySpec_1.ContextMessageReplaySpec.name, function (message) {\r\n            var type = message.type;\r\n            if (!type) {\r\n                return;\r\n            }\r\n            if (type === msg.GW_MESSAGE_CONTEXT_CREATED ||\r\n                type === msg.GW_MESSAGE_CONTEXT_ADDED ||\r\n                type === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n                _this.handleContextCreatedMessage(message);\r\n            }\r\n            else if (type === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT ||\r\n                type === msg.GW_MESSAGE_CONTEXT_UPDATED ||\r\n                type === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n                _this.handleContextUpdatedMessage(message);\r\n            }\r\n            else if (type === msg.GW_MESSAGE_CONTEXT_DESTROYED ||\r\n                type === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n                _this.handleContextDestroyedMessage(message);\r\n            }\r\n        });\r\n    }\r\n    GW3Bridge.prototype.dispose = function () {\r\n        for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {\r\n            var sub = _a[_i];\r\n            this._connection.off(sub);\r\n        }\r\n        this._gw3Subscriptions.length = 0;\r\n        for (var contextName in this._contextNameToData) {\r\n            if (this._contextNameToId.hasOwnProperty(contextName)) {\r\n                delete this._contextNameToData[contextName];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.createContext = function (name, data) {\r\n        var _this = this;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            domain: \"global\",\r\n            name: name,\r\n            data: data,\r\n            lifetime: \"retained\",\r\n        })\r\n            .then(function (createContextMsg) {\r\n            _this._contextNameToId[name] = createContextMsg.context_id;\r\n            if (!_this._contextIdToName[createContextMsg.context_id]) {\r\n                _this._contextIdToName[createContextMsg.context_id] = name;\r\n                var contextData = _this._contextNameToData[name] || new gw3ContextData_1.GW3ContextData(createContextMsg.context_id, name, true, null);\r\n                contextData.isAnnounced = true;\r\n                contextData.name = name;\r\n                contextData.contextId = createContextMsg.context_id;\r\n                _this._contextNameToData[name] = contextData;\r\n                contextData.context = createContextMsg.data;\r\n                contextData.sentExplicitSubscription = true;\r\n                if (contextData.context) {\r\n                    _this.invokeUpdateCallbacks(contextData, contextData.context, null);\r\n                }\r\n                return _this.update(name, data).then(function () { return createContextMsg.context_id; });\r\n            }\r\n            return createContextMsg.context_id;\r\n        });\r\n    };\r\n    GW3Bridge.prototype.all = function () {\r\n        var _this = this;\r\n        return Object.keys(this._contextNameToData)\r\n            .filter(function (name) { return _this._contextNameToData[name].isAnnounced; });\r\n    };\r\n    GW3Bridge.prototype.update = function (name, delta) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, delta);\r\n        }\r\n        var calculatedDelta = this.calculateContextDelta(contextData.context, delta);\r\n        if (!Object.keys(calculatedDelta.added).length\r\n            && !Object.keys(calculatedDelta.updated).length\r\n            && !calculatedDelta.removed.length) {\r\n            return Promise.resolve();\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: calculatedDelta,\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, calculatedDelta, {\r\n                updaterId: gwResponse.peer_id\r\n            });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.set = function (name, data) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, data);\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: { reset: data },\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n                var _this = this;\r\n                return __generator(this, function (_a) {\r\n                    this.subscribe(name, function (data, delta, removed, un) {\r\n                        _this.unsubscribe(un);\r\n                        resolve(data);\r\n                    });\r\n                    return [2];\r\n                });\r\n            }); });\r\n        }\r\n        else {\r\n            return Promise.resolve(contextData.context);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribe = function (name, callback) {\r\n        var thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;\r\n        this._nextCallbackSubscriptionNumber += 1;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData ||\r\n            !contextData.isAnnounced) {\r\n            contextData = contextData || new gw3ContextData_1.GW3ContextData(undefined, name, false, undefined);\r\n            this._contextNameToData[name] = contextData;\r\n            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n        var hadCallbacks = contextData.hasCallbacks();\r\n        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n        if (!hadCallbacks) {\r\n            if (!contextData.joinedActivity) {\r\n                if (contextData.context &&\r\n                    contextData.sentExplicitSubscription) {\r\n                    callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n                    return Promise.resolve(thisCallbackSubscriptionNumber);\r\n                }\r\n                return this.sendSubscribe(contextData)\r\n                    .then(function () { return thisCallbackSubscriptionNumber; });\r\n            }\r\n            else {\r\n                callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n                return Promise.resolve(thisCallbackSubscriptionNumber);\r\n            }\r\n        }\r\n        else {\r\n            callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.unsubscribe = function (subscriptionKey) {\r\n        for (var _i = 0, _a = Object.keys(this._contextNameToData); _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var contextId = this._contextNameToId[name_1];\r\n            var contextData = this._contextNameToData[name_1];\r\n            if (!contextData) {\r\n                return;\r\n            }\r\n            var hadCallbacks = contextData.hasCallbacks();\r\n            delete contextData.updateCallbacks[subscriptionKey];\r\n            if (contextData.isAnnounced &&\r\n                hadCallbacks &&\r\n                !contextData.hasCallbacks() &&\r\n                contextData.sentExplicitSubscription) {\r\n                this.sendUnsubscribe(contextData);\r\n            }\r\n            if (!contextData.isAnnounced &&\r\n                !contextData.hasCallbacks()) {\r\n                delete this._contextNameToData[name_1];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleUpdated = function (contextData, delta, extraData) {\r\n        var oldContext = contextData.context;\r\n        contextData.context = helpers_1.applyContextDelta(contextData.context, delta);\r\n        if (this._contextNameToData[contextData.name] === contextData &&\r\n            !helpers_1.deepEqual(oldContext, contextData.context)) {\r\n            this.invokeUpdateCallbacks(contextData, contextData.context, delta, extraData);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextCreatedMessages = function () {\r\n        var createdMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n        ];\r\n        for (var _i = 0, createdMessageTypes_1 = createdMessageTypes; _i < createdMessageTypes_1.length; _i++) {\r\n            var createdMessageType = createdMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", createdMessageType, this.handleContextCreatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextCreatedMessage = function (contextCreatedMsg) {\r\n        var createdMessageType = contextCreatedMsg.type;\r\n        if (createdMessageType === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;\r\n        }\r\n        else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_ADDED) {\r\n            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;\r\n        }\r\n        else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_CREATED) {\r\n        }\r\n        var name = this._contextIdToName[contextCreatedMsg.context_id];\r\n        if (!name) {\r\n            throw new Error(\"Received created event for context with unknown name: \" + contextCreatedMsg.context_id);\r\n        }\r\n        if (!this._contextNameToId[name]) {\r\n            throw new Error(\"Received created event for context with unknown id: \" + contextCreatedMsg.context_id);\r\n        }\r\n        var contextData = this._contextNameToData[name];\r\n        if (contextData) {\r\n            if (contextData.isAnnounced) {\r\n                return;\r\n            }\r\n            else {\r\n                if (!contextData.hasCallbacks()) {\r\n                    throw new Error(\"Assertion failure: contextData.hasCallbacks()\");\r\n                }\r\n                contextData.isAnnounced = true;\r\n                contextData.contextId = contextCreatedMsg.context_id;\r\n                contextData.activityId = contextCreatedMsg.activity_id;\r\n                if (!contextData.sentExplicitSubscription) {\r\n                    this.sendSubscribe(contextData);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._contextNameToData[name] = contextData =\r\n                new gw3ContextData_1.GW3ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextUpdatedMessages = function () {\r\n        var updatedMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY,\r\n        ];\r\n        for (var _i = 0, updatedMessageTypes_1 = updatedMessageTypes; _i < updatedMessageTypes_1.length; _i++) {\r\n            var updatedMessageType = updatedMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", updatedMessageType, this.handleContextUpdatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextUpdatedMessage = function (contextUpdatedMsg) {\r\n        var updatedMessageType = contextUpdatedMsg.type;\r\n        var contextId = contextUpdatedMsg.context_id;\r\n        var contextData = this._contextNameToData[this._contextIdToName[contextId]];\r\n        var justSeen = !contextData || !contextData.isAnnounced;\r\n        if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            if (!contextData) {\r\n                contextData = new gw3ContextData_1.GW3ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);\r\n                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;\r\n                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;\r\n                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;\r\n            }\r\n            else {\r\n                contextData.contextId = contextId;\r\n                contextData.isAnnounced = true;\r\n                contextData.activityId = contextUpdatedMsg.activity_id;\r\n            }\r\n            contextData.joinedActivity = true;\r\n        }\r\n        else {\r\n            if (!contextData || !contextData.isAnnounced) {\r\n                if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n                    contextData = contextData || new gw3ContextData_1.GW3ContextData(contextId, contextUpdatedMsg.name, true, null);\r\n                    contextData.sentExplicitSubscription = true;\r\n                    this._contextNameToData[contextUpdatedMsg.name] = contextData;\r\n                    this._contextIdToName[contextId] = contextUpdatedMsg.name;\r\n                    this._contextNameToId[contextUpdatedMsg.name] = contextId;\r\n                }\r\n                else {\r\n                    this._logger.error(\"Received 'update' for unknown context: \" + contextId);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        var oldContext = contextData.context;\r\n        if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            contextData.context = contextUpdatedMsg.data || {};\r\n        }\r\n        else if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            contextData.context = contextUpdatedMsg.context_snapshot || {};\r\n        }\r\n        else if (updatedMessageType === msg.GW_MESSAGE_CONTEXT_UPDATED) {\r\n            contextData.context = helpers_1.applyContextDelta(contextData.context, contextUpdatedMsg.delta);\r\n        }\r\n        else {\r\n            throw new Error(\"Unrecognized context update message \" + updatedMessageType);\r\n        }\r\n        if (justSeen ||\r\n            !helpers_1.deepEqual(contextData.context, oldContext) ||\r\n            updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            this.invokeUpdateCallbacks(contextData, contextData.context, null, { updaterId: contextUpdatedMsg.updater_id });\r\n        }\r\n    };\r\n    GW3Bridge.prototype.invokeUpdateCallbacks = function (contextData, data, delta, extraData) {\r\n        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };\r\n        for (var updateCallbackIndex in contextData.updateCallbacks) {\r\n            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {\r\n                try {\r\n                    var updateCallback = contextData.updateCallbacks[updateCallbackIndex];\r\n                    updateCallback(helpers_1.deepClone(data), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex), extraData);\r\n                }\r\n                catch (err) {\r\n                    this._logger.debug(\"Callback error: \" + JSON.stringify(err));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextDestroyedMessages = function () {\r\n        var destroyedMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n        ];\r\n        for (var _i = 0, destroyedMessageTypes_1 = destroyedMessageTypes; _i < destroyedMessageTypes_1.length; _i++) {\r\n            var destroyedMessageType = destroyedMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", destroyedMessageType, this.handleContextDestroyedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextDestroyedMessage = function (destroyedMsg) {\r\n        var destroyedMessageType = destroyedMsg.type;\r\n        var contextId;\r\n        var name;\r\n        if (destroyedMessageType === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n            name = destroyedMsg.activity_id;\r\n            contextId = this._contextNameToId[name];\r\n            if (!contextId) {\r\n                this._logger.error(\"Received 'destroyed' for unknown activity: \" + destroyedMsg.activity_id);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            contextId = destroyedMsg.context_id;\r\n            name = this._contextIdToName[contextId];\r\n            if (!name) {\r\n                this._logger.error(\"Received 'destroyed' for unknown context: \" + destroyedMsg.context_id);\r\n                return;\r\n            }\r\n        }\r\n        delete this._contextIdToName[contextId];\r\n        delete this._contextNameToId[name];\r\n        var contextData = this._contextNameToData[name];\r\n        delete this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            this._logger.error(\"Received 'destroyed' for unknown context: \" + contextId);\r\n            return;\r\n        }\r\n    };\r\n    GW3Bridge.prototype.sendSubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = true;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.sendUnsubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = false;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.calculateContextDelta = function (from, to) {\r\n        var delta = { added: {}, updated: {}, removed: [], reset: null };\r\n        if (from) {\r\n            for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n                var x = _a[_i];\r\n                if (Object.keys(to).indexOf(x) !== -1\r\n                    && to[x] !== null\r\n                    && !helpers_1.deepEqual(from[x], to[x])) {\r\n                    delta.updated[x] = to[x];\r\n                }\r\n            }\r\n        }\r\n        for (var _b = 0, _c = Object.keys(to); _b < _c.length; _b++) {\r\n            var x = _c[_b];\r\n            if (!from || (Object.keys(from).indexOf(x) === -1)) {\r\n                if (to[x] !== null) {\r\n                    delta.added[x] = to[x];\r\n                }\r\n            }\r\n            else if (to[x] === null) {\r\n                delta.removed.push(x);\r\n            }\r\n        }\r\n        return delta;\r\n    };\r\n    return GW3Bridge;\r\n}());\r\nexports.GW3Bridge = GW3Bridge;\r\n//# sourceMappingURL=gw3Bridge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/gw3/gw3Bridge.js\n// module id = 86\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GW3ContextData = (function () {\r\n    function GW3ContextData(contextId, name, isAnnounced, activityId) {\r\n        this.updateCallbacks = {};\r\n        this.contextId = contextId;\r\n        this.name = name;\r\n        this.isAnnounced = isAnnounced;\r\n        this.activityId = activityId;\r\n        this.context = {};\r\n    }\r\n    GW3ContextData.prototype.hasCallbacks = function () {\r\n        return Object.keys(this.updateCallbacks).length > 0;\r\n    };\r\n    GW3ContextData.prototype.getState = function () {\r\n        if (this.isAnnounced && this.hasCallbacks()) {\r\n            return 3;\r\n        }\r\n        if (this.isAnnounced) {\r\n            return 2;\r\n        }\r\n        if (this.hasCallbacks()) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    };\r\n    return GW3ContextData;\r\n}());\r\nexports.GW3ContextData = GW3ContextData;\r\n//# sourceMappingURL=gw3ContextData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/gw3/gw3ContextData.js\n// module id = 87\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCBridge = (function () {\r\n    function HCBridge(config) {\r\n        this._facade = window.htmlContainer.sharedContextFacade;\r\n    }\r\n    HCBridge.prototype.all = function () {\r\n        var allObj = this._facade.all();\r\n        if (!allObj || !allObj.keys) {\r\n            return [];\r\n        }\r\n        return allObj.keys;\r\n    };\r\n    HCBridge.prototype.update = function (name, delta) {\r\n        this._facade.update(name, delta);\r\n        return Promise.resolve();\r\n    };\r\n    HCBridge.prototype.set = function (name, data) {\r\n        this._facade.set(name, data);\r\n        return Promise.resolve();\r\n    };\r\n    HCBridge.prototype.subscribe = function (name, callback) {\r\n        var snapshot = null;\r\n        var key = this._facade.subscribe(name, function (data, delta, removed) {\r\n            if (!key && key !== 0) {\r\n                snapshot = data;\r\n                return;\r\n            }\r\n            callback(data, delta, removed, key);\r\n        });\r\n        if (snapshot) {\r\n            callback(snapshot, snapshot, [], key);\r\n            snapshot = null;\r\n        }\r\n        return Promise.resolve(key);\r\n    };\r\n    HCBridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                this.subscribe(name, function (data, un) {\r\n                    _this.unsubscribe(un);\r\n                    resolve(data);\r\n                });\r\n                return [2];\r\n            });\r\n        }); });\r\n    };\r\n    HCBridge.prototype.unsubscribe = function (key) {\r\n        this._facade.unsubscribe(key);\r\n    };\r\n    return HCBridge;\r\n}());\r\nexports.HCBridge = HCBridge;\r\n//# sourceMappingURL=hcBridge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/hcBridge.js\n// module id = 88\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3Bridge_1 = require(\"./bridges/gw3/gw3Bridge\");\r\nvar hcBridge_1 = require(\"./bridges/hcBridge\");\r\nvar ContextsModule = (function () {\r\n    function ContextsModule(config) {\r\n        this.config = config;\r\n        try {\r\n            if (config.gdMajorVersion === 2) {\r\n                var hc = window.htmlContainer;\r\n                if (!hc.sharedContextFacade) {\r\n                    throw new Error(\"Your version of HtmlContainer does not support contexts.\"\r\n                        + \" Get version 1.46.0.0 or later to have that feature.\");\r\n                }\r\n                this._bridge = new hcBridge_1.HCBridge(config);\r\n            }\r\n            else if (config.connection.protocolVersion === 3) {\r\n                this._bridge = new gw3Bridge_1.GW3Bridge(config);\r\n            }\r\n            else {\r\n                throw new Error(\"To use the Contexts library you must run in the\"\r\n                    + \" HTML Container or using a connection to Gateway v3.\");\r\n            }\r\n        }\r\n        catch (err) {\r\n            throw err;\r\n        }\r\n    }\r\n    ContextsModule.prototype.all = function () {\r\n        return this._bridge.all();\r\n    };\r\n    ContextsModule.prototype.update = function (name, delta) {\r\n        this.checkName(name);\r\n        return this._bridge.update(name, delta);\r\n    };\r\n    ContextsModule.prototype.set = function (name, data) {\r\n        this.checkName(name);\r\n        return this._bridge.set(name, data);\r\n    };\r\n    ContextsModule.prototype.subscribe = function (name, callback) {\r\n        var _this = this;\r\n        this.checkName(name);\r\n        return this._bridge\r\n            .subscribe(name, function (data, delta, removed, key, extraData) { return callback(data, delta, removed, function () { return _this._bridge.unsubscribe(key); }, extraData); })\r\n            .then(function (key) {\r\n            return function () {\r\n                _this._bridge.unsubscribe(key);\r\n            };\r\n        });\r\n    };\r\n    ContextsModule.prototype.get = function (name) {\r\n        return this._bridge.get(name);\r\n    };\r\n    ContextsModule.prototype.ready = function () {\r\n        return Promise.resolve(this);\r\n    };\r\n    ContextsModule.prototype.checkName = function (name) {\r\n        if (typeof name !== \"string\" ||\r\n            name == \"\") {\r\n            throw new Error(\"'name' must be non-empty string, got '\" + name + \"'\");\r\n        }\r\n    };\r\n    return ContextsModule;\r\n}());\r\nexports.ContextsModule = ContextsModule;\r\n//# sourceMappingURL=contextsModule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/contextsModule.js\n// module id = 89\n// module chunks = 0","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction applyContextDelta(context, delta) {\r\n    if (delta) {\r\n        if (delta.reset) {\r\n            context = __assign({}, delta.reset);\r\n            return context;\r\n        }\r\n        context = deepClone(context, null);\r\n        var added_1 = delta.added;\r\n        var updated_1 = delta.updated;\r\n        var removed = delta.removed;\r\n        if (added_1) {\r\n            Object.keys(added_1).forEach(function (key) {\r\n                context[key] = added_1[key];\r\n            });\r\n        }\r\n        if (updated_1) {\r\n            Object.keys(updated_1).forEach(function (key) {\r\n                mergeObjectsProperties(key, context, updated_1);\r\n            });\r\n        }\r\n        if (removed) {\r\n            removed.forEach(function (key) {\r\n                delete context[key];\r\n            });\r\n        }\r\n    }\r\n    return context;\r\n}\r\nexports.applyContextDelta = applyContextDelta;\r\nfunction deepClone(obj, hash) {\r\n    hash = hash || new WeakMap();\r\n    if (Object(obj) !== obj) {\r\n        return obj;\r\n    }\r\n    if (obj instanceof Set) {\r\n        return new Set(obj);\r\n    }\r\n    if (hash.has(obj)) {\r\n        return hash.get(obj);\r\n    }\r\n    var result = obj instanceof Date ? new Date(obj)\r\n        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)\r\n            : obj.constructor ? new obj.constructor()\r\n                : Object.create(null);\r\n    hash.set(obj, result);\r\n    if (obj instanceof Map) {\r\n        Array.from(obj, function (_a) {\r\n            var key = _a[0], val = _a[1];\r\n            return result.set(key, deepClone(val, hash));\r\n        });\r\n    }\r\n    return Object.assign.apply(Object, [result].concat(Object.keys(obj).map(function (key) {\r\n        var _a;\r\n        return (_a = {}, _a[key] = deepClone(obj[key], hash), _a);\r\n    })));\r\n}\r\nexports.deepClone = deepClone;\r\nvar mergeObjectsProperties = function (key, what, withWhat) {\r\n    var right = withWhat[key];\r\n    if (right === undefined) {\r\n        return what;\r\n    }\r\n    var left = what[key];\r\n    if (!left || !right) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    if (typeof left === \"string\" ||\r\n        typeof left === \"number\" ||\r\n        typeof left === \"boolean\" ||\r\n        typeof right === \"string\" ||\r\n        typeof right === \"number\" ||\r\n        typeof right === \"boolean\" ||\r\n        Array.isArray(left) ||\r\n        Array.isArray(right)) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    what[key] = Object.assign({}, left, right);\r\n    return what;\r\n};\r\nfunction deepEqual(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    if (!(x instanceof Object) || !(y instanceof Object)) {\r\n        return false;\r\n    }\r\n    if (x.constructor !== y.constructor) {\r\n        return false;\r\n    }\r\n    for (var p in x) {\r\n        if (!x.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (!y.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        if (x[p] === y[p]) {\r\n            continue;\r\n        }\r\n        if (typeof (x[p]) !== \"object\") {\r\n            return false;\r\n        }\r\n        if (!deepEqual(x[p], y[p])) {\r\n            return false;\r\n        }\r\n    }\r\n    for (var p in y) {\r\n        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.deepEqual = deepEqual;\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/helpers.js\n// module id = 90\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar contextsModule_1 = require(\"./contextsModule\");\r\nexports.ContextsModule = contextsModule_1.ContextsModule;\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/main.js\n// module id = 91\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar LogLevel = (function () {\r\n    function LogLevel() {\r\n    }\r\n    LogLevel.canPublish = function (level, restriction) {\r\n        var levelIdx = LogLevel.order.indexOf(level);\r\n        var restrictionIdx = LogLevel.order.indexOf(restriction);\r\n        return levelIdx >= restrictionIdx;\r\n    };\r\n    LogLevel.off = \"off\";\r\n    LogLevel.trace = \"trace\";\r\n    LogLevel.debug = \"debug\";\r\n    LogLevel.info = \"info\";\r\n    LogLevel.warn = \"warn\";\r\n    LogLevel.error = \"error\";\r\n    LogLevel.order = [LogLevel.trace, LogLevel.debug, LogLevel.info, LogLevel.warn, LogLevel.error, LogLevel.off];\r\n    return LogLevel;\r\n}());\r\nexports.default = LogLevel;\r\n//# sourceMappingURL=levels.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/logger/levels.js\n// module id = 92\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar levels_1 = require(\"./levels\");\r\nvar LoggerImpl = (function () {\r\n    function LoggerImpl(name, parent, metricSystem) {\r\n        this._subloggers = [];\r\n        this._name = name;\r\n        this._parent = parent;\r\n        if (parent) {\r\n            this._path = parent.path + \".\" + name;\r\n        }\r\n        else {\r\n            this._path = name;\r\n        }\r\n        this._loggerFullName = \"[\" + this._path + \"]\";\r\n        if (typeof metricSystem !== \"undefined\") {\r\n            this.metricsLevel(\"warn\", metricSystem.subSystem(name));\r\n        }\r\n    }\r\n    Object.defineProperty(LoggerImpl.prototype, \"name\", {\r\n        get: function () {\r\n            return this._name;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(LoggerImpl.prototype, \"path\", {\r\n        get: function () {\r\n            return this._path;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    LoggerImpl.prototype.subLogger = function (name) {\r\n        var existingSub = this._subloggers.filter(function (subLogger) {\r\n            return subLogger.name === name;\r\n        })[0];\r\n        if (existingSub !== undefined) {\r\n            return existingSub;\r\n        }\r\n        Object.keys(this).forEach(function (key) {\r\n            if (key === name) {\r\n                throw new Error(\"This sub logger name is not allowed.\");\r\n            }\r\n        });\r\n        var sub = new LoggerImpl(name, this);\r\n        this._subloggers.push(sub);\r\n        return sub;\r\n    };\r\n    LoggerImpl.prototype.publishLevel = function (level) {\r\n        if (level !== null && level !== undefined) {\r\n            this._publishLevel = level;\r\n        }\r\n        return this._publishLevel || this._parent.publishLevel();\r\n    };\r\n    LoggerImpl.prototype.consoleLevel = function (level) {\r\n        if (level !== null && level !== undefined) {\r\n            this._consoleLevel = level;\r\n        }\r\n        return this._consoleLevel || this._parent.consoleLevel();\r\n    };\r\n    LoggerImpl.prototype.metricsLevel = function (level, metricsSystem) {\r\n        if (level !== null && level !== undefined) {\r\n            this._metricLevel = level;\r\n        }\r\n        if (metricsSystem !== undefined) {\r\n            if (typeof metricsSystem === \"object\" && typeof metricsSystem.objectMetric === \"function\") {\r\n                this._metricSystem = metricsSystem;\r\n            }\r\n            else {\r\n                throw new Error(\"Please specify metric system\");\r\n            }\r\n        }\r\n        return this._metricLevel || this._parent.metricsLevel();\r\n    };\r\n    LoggerImpl.prototype.log = function (message, level) {\r\n        this.publishMessage(level || levels_1.default.info, message);\r\n    };\r\n    LoggerImpl.prototype.trace = function (message) {\r\n        this.log(message, levels_1.default.trace);\r\n    };\r\n    LoggerImpl.prototype.debug = function (message) {\r\n        this.log(message, levels_1.default.debug);\r\n    };\r\n    LoggerImpl.prototype.info = function (message) {\r\n        this.log(message, levels_1.default.info);\r\n    };\r\n    LoggerImpl.prototype.warn = function (message) {\r\n        this.log(message, levels_1.default.warn);\r\n    };\r\n    LoggerImpl.prototype.error = function (message) {\r\n        this.log(message, levels_1.default.error);\r\n    };\r\n    LoggerImpl.prototype.toAPIObject = function () {\r\n        var that = this;\r\n        return {\r\n            name: this.name,\r\n            subLogger: this.subLogger.bind(that),\r\n            publishLevel: this.publishLevel.bind(that),\r\n            consoleLevel: this.consoleLevel.bind(that),\r\n            metricsLevel: this.metricsLevel.bind(that),\r\n            log: this.log.bind(that),\r\n            trace: this.trace.bind(that),\r\n            debug: this.debug.bind(that),\r\n            info: this.info.bind(that),\r\n            warn: this.warn.bind(that),\r\n            error: this.error.bind(that),\r\n        };\r\n    };\r\n    LoggerImpl.prototype.publishMessage = function (level, message) {\r\n        var loggerName = this._loggerFullName;\r\n        if (level === levels_1.default.error) {\r\n            var e = new Error();\r\n            if (e.stack) {\r\n                message = message + \"\\n\" +\r\n                    (e.stack.split(\"\\n\").slice(3).join(\"\\n\"));\r\n            }\r\n        }\r\n        if (levels_1.default.canPublish(level, this.consoleLevel())) {\r\n            var toPrint = loggerName + \": \" + message;\r\n            switch (level) {\r\n                case levels_1.default.trace:\r\n                    console.trace(toPrint);\r\n                    break;\r\n                case levels_1.default.debug:\r\n                    if (console.debug) {\r\n                        console.debug(toPrint);\r\n                    }\r\n                    else {\r\n                        console.log(toPrint);\r\n                    }\r\n                    break;\r\n                case levels_1.default.info:\r\n                    console.info(toPrint);\r\n                    break;\r\n                case levels_1.default.warn:\r\n                    console.warn(toPrint);\r\n                    break;\r\n                case levels_1.default.error:\r\n                    console.error(toPrint);\r\n                    break;\r\n            }\r\n        }\r\n        if (levels_1.default.canPublish(level, this.publishLevel())) {\r\n            LoggerImpl.GetConnection().send(\"log\", \"LogMessage\", {\r\n                instance: LoggerImpl.Instance,\r\n                level: levels_1.default.order.indexOf(level),\r\n                logger: loggerName,\r\n                message: message,\r\n            });\r\n        }\r\n        if (levels_1.default.canPublish(level, this.metricsLevel())) {\r\n            if (this._metricSystem !== undefined) {\r\n                this._metricSystem.objectMetric(\"LogMessage\", {\r\n                    Level: level,\r\n                    Logger: loggerName,\r\n                    Message: message,\r\n                    Time: new Date(),\r\n                });\r\n                if (level === levels_1.default.error) {\r\n                    this._metricSystem.setState(100, message);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return LoggerImpl;\r\n}());\r\nexports.default = LoggerImpl;\r\n//# sourceMappingURL=logger.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/logger/logger.js\n// module id = 93\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar logger_1 = require(\"./logger\");\r\nexports.default = (function (settings) {\r\n    var identity = settings.identity;\r\n    if (!identity) {\r\n        throw new Error(\"identity is missing\");\r\n    }\r\n    var identityStr = identity.system + \"\\\\\" + identity.service + \"\\\\\" + identity.instance;\r\n    logger_1.default.Instance = identityStr;\r\n    logger_1.default.GetConnection = settings.getConnection;\r\n    var mainLogger = new logger_1.default(\"main\");\r\n    mainLogger.publishLevel(settings.publish || \"off\");\r\n    mainLogger.consoleLevel(settings.console || \"info\");\r\n    mainLogger.metricsLevel(settings.metrics || \"off\");\r\n    var apiLogger = mainLogger.toAPIObject();\r\n    return apiLogger;\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/logger/main.js\n// module id = 94\n// module chunks = 0","\"use strict\";\r\nvar glue_1 = require(\"./glue\");\r\nvar pjson = require(\"../package.json\");\r\nif (typeof window !== \"undefined\") {\r\n    window.GlueCore = glue_1.default;\r\n}\r\nglue_1.default.default = glue_1.default;\r\nglue_1.default.version = pjson.version;\r\nmodule.exports = glue_1.default;\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/main.js\n// module id = 95\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction addressMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var conflation = definition.conflation;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.ADDRESS;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = addressMetric;\r\n//# sourceMappingURL=address.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/address.js\n// module id = 96\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction countMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || 0;\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.COUNT;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function incrementBy(num) {\r\n        update(_value + num);\r\n    }\r\n    function increment() {\r\n        incrementBy(1);\r\n    }\r\n    function decrement() {\r\n        incrementBy(-1);\r\n    }\r\n    function decrementBy(num) {\r\n        incrementBy(num * -1);\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get path() {\r\n            return _path;\r\n        },\r\n        get value() {\r\n            return _value;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n        incrementBy: incrementBy,\r\n        increment: increment,\r\n        decrement: decrement,\r\n        decrementBy: decrementBy,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = countMetric;\r\n//# sourceMappingURL=count.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/count.js\n// module id = 97\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction numberMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _path = parent.path.slice(0);\r\n    var _value = value || 0;\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.NUMBER;\r\n    _path.push(parent.name);\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function incrementBy(num) {\r\n        update(_value + num);\r\n    }\r\n    function increment() {\r\n        incrementBy(1);\r\n    }\r\n    function decrement() {\r\n        incrementBy(-1);\r\n    }\r\n    function decrementBy(num) {\r\n        incrementBy(num * -1);\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        type: type,\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n        incrementBy: incrementBy,\r\n        increment: increment,\r\n        decrement: decrement,\r\n        decrementBy: decrementBy,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = numberMetric;\r\n//# sourceMappingURL=number.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/number.js\n// module id = 98\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nvar helpers_1 = require(\"../../helpers\");\r\nfunction objectMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.OBJECT;\r\n    function update(newValue) {\r\n        mergeValues(newValue);\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function mergeValues(values) {\r\n        return Object.keys(_value).forEach(function (k) {\r\n            if (typeof values[k] !== \"undefined\") {\r\n                _value[k] = values[k];\r\n            }\r\n        });\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = objectMetric;\r\n//# sourceMappingURL=object.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/object.js\n// module id = 99\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction rateMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.RATE;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = rateMetric;\r\n//# sourceMappingURL=rate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/rate.js\n// module id = 100\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction statisticsMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.STATISTICS;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = statisticsMetric;\r\n//# sourceMappingURL=statistics.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/statistics.js\n// module id = 101\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction stringMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.STRING;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        type: type,\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = stringMetric;\r\n//# sourceMappingURL=string.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/string.js\n// module id = 102\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction timespanMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.TIMESPAN;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function start() {\r\n        update(true);\r\n    }\r\n    function stop() {\r\n        update(false);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        start: start,\r\n        stop: stop,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = timespanMetric;\r\n//# sourceMappingURL=timespan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/timespan.js\n// module id = 103\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction timestampMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.TIMESTAMP;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function now() {\r\n        update(new Date());\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        now: now,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = timestampMetric;\r\n//# sourceMappingURL=timestamp.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/timestamp.js\n// module id = 104\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar serializer_1 = require(\"./serializer\");\r\nfunction default_1(connection, config) {\r\n    var DEFAULT_HEARTBEAT_INTERVAL = 3000;\r\n    var heartbeatTimer;\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var _connection = connection;\r\n    var heartbeatInterval = config.heartbeatInterval || DEFAULT_HEARTBEAT_INTERVAL;\r\n    var send = function (type, message) {\r\n        _connection.send(\"metrics\", type, message);\r\n    };\r\n    function sendFull(repo) {\r\n        if (!repo.root) {\r\n            return;\r\n        }\r\n        if (repo.root.subSystems.length === 0) {\r\n            return;\r\n        }\r\n        sendFullSystem(repo.root);\r\n    }\r\n    function sendFullSystem(system) {\r\n        createSystem(system);\r\n        system.subSystems.forEach(function (sub) {\r\n            sendFullSystem(sub);\r\n        });\r\n        system.metrics.forEach(function (metric) {\r\n            createMetric(metric);\r\n        });\r\n    }\r\n    function heartbeat(repo) {\r\n        send(\"HeartbeatMetrics\", {\r\n            publishingInterval: heartbeatInterval,\r\n            instance: repo.instance,\r\n        });\r\n    }\r\n    function createSystem(system) {\r\n        if (system.parent !== undefined) {\r\n            send(\"CreateMetricSystem\", {\r\n                id: system.id,\r\n                instance: system.repo.instance,\r\n                definition: {\r\n                    name: system.name,\r\n                    description: system.description,\r\n                    path: system.path,\r\n                },\r\n            });\r\n        }\r\n    }\r\n    function updateSystem(system, state) {\r\n        send(\"UpdateMetricSystem\", {\r\n            id: system.id,\r\n            instance: system.repo.instance,\r\n            state: state,\r\n        });\r\n    }\r\n    function createMetric(metric) {\r\n        send(\"CreateMetric\", serializer_1.default(metric));\r\n    }\r\n    function updateMetric(metric) {\r\n        send(\"UpdateMetric\", serializer_1.default(metric));\r\n    }\r\n    function init(repo) {\r\n        heartbeat(repo);\r\n        _connection.on(\"metrics\", \"MetricsSnapshotRequest\", function (instanceInfo) {\r\n            if (instanceInfo.Instance !== repo.instance) {\r\n                return;\r\n            }\r\n            sendFull(repo);\r\n        });\r\n        _connection.disconnected(function () { return clearInterval(heartbeatTimer); });\r\n        if (typeof window !== \"undefined\" && typeof window.htmlContainer === \"undefined\") {\r\n            heartbeatTimer = setInterval(function () {\r\n                heartbeat(repo);\r\n            }, heartbeatInterval);\r\n        }\r\n    }\r\n    var me = {\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n        init: init,\r\n    };\r\n    return me;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw1.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw1/gw1.js\n// module id = 105\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = require(\"../../const/metric-types\");\r\nfunction metricToMessage(metric) {\r\n    var definition = getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution, metric.conflation);\r\n    function getMetricDefinition(name, value, path, type, description, period, resolution, conflation) {\r\n        var _definition = {\r\n            name: name,\r\n            description: description,\r\n            type: type ? type : getTypeFromValue(value),\r\n            path: path,\r\n            resolution: resolution,\r\n            period: period,\r\n            conflation: conflation,\r\n        };\r\n        if (_definition.type === metric_types_1.default.OBJECT) {\r\n            _definition.Composite = Object.keys(value).reduce(function (arr, key) {\r\n                var val = value[key];\r\n                arr.push(getMetricDefinition(key, val, path));\r\n                return arr;\r\n            }, []);\r\n        }\r\n        return _definition;\r\n    }\r\n    function serializeValue(value, _metric) {\r\n        if (value && value.constructor === Date) {\r\n            return {\r\n                value: {\r\n                    type: _valueTypes.indexOf(\"date\"),\r\n                    value: value.valueOf(),\r\n                    isArray: false,\r\n                },\r\n            };\r\n        }\r\n        if (typeof value === \"object\") {\r\n            return {\r\n                CompositeValue: Object.keys(value).reduce(function (arr, key) {\r\n                    var val = serializeValue(value[key]);\r\n                    val.InnerMetricName = key;\r\n                    arr.push(val);\r\n                    return arr;\r\n                }, []),\r\n            };\r\n        }\r\n        var valueType = _metric ? _metric.getValueType() : undefined;\r\n        valueType = valueType || _valueTypes.indexOf(typeof value);\r\n        return {\r\n            value: {\r\n                type: valueType,\r\n                value: value,\r\n                isArray: false,\r\n            },\r\n        };\r\n    }\r\n    function getTypeFromValue(value) {\r\n        var typeAsString = value.constructor === Date ? \"timestamp\" : typeof value;\r\n        switch (typeAsString) {\r\n            case \"string\":\r\n                return metric_types_1.default.STRING;\r\n            case \"number\":\r\n                return metric_types_1.default.NUMBER;\r\n            case \"timestamp\":\r\n                return metric_types_1.default.TIMESTAMP;\r\n            case \"object\":\r\n                return metric_types_1.default.OBJECT;\r\n        }\r\n        return 0;\r\n    }\r\n    var _valueTypes = [\r\n        \"boolean\",\r\n        \"int\",\r\n        \"number\",\r\n        \"long\",\r\n        \"string\",\r\n        \"date\",\r\n        \"object\",\r\n    ];\r\n    return {\r\n        id: metric.id,\r\n        instance: metric.repo.instance,\r\n        definition: definition,\r\n        value: serializeValue(metric.value, metric),\r\n    };\r\n}\r\nexports.default = metricToMessage;\r\n//# sourceMappingURL=serializer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw1/serializer.js\n// module id = 106\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar serializer_1 = require(\"./serializer\");\r\nfunction default_1(connection, config) {\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var joinPromise;\r\n    var session;\r\n    var init = function (repo) {\r\n        var resolveReadyPromise;\r\n        joinPromise = new Promise(function (resolve) {\r\n            resolveReadyPromise = resolve;\r\n        });\r\n        session = connection.domain(\"metrics\", config.logger);\r\n        session.onJoined(function (reconnect) {\r\n            if (!reconnect) {\r\n                resolveReadyPromise();\r\n                resolveReadyPromise = undefined;\r\n            }\r\n            var rootStateMetric = {\r\n                name: \"/State\",\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var defineRootMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [rootStateMetric],\r\n            };\r\n            session.send(defineRootMetricsMsg);\r\n            if (reconnect) {\r\n                replayRepo(repo);\r\n            }\r\n        });\r\n        session.join(config.identity);\r\n    };\r\n    var replayRepo = function (repo) {\r\n        replaySystem(repo.root);\r\n    };\r\n    var replaySystem = function (system) {\r\n        createSystem(system);\r\n        system.metrics.forEach(function (m) {\r\n            createMetric(m);\r\n        });\r\n        system.subSystems.forEach(function (ss) {\r\n            replaySystem(ss);\r\n        });\r\n    };\r\n    var createSystem = function (system) {\r\n        if (system.parent === undefined) {\r\n            return;\r\n        }\r\n        joinPromise.then(function () {\r\n            var metric = {\r\n                name: serializer_1.normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var createMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [metric],\r\n            };\r\n            session.send(createMetricsMsg);\r\n        });\r\n    };\r\n    var updateSystem = function (system, state) {\r\n        joinPromise.then(function () {\r\n            var shadowedUpdateMetric = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: serializer_1.normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                        value: {\r\n                            Description: state.description,\r\n                            Value: state.state,\r\n                        },\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(shadowedUpdateMetric);\r\n            var stateObj = serializer_1.composeMsgForRootStateMetric(system);\r\n            var rootMetric = {\r\n                type: \"publish\",\r\n                peer_id: connection.peerId,\r\n                values: [{\r\n                        name: \"/State\",\r\n                        value: {\r\n                            Description: stateObj.description,\r\n                            Value: stateObj.value,\r\n                        },\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(rootMetric);\r\n        });\r\n    };\r\n    var createMetric = function (metric) {\r\n        joinPromise.then(function () {\r\n            var m = serializer_1.serializeMetric(metric);\r\n            var createMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [m],\r\n            };\r\n            session.send(createMetricsMsg);\r\n            if (typeof metric.value !== \"undefined\") {\r\n                updateMetric(metric);\r\n            }\r\n        });\r\n    };\r\n    var updateMetric = function (metric) {\r\n        joinPromise.then(function () {\r\n            var value = serializer_1.getMetricValueByType(metric);\r\n            var publishMetricsMsg = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: serializer_1.normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name),\r\n                        value: value,\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(publishMetricsMsg);\r\n        });\r\n    };\r\n    return {\r\n        init: init,\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw3/gw3.js\n// module id = 107\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = require(\"../../const/metric-types\");\r\nfunction getMetricTypeByValue(metric) {\r\n    if ((metric.value && metric.value.constructor === Date) || metric.type === metric_types_1.default.TIMESPAN || metric.type === metric_types_1.default.TIMESTAMP) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof metric.value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof metric.value === \"string\" || metric.type === metric_types_1.default.STRING || metric.type === metric_types_1.default.RATE) {\r\n        return \"string\";\r\n    }\r\n    else if (typeof metric.value === \"object\") {\r\n        return \"object\";\r\n    }\r\n}\r\nfunction getTypeByValue(value) {\r\n    if (value.constructor === Date) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof value === \"string\") {\r\n        return \"string\";\r\n    }\r\n    else if (typeof value === \"object\") {\r\n        return \"object\";\r\n    }\r\n    else {\r\n        return \"string\";\r\n    }\r\n}\r\nfunction serializeMetric(metric) {\r\n    var serializedMetrics = {};\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"object\") {\r\n        var values = Object.keys(metric.value).reduce(function (memo, key) {\r\n            var innerType = getTypeByValue(metric.value[key]);\r\n            if (innerType === \"object\") {\r\n                var composite = defineNestedComposite(metric.value[key]);\r\n                memo[key] = {\r\n                    type: \"object\",\r\n                    description: \"\",\r\n                    context: {},\r\n                    composite: composite,\r\n                };\r\n            }\r\n            else {\r\n                memo[key] = {\r\n                    type: innerType,\r\n                    description: \"\",\r\n                    context: {},\r\n                };\r\n            }\r\n            return memo;\r\n        }, {});\r\n        serializedMetrics.composite = values;\r\n    }\r\n    serializedMetrics.name = normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name);\r\n    serializedMetrics.type = type;\r\n    serializedMetrics.description = metric.description;\r\n    serializedMetrics.context = {};\r\n    return serializedMetrics;\r\n}\r\nexports.serializeMetric = serializeMetric;\r\nfunction defineNestedComposite(values) {\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var type = getTypeByValue(values[key]);\r\n        if (type === \"object\") {\r\n            memo[key] = {\r\n                type: \"object\",\r\n                description: \"\",\r\n                context: {},\r\n                composite: defineNestedComposite(values[key]),\r\n            };\r\n        }\r\n        else {\r\n            memo[key] = {\r\n                type: type,\r\n                description: \"\",\r\n                context: {},\r\n            };\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction normalizeMetricName(name) {\r\n    if (typeof name !== \"undefined\" && name.length > 0 && name[0] !== \"/\") {\r\n        return \"/\" + name;\r\n    }\r\n    else {\r\n        return name;\r\n    }\r\n}\r\nexports.normalizeMetricName = normalizeMetricName;\r\nfunction getMetricValueByType(metric) {\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"timestamp\") {\r\n        return Date.now();\r\n    }\r\n    else {\r\n        return publishNestedComposite(metric.value);\r\n    }\r\n}\r\nexports.getMetricValueByType = getMetricValueByType;\r\nfunction publishNestedComposite(values) {\r\n    if (typeof values !== \"object\") {\r\n        return values;\r\n    }\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var value = values[key];\r\n        if (typeof value === \"object\" && value.constructor !== Date) {\r\n            memo[key] = publishNestedComposite(value);\r\n        }\r\n        else if (value.constructor === Date) {\r\n            memo[key] = new Date(value).getTime();\r\n        }\r\n        else if (value.constructor === Boolean) {\r\n            memo[key] = value.toString();\r\n        }\r\n        else {\r\n            memo[key] = value;\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction flatten(arr) {\r\n    return arr.reduce(function (flat, toFlatten) {\r\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\r\n    }, []);\r\n}\r\nfunction getHighestState(arr) {\r\n    return arr.sort(function (a, b) {\r\n        return b.state - a.state;\r\n    })[0];\r\n}\r\nfunction aggregateDescription(arr) {\r\n    var msg = \"\";\r\n    arr.forEach(function (m, idx, a) {\r\n        var path = m.path.join(\".\");\r\n        if (idx === a.length - 1) {\r\n            msg += path + \".\" + m.name + \": \" + m.description;\r\n        }\r\n        else {\r\n            msg += path + \".\" + m.name + \": \" + m.description + \",\";\r\n        }\r\n    });\r\n    if (msg.length > 100) {\r\n        return msg.slice(0, 100) + \"...\";\r\n    }\r\n    else {\r\n        return msg;\r\n    }\r\n}\r\nfunction composeMsgForRootStateMetric(system) {\r\n    var aggregatedState = system.root.getAggregateState();\r\n    var merged = flatten(aggregatedState);\r\n    var highestState = getHighestState(merged);\r\n    var aggregateDesc = aggregateDescription(merged);\r\n    return {\r\n        description: aggregateDesc,\r\n        value: highestState.state,\r\n    };\r\n}\r\nexports.composeMsgForRootStateMetric = composeMsgForRootStateMetric;\r\n//# sourceMappingURL=serializer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw3/serializer.js\n// module id = 108\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3_1 = require(\"./core/protocols/gw3/gw3\");\r\nvar gw1_1 = require(\"./core/protocols/gw1/gw1\");\r\nvar repository_1 = require(\"./repository\");\r\nexports.default = (function (settings) {\r\n    var options = {\r\n        connection: settings.connection,\r\n        identity: settings.identity,\r\n        logger: settings.logger,\r\n        heartbeatInterval: settings.heartbeatInterval,\r\n        settings: {},\r\n        clickStream: settings.clickStream,\r\n    };\r\n    if (!options.connection || typeof options.connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var _protocol;\r\n    if (options.connection.protocolVersion === 3) {\r\n        _protocol = gw3_1.default(options.connection, settings);\r\n    }\r\n    else {\r\n        _protocol = gw1_1.default(options.connection, settings);\r\n    }\r\n    var repo = repository_1.default(options, _protocol);\r\n    var rootSystem = repo.root;\r\n    return rootSystem;\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/main.js\n// module id = 109\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar system_1 = require(\"./system\");\r\nfunction repository(options, protocol) {\r\n    if (!options.identity) {\r\n        throw new Error(\"Identity missing from metrics configuration\");\r\n    }\r\n    if (!options.identity.service || typeof options.identity.service !== \"string\") {\r\n        throw new Error(\"Service missing or invalid in metrics identity configuration\");\r\n    }\r\n    if (!options.identity.system || typeof options.identity.system !== \"string\") {\r\n        throw new Error(\"System missing or invalid in metrics identity configuration\");\r\n    }\r\n    if (!options.identity.instance || typeof options.identity.instance !== \"string\") {\r\n        throw new Error(\"Instance missing or invalid in metrics identity configuration\");\r\n    }\r\n    var identity = options.identity;\r\n    var instance = options.identity.system + \"/\" + options.identity.service + \"/\" + options.identity.instance;\r\n    function _initSystemMetrics(rootSystem, useClickStream) {\r\n        if (typeof navigator !== \"undefined\") {\r\n            rootSystem.stringMetric(\"UserAgent\", navigator.userAgent);\r\n        }\r\n        if (useClickStream && typeof document !== \"undefined\") {\r\n            var clickStream_1 = rootSystem.subSystem(\"ClickStream\");\r\n            var documentClickHandler = function (e) {\r\n                if (!e.target) {\r\n                    return;\r\n                }\r\n                var target = e.target;\r\n                clickStream_1.objectMetric(\"LastBrowserEvent\", {\r\n                    type: \"click\",\r\n                    timestamp: new Date(),\r\n                    target: {\r\n                        className: e.target ? target.className : \"\",\r\n                        id: target.id,\r\n                        type: \"<\" + target.tagName.toLowerCase() + \">\",\r\n                        href: target.href || \"\",\r\n                    },\r\n                });\r\n            };\r\n            clickStream_1.objectMetric(\"Page\", {\r\n                title: document.title,\r\n                page: window.location.href,\r\n            });\r\n            if (document.addEventListener) {\r\n                document.addEventListener(\"click\", documentClickHandler);\r\n            }\r\n            else {\r\n                document.attachEvent(\"onclick\", documentClickHandler);\r\n            }\r\n        }\r\n        var startTime = rootSystem.stringMetric(\"StartTime\", (new Date()).toString());\r\n        var urlMetric = rootSystem.stringMetric(\"StartURL\", \"\");\r\n        var appNameMetric = rootSystem.stringMetric(\"AppName\", \"\");\r\n        if (typeof window !== \"undefined\") {\r\n            if (typeof window.location !== \"undefined\") {\r\n                var startUrl = window.location.href;\r\n                urlMetric.update(startUrl);\r\n            }\r\n            if (typeof window.glue42gd !== \"undefined\") {\r\n                appNameMetric.update(window.glue42gd.appName);\r\n            }\r\n        }\r\n    }\r\n    var me = {\r\n        identity: identity,\r\n        instance: instance,\r\n        get root() {\r\n            return _root;\r\n        },\r\n    };\r\n    protocol.init(me);\r\n    var _root = system_1.default(\"\", me, protocol);\r\n    _initSystemMetrics(_root, options.clickStream || options.clickStream === undefined);\r\n    return me;\r\n}\r\nexports.default = repository;\r\n//# sourceMappingURL=repository.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/repository.js\n// module id = 110\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar address_1 = require(\"./core/metrics/address\");\r\nvar count_1 = require(\"./core/metrics/count\");\r\nvar number_1 = require(\"./core/metrics/number\");\r\nvar object_1 = require(\"./core/metrics/object\");\r\nvar rate_1 = require(\"./core/metrics/rate\");\r\nvar statistics_1 = require(\"./core/metrics/statistics\");\r\nvar string_1 = require(\"./core/metrics/string\");\r\nvar timespan_1 = require(\"./core/metrics/timespan\");\r\nvar timestamp_1 = require(\"./core/metrics/timestamp\");\r\nvar metric_types_1 = require(\"./core/const/metric-types\");\r\nfunction system(name, repo, protocol, parent, description) {\r\n    if (!repo) {\r\n        throw new Error(\"Repository is required\");\r\n    }\r\n    if (!protocol) {\r\n        throw new Error(\"Transport is required\");\r\n    }\r\n    var _transport = protocol;\r\n    var _name = name;\r\n    var _description = description || \"\";\r\n    var _repo = repo;\r\n    var _parent = parent;\r\n    var _path = _buildPath(parent);\r\n    var _state = {};\r\n    var id = _arrayToString(_path, \"/\") + name;\r\n    var identity = repo.identity;\r\n    var root = repo.root;\r\n    var _subSystems = [];\r\n    var _metrics = [];\r\n    function subSystem(nameSystem, descriptionSystem) {\r\n        if (!nameSystem || nameSystem.length === 0) {\r\n            throw new Error(\"name is required\");\r\n        }\r\n        var match = _subSystems.filter(function (s) { return s.name === nameSystem; });\r\n        if (match.length > 0) {\r\n            return match[0];\r\n        }\r\n        var _system = system(nameSystem, _repo, _transport, me, descriptionSystem);\r\n        _subSystems.push(_system);\r\n        return _system;\r\n    }\r\n    function setState(state, stateDescription) {\r\n        _state = { state: state, description: stateDescription };\r\n        _transport.updateSystem(me, _state);\r\n    }\r\n    function stringMetric(definition, value) {\r\n        return _getOrCreateMetric.call(me, definition, metric_types_1.default.STRING, value, function (metricDef) { return string_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function numberMetric(definition, value) {\r\n        return _getOrCreateMetric.call(me, definition, metric_types_1.default.NUMBER, value, function (metricDef) { return number_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function countMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.COUNT, value, function (metricDef) { return count_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function addressMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.ADDRESS, value, function (metricDef) { return address_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function objectMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.OBJECT, value, function (metricDef) { return object_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function timespanMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.TIMESPAN, value, function (metricDef) { return timespan_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function timestampMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.TIMESTAMP, value, function (metricDef) { return timestamp_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function rateMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.RATE, value, function (metricDef) { return rate_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function statisticsMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.STATISTICS, value, function (metricDef) { return statistics_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function _unionToMetricDef(def) {\r\n        var metricDefinition = {};\r\n        if (typeof def === \"string\") {\r\n            metricDefinition.name = def;\r\n        }\r\n        else {\r\n            metricDefinition = def;\r\n        }\r\n        if (metricDefinition.name === undefined) {\r\n            throw new Error(\"Metric name is required\");\r\n        }\r\n        return metricDefinition;\r\n    }\r\n    function _getOrCreateMetric(definition, expectedType, value, createMetric) {\r\n        var metricDefinition = _unionToMetricDef(definition);\r\n        var matching = _metrics.filter(function (shadowedMetric) { return shadowedMetric.name === metricDefinition.name; });\r\n        if (matching.length > 0) {\r\n            var existing = matching[0];\r\n            if (existing.type !== expectedType) {\r\n                throw new Error(\"A metric named \" + metricDefinition.name + \" is already defined with different type.\");\r\n            }\r\n            if (typeof value !== \"undefined\") {\r\n                existing.update(value);\r\n            }\r\n            return existing;\r\n        }\r\n        var metric = createMetric(metricDefinition);\r\n        _metrics.push(metric);\r\n        return metric;\r\n    }\r\n    function _buildPath(shadowedSystem) {\r\n        if (!shadowedSystem || !shadowedSystem.parent) {\r\n            return [];\r\n        }\r\n        var path = _buildPath(shadowedSystem.parent);\r\n        path.push(shadowedSystem.name);\r\n        return path;\r\n    }\r\n    function _arrayToString(path, separator) {\r\n        return ((path && path.length > 0) ? path.join(separator) : \"\");\r\n    }\r\n    function getAggregateState() {\r\n        var aggState = [];\r\n        if (Object.keys(_state).length > 0) {\r\n            aggState.push({\r\n                name: _name,\r\n                path: _path,\r\n                state: _state.state,\r\n                description: _state.description,\r\n            });\r\n        }\r\n        _subSystems.forEach(function (shadowedSubSystem) {\r\n            var result = shadowedSubSystem.getAggregateState();\r\n            if (result.length > 0) {\r\n                aggState.push.apply(aggState, result);\r\n            }\r\n        });\r\n        return aggState;\r\n    }\r\n    var me = {\r\n        get name() {\r\n            return _name;\r\n        },\r\n        get description() {\r\n            return _description;\r\n        },\r\n        get repo() {\r\n            return _repo;\r\n        },\r\n        get parent() {\r\n            return _parent;\r\n        },\r\n        path: _path,\r\n        id: id,\r\n        identity: identity,\r\n        root: root,\r\n        get subSystems() {\r\n            return _subSystems;\r\n        },\r\n        get metrics() {\r\n            return _metrics;\r\n        },\r\n        subSystem: subSystem,\r\n        getState: function () {\r\n            return _state;\r\n        },\r\n        setState: setState,\r\n        stringMetric: stringMetric,\r\n        statisticsMetric: statisticsMetric,\r\n        rateMetric: rateMetric,\r\n        timestampMetric: timestampMetric,\r\n        timespanMetric: timespanMetric,\r\n        objectMetric: objectMetric,\r\n        addressMetric: addressMetric,\r\n        countMetric: countMetric,\r\n        numberMetric: numberMetric,\r\n        getAggregateState: getAggregateState,\r\n    };\r\n    _transport.createSystem(me);\r\n    return me;\r\n}\r\nexports.default = system;\r\n//# sourceMappingURL=system.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/system.js\n// module id = 111\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1() {\r\n    function now() {\r\n        return new Date().getTime();\r\n    }\r\n    var startTime = now();\r\n    var endTime;\r\n    var period;\r\n    function stop() {\r\n        endTime = now();\r\n        period = now() - startTime;\r\n        return period;\r\n    }\r\n    return {\r\n        get startTime() {\r\n            return startTime;\r\n        },\r\n        get endTime() {\r\n            return endTime;\r\n        },\r\n        get period() {\r\n            return period;\r\n        },\r\n        stop: stop\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/timer.js\n// module id = 112\n// module chunks = 0","module.exports = require(\"cluster\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cluster\"\n// module id = 113\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 114\n// module chunks = 0","module.exports = require(\"https\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 115\n// module chunks = 0","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 116\n// module chunks = 0","module.exports = require(\"tls\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tls\"\n// module id = 117\n// module chunks = 0","module.exports = require(\"zlib\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"zlib\"\n// module id = 118\n// module chunks = 0"],"sourceRoot":""}