{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d43585f74f9ee4bf1927","webpack:///./src_js/metrics/core/const/metric-types.js","webpack:///./~/callback-registry/lib/index.js","webpack:///./src_js/metrics/helpers.js","webpack:///external \"util\"","webpack:///./src_js/agm/helpers/random.js","webpack:///./~/shortid/lib/alphabet.js","webpack:///./~/ws/lib/PerMessageDeflate.js","webpack:///./src_js/agm/protocols/gw1/helpers.js","webpack:///external \"events\"","webpack:///./~/shortid/index.js","webpack:///./src_js/agm/helpers/promisify.js","webpack:///./src_js/agm/server/subscription.js","webpack:///./src_js/contexts/contextMessageReplaySpec.js","webpack:///./src_js/utils.js","webpack:///external \"crypto\"","webpack:///./package.json","webpack:///./~/options/lib/options.js","webpack:///./~/ws/lib/BufferUtil.js","webpack:///./~/ws/lib/ErrorCodes.js","webpack:///./~/ws/lib/Extensions.js","webpack:///./~/ws/lib/Receiver.js","webpack:///./~/ws/lib/Sender.js","webpack:///./~/ws/lib/WebSocket.js","webpack:///./src_js/connection/connection.js","webpack:///./src_js/contexts/bridges/gw3/gw3Messages.js","webpack:///./src_js/dummyConnection.js","webpack:///external \"http\"","webpack:///external \"url\"","webpack:///./src_js/glue.js","webpack:///./~/nanoid/format.js","webpack:///./~/nanoid/random.js","webpack:///./~/shortid/lib/build.js","webpack:///./~/shortid/lib/generate.js","webpack:///./~/shortid/lib/index.js","webpack:///./~/shortid/lib/is-valid.js","webpack:///./~/shortid/lib/random/random-byte.js","webpack:///./~/shortid/lib/random/random-from-seed.js","webpack:///./~/shortid/lib/util/cluster-worker-id.js","webpack:///./~/ultron/index.js","webpack:///./~/ws/index.js","webpack:///./~/ws/lib/BufferPool.js","webpack:///./~/ws/lib/BufferUtil.fallback.js","webpack:///./~/ws/lib/Receiver.hixie.js","webpack:///./~/ws/lib/Sender.hixie.js","webpack:///./~/ws/lib/Validation.fallback.js","webpack:///./~/ws/lib/Validation.js","webpack:///./~/ws/lib/WebSocketServer.js","webpack:///./src_js/agm/agm.js","webpack:///./src_js/agm/client/client.js","webpack:///./src_js/agm/client/invoke.js","webpack:///./src_js/agm/client/repository.js","webpack:///./src_js/agm/hc/agm.js","webpack:///./src_js/agm/hc/helpers.js","webpack:///./src_js/agm/hc/native.js","webpack:///./src_js/agm/instance.js","webpack:///./src_js/agm/main.js","webpack:///./src_js/agm/protocols/gw1/client-streaming.js","webpack:///./src_js/agm/protocols/gw1/client.js","webpack:///./src_js/agm/protocols/gw1/factory.js","webpack:///./src_js/agm/protocols/gw1/server-streaming.js","webpack:///./src_js/agm/protocols/gw1/server.js","webpack:///./src_js/agm/protocols/gw3/client-streaming.js","webpack:///./src_js/agm/protocols/gw3/client.js","webpack:///./src_js/agm/protocols/gw3/factory.js","webpack:///./src_js/agm/protocols/gw3/server-streaming.js","webpack:///./src_js/agm/protocols/gw3/server.js","webpack:///./src_js/agm/server/branch.js","webpack:///./src_js/agm/server/repository.js","webpack:///./src_js/agm/server/request.js","webpack:///./src_js/agm/server/server.js","webpack:///./src_js/agm/server/stream.js","webpack:///./src_js/agm/server/streaming.js","webpack:///./src_js/bus/main.js","webpack:///./src_js/bus/protocol.js","webpack:///./src_js/bus/utils.js","webpack:///./src_js/config.js","webpack:///./src_js/connection/gw3Connection.js","webpack:///./src_js/connection/main.js","webpack:///./src_js/connection/messageReplayer.js","webpack:///./src_js/connection/protocols/gw1.js","webpack:///./src_js/connection/protocols/gw3.js","webpack:///./src_js/connection/protocols/gw3Domain.js","webpack:///./src_js/connection/protocols/hc.js","webpack:///./src_js/connection/transports/hc.js","webpack:///./src_js/connection/transports/inproc.js","webpack:///./src_js/connection/transports/ws.js","webpack:///./src_js/contexts/bridges/gw3/gw3Bridge.js","webpack:///./src_js/contexts/bridges/gw3/gw3ContextData.js","webpack:///./src_js/contexts/bridges/hcBridge.js","webpack:///./src_js/contexts/contextsModule.js","webpack:///./src_js/contexts/helpers.js","webpack:///./src_js/contexts/main.js","webpack:///./src_js/logger/levels.js","webpack:///./src_js/logger/logger.js","webpack:///./src_js/logger/main.js","webpack:///./src_js/main.js","webpack:///./src_js/metrics/core/metrics/address.js","webpack:///./src_js/metrics/core/metrics/count.js","webpack:///./src_js/metrics/core/metrics/number.js","webpack:///./src_js/metrics/core/metrics/object.js","webpack:///./src_js/metrics/core/metrics/rate.js","webpack:///./src_js/metrics/core/metrics/statistics.js","webpack:///./src_js/metrics/core/metrics/string.js","webpack:///./src_js/metrics/core/metrics/timespan.js","webpack:///./src_js/metrics/core/metrics/timestamp.js","webpack:///./src_js/metrics/core/protocols/gw1/gw1.js","webpack:///./src_js/metrics/core/protocols/gw1/serializer.js","webpack:///./src_js/metrics/core/protocols/gw3/gw3.js","webpack:///./src_js/metrics/core/protocols/gw3/serializer.js","webpack:///./src_js/metrics/main.js","webpack:///./src_js/metrics/repository.js","webpack:///./src_js/metrics/system.js","webpack:///./src_js/timer.js","webpack:///external \"cluster\"","webpack:///external \"fs\"","webpack:///external \"https\"","webpack:///external \"stream\"","webpack:///external \"tls\"","webpack:///external \"zlib\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACrFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mC;;;;;;ACfA,iC;;;;;;;ACAA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,kC;;;;;;;ACJA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC/RA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;ACtCA,mC;;;;;;;ACAA;AACA;;;;;;;;ACDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qC;;;;;;;ACfA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA,0BAA0B,0CAA0C,EAAE;AACtE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,mCAAmC,EAAE;AAC/D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;ACrCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;ACzBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,iC;;;;;;AC7BA,mC;;;;;;ACAA,kBAAkB,mPAAmP,m+BAAm+B,eAAe,sEAAsE,WAAW,8CAA8C,iCAAiC,+GAA+G,oBAAoB,ge;;;;;;ACA1hD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B,EAAE;AACrD;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;ACZA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;ACtBA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB,OAAO,UAAU;AACjB,KAAK;AACL,GAAG;AACH;;;;;;;ACrEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,4CAA4C;AACrG;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4CAA4C;AACtF;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;ACzrBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpTA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,8BAA8B,EAAE;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,0BAA0B,EAAE;AAC9D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oIAAoI;AACpI;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK,YAAY;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,EAAE;AAC1C;AACA;;;;;;;;ACv6BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;ACvIA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;ACfA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,2C;;;;;;AC5BA,iC;;;;;;ACAA,gC;;;;;;;ACAA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,+CAA+C;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,2BAA2B,+EAA+E,EAAE;AAC5G;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gC;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;;;;;;ACjDA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;ACdA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7CA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;;;;;;;ACdA;;;;;;;;ACAA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACxBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AChIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AChDA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1DA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9CA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;;;;;;ACnLA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACvHA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;ACZA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL;AACA,oCAAoC,wCAAwC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB,EAAE;;AAEzF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,kBAAkB,EAAE;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB,EAAE;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS,kBAAkB,EAAE;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa,kBAAkB,EAAE;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,kBAAkB,EAAE;AAC7B;AACA;;;;;;;;ACpfA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+B;;;;;;;AC5EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,+CAA+C;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sGAAsG;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mEAAmE;AACzF,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mEAAmE;AACzF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yFAAyF;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mGAAmG;AAC3H;AACA;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB,GAAG,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,GAAG,iBAAiB;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,4CAA4C;AACvE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACjaA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACpEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;AC3NA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+B;;;;;;;ACnQA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;ACxFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AC5CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;AChCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,gBAAgB,EAAE;AACtJ;AACA;AACA,oIAAoI,gBAAgB,EAAE;AACtJ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,KAAK;AACL,CAAC;AACD,gC;;;;;;;AC/CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+BAA+B,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uCAAuC,EAAE;AACzC,oCAAoC,8DAA8D,EAAE;AACpG;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;ACpVA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,oCAAoC,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B,EAAE;AACjE;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACrKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,mC;;;;;;;ACnBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uEAAuE,qCAAqC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;ACtUA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,iDAAiD,EAAE;AAClI;AACA;AACA;AACA,2DAA2D,8BAA8B,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+BAA+B,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6BAA6B,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACnKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,wCAAwC,4CAA4C,EAAE;AACtF;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAA+C;AACpF,oCAAoC,kCAAkC,EAAE;AACxE,uCAAuC,0CAA0C,EAAE;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;AC3SA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mCAAmC,EAAE;AACtF,mDAAmD,qCAAqC,EAAE;AAC1F,oDAAoD,6CAA6C,EAAE;AACnG,sDAAsD,+CAA+C,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE,gCAAgC,qCAAqC,EAAE;AACvE,mCAAmC,yCAAyC,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,gBAAgB;AACpF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;AC9GA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mC;;;;;;;ACjDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B,EAAE;AACnF,sDAAsD,iCAAiC,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uEAAuE,qCAAqC;AAC5G;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;ACtPA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uCAAuC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,mEAAmE,8BAA8B;AACjG,sDAAsD,2CAA2C,EAAE;AACnG,uDAAuD,uCAAuC,EAAE;AAChG;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACjNA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACzBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8CAA8C,UAAU,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;AC/CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;ACtBA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,2CAA2C,+DAA+D,EAAE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uCAAuC,EAAE;AAC5F;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB,EAAE,EAAE;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,4CAA4C,EAAE;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACxTA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB,EAAE;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACtEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,uCAAuC,EAAE;AACjG,uDAAuD,sCAAsC,EAAE;AAC/F,yDAAyD,wCAAwC,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;AC3CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,CAAC;AACD,gC;;;;;;;AChBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,qFAAqF;AACnI;AACA;AACA,gDAAgD,+EAA+E;AAC/H,2FAA2F,8CAA8C,EAAE;AAC3I;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,6CAA6C,sBAAsB,EAAE;AACrE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0EAA0E,8CAA8C,EAAE;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;AC3EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iC;;;;;;;ACvBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACpQA;AACA;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,EAAE;AAChD,yBAAyB,mBAAmB,EAAE;AAC9C,wBAAwB,kBAAkB,EAAE;AAC5C,oCAAoC,8BAA8B,EAAE;AACpE,oCAAoC,8BAA8B,EAAE;AACpE,gCAAgC,0BAA0B,EAAE;AAC5D,4BAA4B,sBAAsB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;ACnEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gC;;;;;;;AC7CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,wCAAwC,EAAE;AACrH;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2C;;;;;;;AC3EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,mCAAmC,iBAAiB,yBAAyB,EAAE,EAAE;AACjF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+B;;;;;;;ACjDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gCAAgC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACtNA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kCAAkC,EAAE;AACzF,mDAAmD,gCAAgC,EAAE;AACrF,oDAAoD,kCAAkC,EAAE;AACxF;AACA;AACA,sDAAsD,kCAAkC,EAAE;AAC1F,SAAS;AACT;AACA;AACA;AACA,sDAAsD,gCAAgC,EAAE;AACxF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,uCAAuC,sCAAsC,EAAE;AAC/E,wCAAwC,uCAAuC,EAAE;AACjF,2CAA2C,0CAA0C,EAAE;AACvF;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qC;;;;;;;ACzMA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8B;;;;;;;AClCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8B;;;;;;;AC3BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;AC7CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8B;;;;;;;ACnGA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,oCAAoC,EAAE;AACxG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,mDAAmD,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,GAAG,oBAAoB;AACpC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,SAAS,IAAI,GAAG,oBAAoB;AACpC;AACA,8CAA8C,uBAAuB,0BAA0B,EAAE,GAAG,gCAAgC;AACpI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa,EAAE,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uCAAuC,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,mCAAmC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,mCAAmC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,0CAA0C;AAC1H;AACA;AACA;AACA,0BAA0B,UAAU,aAAa,WAAW;AAC5D;AACA;AACA;AACA;AACA,8EAA8E,mBAAmB,qBAAqB,mBAAmB;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qCAAqC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB,kBAAkB,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB,kBAAkB,EAAE;AAClD;AACA;AACA,qBAAqB,UAAU,aAAa;AAC5C;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;ACrdA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;AC7BA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS,EAAE,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;AC1FA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,oDAAoD,uCAAuC,EAAE,aAAa,EAAE;AAC1L;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;ACjEA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;ACjIA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,gC;;;;;;;ACJA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACpBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;ACxKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gC;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;ACTA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;ACjDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACjEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACjEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACxDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;ACjDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACjDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACjDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;ACzDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;ACrDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,sCAAsC,EAAE;AACtF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACzFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACrFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACzJA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACvKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gC;;;;;;;AC5BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;AC7EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8BAA8B,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mHAAmH,2DAA2D,EAAE;AAChL;AACA;AACA,mHAAmH,2DAA2D,EAAE;AAChL;AACA;AACA,oHAAoH,0DAA0D,EAAE;AAChL;AACA;AACA,sHAAsH,4DAA4D,EAAE;AACpL;AACA;AACA,qHAAqH,2DAA2D,EAAE;AAClL;AACA;AACA,uHAAuH,6DAA6D,EAAE;AACtL;AACA;AACA,wHAAwH,8DAA8D,EAAE;AACxL;AACA;AACA,mHAAmH,yDAAyD,EAAE;AAC9K;AACA;AACA,yHAAyH,+DAA+D,EAAE;AAC1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sDAAsD,EAAE;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AChLA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iC;;;;;;AC5BA,oC;;;;;;ACAA,+B;;;;;;ACAA,kC;;;;;;ACAA,mC;;;;;;ACAA,gC;;;;;;ACAA,iC","file":"tick42-glue-core.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"util\"), require(\"events\"), require(\"crypto\"), require(\"http\"), require(\"url\"), require(\"cluster\"), require(\"fs\"), require(\"https\"), require(\"stream\"), require(\"tls\"), require(\"zlib\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"tick42-glue-core\", [\"util\", \"events\", \"crypto\", \"http\", \"url\", \"cluster\", \"fs\", \"https\", \"stream\", \"tls\", \"zlib\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tick42-glue-core\"] = factory(require(\"util\"), require(\"events\"), require(\"crypto\"), require(\"http\"), require(\"url\"), require(\"cluster\"), require(\"fs\"), require(\"https\"), require(\"stream\"), require(\"tls\"), require(\"zlib\"));\n\telse\n\t\troot[\"tick42-glue-core\"] = factory(root[\"util\"], root[\"events\"], root[\"crypto\"], root[\"http\"], root[\"url\"], root[\"cluster\"], root[\"fs\"], root[\"https\"], root[\"stream\"], root[\"tls\"], root[\"zlib\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_14__, __WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_27__, __WEBPACK_EXTERNAL_MODULE_113__, __WEBPACK_EXTERNAL_MODULE_114__, __WEBPACK_EXTERNAL_MODULE_115__, __WEBPACK_EXTERNAL_MODULE_116__, __WEBPACK_EXTERNAL_MODULE_117__, __WEBPACK_EXTERNAL_MODULE_118__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 95);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d43585f74f9ee4bf1927","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    DEFAULT: 0,\r\n    STRING: 1,\r\n    NUMBER: 2,\r\n    COUNT: 3,\r\n    RATE: 4,\r\n    STATISTICS: 6,\r\n    TIMESTAMP: 7,\r\n    ADDRESS: 8,\r\n    TIMESPAN: 10,\r\n    OBJECT: 11\r\n};\r\n//# sourceMappingURL=metric-types.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/const/metric-types.js\n// module id = 0\n// module chunks = 0","\"use strict\";\r\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            callbacks[key] = allForKey;\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear\r\n    };\r\n}\r\n;\r\ncreateRegistry.default = createRegistry;\r\nmodule.exports = createRegistry;\r\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/callback-registry/lib/index.js\n// module id = 1\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    validate: function (definition, parent, transport) {\r\n        if (definition === null || typeof definition !== \"object\") {\r\n            throw new Error(\"Missing definition\");\r\n        }\r\n        if (parent === null || typeof parent !== \"object\") {\r\n            throw new Error(\"Missing parent\");\r\n        }\r\n        if (transport === null || typeof transport !== \"object\") {\r\n            throw new Error(\"Missing transport\");\r\n        }\r\n    },\r\n};\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/helpers.js\n// module id = 2\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 3\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar shortid = require(\"shortid\");\r\nexports.default = shortid;\r\n//# sourceMappingURL=random.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/helpers/random.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nfunction get () {\n  return alphabet || ORIGINAL;\n}\n\nmodule.exports = {\n    get: get,\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/alphabet.js\n// module id = 5\n// module chunks = 0","\nvar zlib = require('zlib');\n\nvar AVAILABLE_WINDOW_BITS = [8, 9, 10, 11, 12, 13, 14, 15];\nvar DEFAULT_WINDOW_BITS = 15;\nvar DEFAULT_MEM_LEVEL = 8;\n\nPerMessageDeflate.extensionName = 'permessage-deflate';\n\n/**\n * Per-message Compression Extensions implementation\n */\n\nfunction PerMessageDeflate(options, isServer) {\n  this._options = options || {};\n  this._isServer = !!isServer;\n  this._inflate = null;\n  this._deflate = null;\n  this.params = null;\n}\n\n/**\n * Create extension parameters offer\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.offer = function() {\n  var params = {};\n  if (this._options.serverNoContextTakeover) {\n    params.server_no_context_takeover = true;\n  }\n  if (this._options.clientNoContextTakeover) {\n    params.client_no_context_takeover = true;\n  }\n  if (this._options.serverMaxWindowBits) {\n    params.server_max_window_bits = this._options.serverMaxWindowBits;\n  }\n  if (this._options.clientMaxWindowBits) {\n    params.client_max_window_bits = this._options.clientMaxWindowBits;\n  } else if (this._options.clientMaxWindowBits == null) {\n    params.client_max_window_bits = true;\n  }\n  return params;\n};\n\n/**\n * Accept extension offer\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.accept = function(paramsList) {\n  paramsList = this.normalizeParams(paramsList);\n\n  var params;\n  if (this._isServer) {\n    params = this.acceptAsServer(paramsList);\n  } else {\n    params = this.acceptAsClient(paramsList);\n  }\n\n  this.params = params;\n  return params;\n};\n\n/**\n * Accept extension offer from client\n *\n * @api private\n */\n\nPerMessageDeflate.prototype.acceptAsServer = function(paramsList) {\n  var accepted = {};\n  var result = paramsList.some(function(params) {\n    accepted = {};\n    if (this._options.serverNoContextTakeover === false && params.server_no_context_takeover) {\n      return;\n    }\n    if (this._options.serverMaxWindowBits === false && params.server_max_window_bits) {\n      return;\n    }\n    if (typeof this._options.serverMaxWindowBits === 'number' &&\n        typeof params.server_max_window_bits === 'number' &&\n        this._options.serverMaxWindowBits > params.server_max_window_bits) {\n      return;\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n      return;\n    }\n\n    if (this._options.serverNoContextTakeover || params.server_no_context_takeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover !== false && params.client_no_context_takeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof this._options.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n    } else if (typeof params.server_max_window_bits === 'number') {\n      accepted.server_max_window_bits = params.server_max_window_bits;\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits !== false && typeof params.client_max_window_bits === 'number') {\n      accepted.client_max_window_bits = params.client_max_window_bits;\n    }\n    return true;\n  }, this);\n\n  if (!result) {\n    throw new Error('Doesn\\'t support the offered configuration');\n  }\n\n  return accepted;\n};\n\n/**\n * Accept extension response from server\n *\n * @api privaye\n */\n\nPerMessageDeflate.prototype.acceptAsClient = function(paramsList) {\n  var params = paramsList[0];\n  if (this._options.clientNoContextTakeover != null) {\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n  }\n  if (this._options.clientMaxWindowBits != null) {\n    if (this._options.clientMaxWindowBits === false && params.client_max_window_bits) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n    if (typeof this._options.clientMaxWindowBits === 'number' &&\n        (!params.client_max_window_bits || params.client_max_window_bits > this._options.clientMaxWindowBits)) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n  }\n  return params;\n};\n\n/**\n * Normalize extensions parameters\n *\n * @api private\n */\n\nPerMessageDeflate.prototype.normalizeParams = function(paramsList) {\n  return paramsList.map(function(params) {\n    Object.keys(params).forEach(function(key) {\n      var value = params[key];\n      if (value.length > 1) {\n        throw new Error('Multiple extension parameters for ' + key);\n      }\n\n      value = value[0];\n\n      switch (key) {\n      case 'server_no_context_takeover':\n      case 'client_no_context_takeover':\n        if (value !== true) {\n          throw new Error('invalid extension parameter value for ' + key + ' (' + value + ')');\n        }\n        params[key] = true;\n        break;\n      case 'server_max_window_bits':\n      case 'client_max_window_bits':\n        if (typeof value === 'string') {\n          value = parseInt(value, 10);\n          if (!~AVAILABLE_WINDOW_BITS.indexOf(value)) {\n            throw new Error('invalid extension parameter value for ' + key + ' (' + value + ')');\n          }\n        }\n        if (!this._isServer && value === true) {\n          throw new Error('Missing extension parameter value for ' + key);\n        }\n        params[key] = value;\n        break;\n      default:\n        throw new Error('Not defined extension parameter (' + key + ')');\n      }\n    }, this);\n    return params;\n  }, this);\n};\n\n/**\n * Decompress message\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.decompress = function (data, fin, callback) {\n  var endpoint = this._isServer ? 'client' : 'server';\n\n  if (!this._inflate) {\n    var maxWindowBits = this.params[endpoint + '_max_window_bits'];\n    this._inflate = zlib.createInflateRaw({\n      windowBits: 'number' === typeof maxWindowBits ? maxWindowBits : DEFAULT_WINDOW_BITS\n    });\n  }\n\n  var self = this;\n  var buffers = [];\n\n  this._inflate.on('error', onError).on('data', onData);\n  this._inflate.write(data);\n  if (fin) {\n    this._inflate.write(new Buffer([0x00, 0x00, 0xff, 0xff]));\n  }\n  this._inflate.flush(function() {\n    cleanup();\n    callback(null, Buffer.concat(buffers));\n  });\n\n  function onError(err) {\n    cleanup();\n    callback(err);\n  }\n\n  function onData(data) {\n    buffers.push(data);\n  }\n\n  function cleanup() {\n    self._inflate.removeListener('error', onError);\n    self._inflate.removeListener('data', onData);\n    if (fin && self.params[endpoint + '_no_context_takeover']) {\n      self._inflate = null;\n    }\n  }\n};\n\n/**\n * Compress message\n *\n * @api public\n */\n\nPerMessageDeflate.prototype.compress = function (data, fin, callback) {\n  var endpoint = this._isServer ? 'server' : 'client';\n\n  if (!this._deflate) {\n    var maxWindowBits = this.params[endpoint + '_max_window_bits'];\n    this._deflate = zlib.createDeflateRaw({\n      flush: zlib.Z_SYNC_FLUSH,\n      windowBits: 'number' === typeof maxWindowBits ? maxWindowBits : DEFAULT_WINDOW_BITS,\n      memLevel: this._options.memLevel || DEFAULT_MEM_LEVEL\n    });\n  }\n\n  var self = this;\n  var buffers = [];\n\n  this._deflate.on('error', onError).on('data', onData);\n  this._deflate.write(data);\n  this._deflate.flush(function() {\n    cleanup();\n    var data = Buffer.concat(buffers);\n    if (fin) {\n      data = data.slice(0, data.length - 4);\n    }\n    callback(null, data);\n  });\n\n  function onError(err) {\n    cleanup();\n    callback(err);\n  }\n\n  function onData(data) {\n    buffers.push(data);\n  }\n\n  function cleanup() {\n    self._deflate.removeListener('error', onError);\n    self._deflate.removeListener('data', onData);\n    if (fin && self.params[endpoint + '_no_context_takeover']) {\n      self._deflate = null;\n    }\n  }\n};\n\nmodule.exports = PerMessageDeflate;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/PerMessageDeflate.js\n// module id = 6\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction convertInfoToInstance(info) {\r\n    if (typeof info !== \"object\") {\r\n        info = {};\r\n    }\r\n    return {\r\n        application: info.ApplicationName,\r\n        environment: info.Environment,\r\n        machine: info.MachineName,\r\n        pid: info.ProcessId,\r\n        region: info.Region,\r\n        service: info.ServiceName,\r\n        user: info.UserName,\r\n        started: info.ProcessStartTime,\r\n    };\r\n}\r\nexports.convertInfoToInstance = convertInfoToInstance;\r\nfunction isStreamingFlagSet(flags) {\r\n    if (typeof flags !== \"number\" || isNaN(flags)) {\r\n        return false;\r\n    }\r\n    var mask = 32;\r\n    var result = flags & mask;\r\n    return result === mask;\r\n}\r\nexports.isStreamingFlagSet = isStreamingFlagSet;\r\nfunction convertInstance(instance) {\r\n    return {\r\n        ApplicationName: instance.application,\r\n        ProcessId: instance.pid,\r\n        MachineName: instance.machine,\r\n        UserName: instance.user,\r\n        Environment: instance.environment,\r\n        Region: instance.region,\r\n    };\r\n}\r\nexports.convertInstance = convertInstance;\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/helpers.js\n// module id = 7\n// module chunks = 0","module.exports = require(\"events\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"events\"\n// module id = 8\n// module chunks = 0","'use strict';\nmodule.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/index.js\n// module id = 9\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1(promise, successCallback, errorCallback) {\r\n    if (typeof successCallback !== \"function\" && typeof errorCallback !== \"function\") {\r\n        return promise;\r\n    }\r\n    if (typeof successCallback !== \"function\") {\r\n        successCallback = function () { };\r\n    }\r\n    else if (typeof errorCallback !== \"function\") {\r\n        errorCallback = function () { };\r\n    }\r\n    promise.then(successCallback, errorCallback);\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=promisify.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/helpers/promisify.js\n// module id = 10\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerSubscription = (function () {\r\n    function ServerSubscription(protocol, repoMethod, subscription) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.subscription = subscription;\r\n    }\r\n    Object.defineProperty(ServerSubscription.prototype, \"stream\", {\r\n        get: function () { return this.repoMethod.stream; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"arguments\", {\r\n        get: function () { return this.subscription.arguments || {}; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"branchKey\", {\r\n        get: function () { return this.subscription.branchKey; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"instance\", {\r\n        get: function () { return this.subscription.instance; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerSubscription.prototype.close = function () {\r\n        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);\r\n    };\r\n    ServerSubscription.prototype.push = function (data) {\r\n        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);\r\n    };\r\n    return ServerSubscription;\r\n}());\r\nexports.default = ServerSubscription;\r\n//# sourceMappingURL=subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/subscription.js\n// module id = 11\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar msg = require(\"./bridges/gw3/gw3Messages\");\r\nexports.ContextMessageReplaySpec = {\r\n    get name() {\r\n        return \"context\";\r\n    },\r\n    get types() {\r\n        return [\r\n            msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY\r\n        ];\r\n    }\r\n};\r\n//# sourceMappingURL=contextMessageReplaySpec.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/contextMessageReplaySpec.js\n// module id = 12\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Utils = (function () {\r\n    function Utils() {\r\n    }\r\n    Utils.getGDMajorVersion = function () {\r\n        if (typeof window === \"undefined\") {\r\n            return -1;\r\n        }\r\n        if (!window.glueDesktop) {\r\n            return -1;\r\n        }\r\n        if (!window.glueDesktop.version) {\r\n            return -1;\r\n        }\r\n        var ver = Number(window.glueDesktop.version.substr(0, 1));\r\n        return isNaN(ver) ? -1 : ver;\r\n    };\r\n    Utils.isNode = function () {\r\n        try {\r\n            return Object.prototype.toString.call(global.process) === \"[object process]\";\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    };\r\n    return Utils;\r\n}());\r\nexports.default = Utils;\r\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/utils.js\n// module id = 13\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 14\n// module chunks = 0","module.exports = {\"name\":\"tick42-glue-core\",\"version\":\"4.3.7\",\"description\":\"Glue42 core library including logger, connection, agm and metrics\",\"main\":\"./dist/node/tick42-glue-core.js\",\"types\":\"./glue.d.ts\",\"browser\":\"./dist/web/tick42-glue-core.js\",\"scripts\":{\"init-dev-mode\":\"node ./build/scripts/init-dev-mode.js\",\"remove-installed-dependencies\":\"node ./build/scripts/remove-installed-dependencies.js\",\"clean\":\"node ./build/scripts/clean.js\",\"pre:build\":\"npm run clean && npm run tslint && tsc && set NODE_ENV=development\",\"file-versionify\":\"node ./build/scripts/file-versionify.js\",\"tslint\":\"tslint -t codeFrame ./src/**.ts\",\"tslint:fix\":\"tslint -t codeFrame --fix ./src/**.ts\",\"watch\":\"onchange ./src/**/*.ts -- npm run build:dev\",\"build:dev\":\"npm run pre:build && set NODE_ENV=development && webpack && npm run file-versionify\",\"build:prod\":\"npm run pre:build && set NODE_ENV=development && webpack && set NODE_ENV=production && webpack && npm run file-versionify\",\"docs\":\"typedoc --options typedoc.json ./src\",\"prepublish\":\"npm run build:prod && npm run test:only\",\"test\":\"npm run build:dev && npm run test:only\",\"test:only\":\"mocha ./tests/ --recursive\",\"test:core\":\"mocha ./tests/core\",\"test:agm\":\"mocha ./tests/agm\",\"test:bus\":\"mocha ./tests/bus\"},\"repository\":{\"type\":\"git\",\"url\":\"https://stash.tick42.com/scm/tg/js-glue-core.git\"},\"author\":{\"name\":\"Tick42\",\"url\":\"http://www.glue42.com\"},\"license\":\"ISC\",\"dependencies\":{\"callback-registry\":\"^2.4.0\",\"es6-promise\":\"^4.1.0\",\"shortid\":\"^2.2.6\",\"util-deprecate\":\"^1.0.2\",\"ws\":\"^0.7.2\"},\"devDependencies\":{\"@types/node\":\"^10.7.0\",\"@types/shortid\":\"0.0.29\",\"archiver\":\"^1.3.0\",\"babel-core\":\"^6.25.0\",\"babel-loader\":\"^6.4.1\",\"babel-plugin-add-module-exports\":\"^0.2.1\",\"babel-preset-es2015\":\"^6.16.0\",\"babel-preset-stage-2\":\"^6.22.0\",\"chai\":\"^4.0.2\",\"deep-equal\":\"^1.0.1\",\"mocha\":\"^2.5.3\",\"onchange\":\"3.*\",\"pre-commit\":\"^1.1.3\",\"readline-sync\":\"^1.4.5\",\"shelljs\":\"^0.6.0\",\"tick42-gateway\":\"0.2.7\",\"tick42-webpack-config\":\"4.1.6\",\"tslint\":\"^5.11.0\",\"typescript\":\"^3.0.1\",\"webpack\":\"2.3.3\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./package.json\n// module id = 15\n// module chunks = 0","/*!\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar fs = require('fs');\n\nfunction Options(defaults) {\n  var internalValues = {};\n  var values = this.value = {};\n  Object.keys(defaults).forEach(function(key) {\n    internalValues[key] = defaults[key];\n    Object.defineProperty(values, key, {\n      get: function() { return internalValues[key]; },\n      configurable: false,\n      enumerable: true\n    });\n  });\n  this.reset = function() {\n    Object.keys(defaults).forEach(function(key) {\n      internalValues[key] = defaults[key];\n    });\n    return this;\n  };\n  this.merge = function(options, required) {\n    options = options || {};\n    if (Object.prototype.toString.call(required) === '[object Array]') {\n      var missing = [];\n      for (var i = 0, l = required.length; i < l; ++i) {\n        var key = required[i];\n        if (!(key in options)) {\n          missing.push(key);\n        }\n      }\n      if (missing.length > 0) {\n        if (missing.length > 1) {\n          throw new Error('options ' +\n            missing.slice(0, missing.length - 1).join(', ') + ' and ' +\n            missing[missing.length - 1] + ' must be defined');\n        }\n        else throw new Error('option ' + missing[0] + ' must be defined');\n      }\n    }\n    Object.keys(options).forEach(function(key) {\n      if (key in internalValues) {\n        internalValues[key] = options[key];\n      }\n    });\n    return this;\n  };\n  this.copy = function(keys) {\n    var obj = {};\n    Object.keys(defaults).forEach(function(key) {\n      if (keys.indexOf(key) !== -1) {\n        obj[key] = values[key];\n      }\n    });\n    return obj;\n  };\n  this.read = function(filename, cb) {\n    if (typeof cb == 'function') {\n      var self = this;\n      fs.readFile(filename, function(error, data) {\n        if (error) return cb(error);\n        var conf = JSON.parse(data);\n        self.merge(conf);\n        cb();\n      });\n    }\n    else {\n      var conf = JSON.parse(fs.readFileSync(filename));\n      this.merge(conf);\n    }\n    return this;\n  };\n  this.isDefined = function(key) {\n    return typeof values[key] != 'undefined';\n  };\n  this.isDefinedAndNonNull = function(key) {\n    return typeof values[key] != 'undefined' && values[key] !== null;\n  };\n  Object.freeze(values);\n  Object.freeze(this);\n}\n\nmodule.exports = Options;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/options/lib/options.js\n// module id = 16\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = require('bufferutil');\n} catch (e) {\n  module.exports = require('./BufferUtil.fallback');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/BufferUtil.js\n// module id = 17\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports = {\n  isValidErrorCode: function(code) {\n    return (code >= 1000 && code <= 1011 && code != 1004 && code != 1005 && code != 1006) ||\n         (code >= 3000 && code <= 4999);\n  },\n  1000: 'normal',\n  1001: 'going away',\n  1002: 'protocol error',\n  1003: 'unsupported data',\n  1004: 'reserved',\n  1005: 'reserved for extensions',\n  1006: 'reserved for extensions',\n  1007: 'inconsistent or invalid data',\n  1008: 'policy violation',\n  1009: 'message too big',\n  1010: 'extension handshake missing',\n  1011: 'an unexpected condition prevented the request from being fulfilled',\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/ErrorCodes.js\n// module id = 18\n// module chunks = 0","\nvar util = require('util');\n\n/**\n * Module exports.\n */\n\nexports.parse = parse;\nexports.format = format;\n\n/**\n * Parse extensions header value\n */\n\nfunction parse(value) {\n  value = value || '';\n\n  var extensions = {};\n\n  value.split(',').forEach(function(v) {\n    var params = v.split(';');\n    var token = params.shift().trim();\n    var paramsList = extensions[token] = extensions[token] || [];\n    var parsedParams = {};\n\n    params.forEach(function(param) {\n      var parts = param.trim().split('=');\n      var key = parts[0];\n      var value = parts[1];\n      if (typeof value === 'undefined') {\n        value = true;\n      } else {\n        // unquote value\n        if (value[0] === '\"') {\n          value = value.slice(1);\n        }\n        if (value[value.length - 1] === '\"') {\n          value = value.slice(0, value.length - 1);\n        }\n      }\n      (parsedParams[key] = parsedParams[key] || []).push(value);\n    });\n\n    paramsList.push(parsedParams);\n  });\n\n  return extensions;\n}\n\n/**\n * Format extensions header value\n */\n\nfunction format(value) {\n  return Object.keys(value).map(function(token) {\n    var paramsList = value[token];\n    if (!util.isArray(paramsList)) {\n      paramsList = [paramsList];\n    }\n    return paramsList.map(function(params) {\n      return [token].concat(Object.keys(params).map(function(k) {\n        var p = params[k];\n        if (!util.isArray(p)) p = [p];\n        return p.map(function(v) {\n          return v === true ? k : k + '=' + v;\n        }).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Extensions.js\n// module id = 19\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util')\n  , Validation = require('./Validation').Validation\n  , ErrorCodes = require('./ErrorCodes')\n  , BufferPool = require('./BufferPool')\n  , bufferUtil = require('./BufferUtil').BufferUtil\n  , PerMessageDeflate = require('./PerMessageDeflate');\n\n/**\n * HyBi Receiver implementation\n */\n\nfunction Receiver (extensions) {\n  // memory pool for fragmented messages\n  var fragmentedPoolPrevUsed = -1;\n  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {\n    return db.used + length;\n  }, function(db) {\n    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed >= 0 ?\n      (fragmentedPoolPrevUsed + db.used) / 2 :\n      db.used;\n  });\n\n  // memory pool for unfragmented messages\n  var unfragmentedPoolPrevUsed = -1;\n  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {\n    return db.used + length;\n  }, function(db) {\n    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed >= 0 ?\n      (unfragmentedPoolPrevUsed + db.used) / 2 :\n      db.used;\n  });\n\n  this.extensions = extensions || {};\n  this.state = {\n    activeFragmentedOperation: null,\n    lastFragment: false,\n    masked: false,\n    opcode: 0,\n    fragmentedOperation: false\n  };\n  this.overflow = [];\n  this.headerBuffer = new Buffer(10);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.currentMessage = [];\n  this.messageHandlers = [];\n  this.expectHeader(2, this.processPacket);\n  this.dead = false;\n  this.processing = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  var dataLength = data.length;\n  if (dataLength == 0) return;\n  if (this.expectBuffer == null) {\n    this.overflow.push(data);\n    return;\n  }\n  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);\n  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);\n  this.expectOffset += toRead;\n  if (toRead < dataLength) {\n    this.overflow.push(data.slice(toRead));\n  }\n  while (this.expectBuffer && this.expectOffset == this.expectBuffer.length) {\n    var bufferForHandler = this.expectBuffer;\n    this.expectBuffer = null;\n    this.expectOffset = 0;\n    this.expectHandler.call(this, bufferForHandler);\n  }\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.overflow = null;\n  this.headerBuffer = null;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.unfragmentedBufferPool = null;\n  this.fragmentedBufferPool = null;\n  this.state = null;\n  this.currentMessage = null;\n  this.onerror = null;\n  this.ontext = null;\n  this.onbinary = null;\n  this.onclose = null;\n  this.onping = null;\n  this.onpong = null;\n};\n\n/**\n * Waits for a certain amount of header bytes to be available, then fires a callback.\n *\n * @api private\n */\n\nReceiver.prototype.expectHeader = function(length, handler) {\n  if (length == 0) {\n    handler(null);\n    return;\n  }\n  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);\n  this.expectHandler = handler;\n  var toRead = length;\n  while (toRead > 0 && this.overflow.length > 0) {\n    var fromOverflow = this.overflow.pop();\n    if (toRead < fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));\n    var read = Math.min(fromOverflow.length, toRead);\n    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\n    this.expectOffset += read;\n    toRead -= read;\n  }\n};\n\n/**\n * Waits for a certain amount of data bytes to be available, then fires a callback.\n *\n * @api private\n */\n\nReceiver.prototype.expectData = function(length, handler) {\n  if (length == 0) {\n    handler(null);\n    return;\n  }\n  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);\n  this.expectHandler = handler;\n  var toRead = length;\n  while (toRead > 0 && this.overflow.length > 0) {\n    var fromOverflow = this.overflow.pop();\n    if (toRead < fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));\n    var read = Math.min(fromOverflow.length, toRead);\n    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\n    this.expectOffset += read;\n    toRead -= read;\n  }\n};\n\n/**\n * Allocates memory from the buffer pool.\n *\n * @api private\n */\n\nReceiver.prototype.allocateFromPool = function(length, isFragmented) {\n  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);\n};\n\n/**\n * Start processing a new packet.\n *\n * @api private\n */\n\nReceiver.prototype.processPacket = function (data) {\n  if (this.extensions[PerMessageDeflate.extensionName]) {\n    if ((data[0] & 0x30) != 0) {\n      this.error('reserved fields (2, 3) must be empty', 1002);\n      return;\n    }\n  } else {\n    if ((data[0] & 0x70) != 0) {\n      this.error('reserved fields must be empty', 1002);\n      return;\n    }\n  }\n  this.state.lastFragment = (data[0] & 0x80) == 0x80;\n  this.state.masked = (data[1] & 0x80) == 0x80;\n  var compressed = (data[0] & 0x40) == 0x40;\n  var opcode = data[0] & 0xf;\n  if (opcode === 0) {\n    if (compressed) {\n      this.error('continuation frame cannot have the Per-message Compressed bits', 1002);\n      return;\n    }\n    // continuation frame\n    this.state.fragmentedOperation = true;\n    this.state.opcode = this.state.activeFragmentedOperation;\n    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {\n      this.error('continuation frame cannot follow current opcode', 1002);\n      return;\n    }\n  }\n  else {\n    if (opcode < 3 && this.state.activeFragmentedOperation != null) {\n      this.error('data frames after the initial data frame must have opcode 0', 1002);\n      return;\n    }\n    if (opcode >= 8 && compressed) {\n      this.error('control frames cannot have the Per-message Compressed bits', 1002);\n      return;\n    }\n    this.state.compressed = compressed;\n    this.state.opcode = opcode;\n    if (this.state.lastFragment === false) {\n      this.state.fragmentedOperation = true;\n      this.state.activeFragmentedOperation = opcode;\n    }\n    else this.state.fragmentedOperation = false;\n  }\n  var handler = opcodes[this.state.opcode];\n  if (typeof handler == 'undefined') this.error('no handler for opcode ' + this.state.opcode, 1002);\n  else {\n    handler.start.call(this, data);\n  }\n};\n\n/**\n * Endprocessing a packet.\n *\n * @api private\n */\n\nReceiver.prototype.endPacket = function() {\n  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);\n  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(false);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  if (this.state.lastFragment && this.state.opcode === this.state.activeFragmentedOperation) {\n    // end current fragmented operation\n    this.state.activeFragmentedOperation = null;\n  }\n  this.state.lastFragment = false;\n  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;\n  this.state.masked = false;\n  this.expectHeader(2, this.processPacket);\n};\n\n/**\n * Reset the parser state.\n *\n * @api private\n */\n\nReceiver.prototype.reset = function() {\n  if (this.dead) return;\n  this.state = {\n    activeFragmentedOperation: null,\n    lastFragment: false,\n    masked: false,\n    opcode: 0,\n    fragmentedOperation: false\n  };\n  this.fragmentedBufferPool.reset(true);\n  this.unfragmentedBufferPool.reset(true);\n  this.expectOffset = 0;\n  this.expectBuffer = null;\n  this.expectHandler = null;\n  this.overflow = [];\n  this.currentMessage = [];\n  this.messageHandlers = [];\n};\n\n/**\n * Unmask received data.\n *\n * @api private\n */\n\nReceiver.prototype.unmask = function (mask, buf, binary) {\n  if (mask != null && buf != null) bufferUtil.unmask(buf, mask);\n  if (binary) return buf;\n  return buf != null ? buf.toString('utf8') : '';\n};\n\n/**\n * Concatenates a list of buffers.\n *\n * @api private\n */\n\nReceiver.prototype.concatBuffers = function(buffers) {\n  var length = 0;\n  for (var i = 0, l = buffers.length; i < l; ++i) length += buffers[i].length;\n  var mergedBuffer = new Buffer(length);\n  bufferUtil.merge(mergedBuffer, buffers);\n  return mergedBuffer;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, protocolErrorCode) {\n  this.reset();\n  this.onerror(reason, protocolErrorCode);\n  return this;\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nReceiver.prototype.flush = function() {\n  if (this.processing || this.dead) return;\n\n  var handler = this.messageHandlers.shift();\n  if (!handler) return;\n\n  this.processing = true;\n  var self = this;\n\n  handler(function() {\n    self.processing = false;\n    self.flush();\n  });\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nReceiver.prototype.applyExtensions = function(messageBuffer, fin, compressed, callback) {\n  var self = this;\n  if (compressed) {\n    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {\n      if (self.dead) return;\n      if (err) {\n        callback(new Error('invalid compressed data'));\n        return;\n      }\n      callback(null, buffer);\n    });\n  } else {\n    callback(null, messageBuffer);\n  }\n};\n\n/**\n * Buffer utilities\n */\n\nfunction readUInt16BE(start) {\n  return (this[start]<<8) +\n         this[start+1];\n}\n\nfunction readUInt32BE(start) {\n  return (this[start]<<24) +\n         (this[start+1]<<16) +\n         (this[start+2]<<8) +\n         this[start+3];\n}\n\nfunction fastCopy(length, srcBuffer, dstBuffer, dstOffset) {\n  switch (length) {\n    default: srcBuffer.copy(dstBuffer, dstOffset, 0, length); break;\n    case 16: dstBuffer[dstOffset+15] = srcBuffer[15];\n    case 15: dstBuffer[dstOffset+14] = srcBuffer[14];\n    case 14: dstBuffer[dstOffset+13] = srcBuffer[13];\n    case 13: dstBuffer[dstOffset+12] = srcBuffer[12];\n    case 12: dstBuffer[dstOffset+11] = srcBuffer[11];\n    case 11: dstBuffer[dstOffset+10] = srcBuffer[10];\n    case 10: dstBuffer[dstOffset+9] = srcBuffer[9];\n    case 9: dstBuffer[dstOffset+8] = srcBuffer[8];\n    case 8: dstBuffer[dstOffset+7] = srcBuffer[7];\n    case 7: dstBuffer[dstOffset+6] = srcBuffer[6];\n    case 6: dstBuffer[dstOffset+5] = srcBuffer[5];\n    case 5: dstBuffer[dstOffset+4] = srcBuffer[4];\n    case 4: dstBuffer[dstOffset+3] = srcBuffer[3];\n    case 3: dstBuffer[dstOffset+2] = srcBuffer[2];\n    case 2: dstBuffer[dstOffset+1] = srcBuffer[1];\n    case 1: dstBuffer[dstOffset] = srcBuffer[0];\n  }\n}\n\nfunction clone(obj) {\n  var cloned = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      cloned[k] = obj[k];\n    }\n  }\n  return cloned;\n}\n\n/**\n * Opcode handlers\n */\n\nvar opcodes = {\n  // text\n  '1': {\n    start: function(data) {\n      var self = this;\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['1'].getData.call(self, firstLength);\n      }\n      else if (firstLength == 126) {\n        self.expectHeader(2, function(data) {\n          opcodes['1'].getData.call(self, readUInt16BE.call(data, 0));\n        });\n      }\n      else if (firstLength == 127) {\n        self.expectHeader(8, function(data) {\n          if (readUInt32BE.call(data, 0) != 0) {\n            self.error('packets with length spanning more than 32 bit is currently not supported', 1008);\n            return;\n          }\n          opcodes['1'].getData.call(self, readUInt32BE.call(data, 4));\n        });\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['1'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['1'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      var packet = this.unmask(mask, data, true) || new Buffer(0);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.applyExtensions(packet, state.lastFragment, state.compressed, function(err, buffer) {\n          if (err) return self.error(err.message, 1007);\n          if (buffer != null) self.currentMessage.push(buffer);\n\n          if (state.lastFragment) {\n            var messageBuffer = self.concatBuffers(self.currentMessage);\n            self.currentMessage = [];\n            if (!Validation.isValidUTF8(messageBuffer)) {\n              self.error('invalid utf8 sequence', 1007);\n              return;\n            }\n            self.ontext(messageBuffer.toString('utf8'), {masked: state.masked, buffer: messageBuffer});\n          }\n          callback();\n        });\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // binary\n  '2': {\n    start: function(data) {\n      var self = this;\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['2'].getData.call(self, firstLength);\n      }\n      else if (firstLength == 126) {\n        self.expectHeader(2, function(data) {\n          opcodes['2'].getData.call(self, readUInt16BE.call(data, 0));\n        });\n      }\n      else if (firstLength == 127) {\n        self.expectHeader(8, function(data) {\n          if (readUInt32BE.call(data, 0) != 0) {\n            self.error('packets with length spanning more than 32 bit is currently not supported', 1008);\n            return;\n          }\n          opcodes['2'].getData.call(self, readUInt32BE.call(data, 4, true));\n        });\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['2'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['2'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      var packet = this.unmask(mask, data, true) || new Buffer(0);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.applyExtensions(packet, state.lastFragment, state.compressed, function(err, buffer) {\n          if (err) return self.error(err.message, 1007);\n          if (buffer != null) self.currentMessage.push(buffer);\n          if (state.lastFragment) {\n            var messageBuffer = self.concatBuffers(self.currentMessage);\n            self.currentMessage = [];\n            self.onbinary(messageBuffer, {masked: state.masked, buffer: messageBuffer});\n          }\n          callback();\n        });\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // close\n  '8': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented close is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['8'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['8'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['8'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = self.unmask(mask, data, true);\n\n      var state = clone(this.state);\n      this.messageHandlers.push(function() {\n        if (data && data.length == 1) {\n          self.error('close packets with data must be at least two bytes long', 1002);\n          return;\n        }\n        var code = data && data.length > 1 ? readUInt16BE.call(data, 0) : 1000;\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          self.error('invalid error code', 1002);\n          return;\n        }\n        var message = '';\n        if (data && data.length > 2) {\n          var messageBuffer = data.slice(2);\n          if (!Validation.isValidUTF8(messageBuffer)) {\n            self.error('invalid utf8 sequence', 1007);\n            return;\n          }\n          message = messageBuffer.toString('utf8');\n        }\n        self.onclose(code, message, {masked: state.masked});\n        self.reset();\n      });\n      this.flush();\n    },\n  },\n  // ping\n  '9': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented ping is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['9'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (self.state.masked) {\n        self.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['9'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        self.expectData(length, function(data) {\n          opcodes['9'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = this.unmask(mask, data, true);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.onping(data, {masked: state.masked, binary: true});\n        callback();\n      });\n      this.flush();\n      this.endPacket();\n    }\n  },\n  // pong\n  '10': {\n    start: function(data) {\n      var self = this;\n      if (self.state.lastFragment == false) {\n        self.error('fragmented pong is not supported', 1002);\n        return;\n      }\n\n      // decode length\n      var firstLength = data[1] & 0x7f;\n      if (firstLength < 126) {\n        opcodes['10'].getData.call(self, firstLength);\n      }\n      else {\n        self.error('control frames cannot have more than 125 bytes of data', 1002);\n      }\n    },\n    getData: function(length) {\n      var self = this;\n      if (this.state.masked) {\n        this.expectHeader(4, function(data) {\n          var mask = data;\n          self.expectData(length, function(data) {\n            opcodes['10'].finish.call(self, mask, data);\n          });\n        });\n      }\n      else {\n        this.expectData(length, function(data) {\n          opcodes['10'].finish.call(self, null, data);\n        });\n      }\n    },\n    finish: function(mask, data) {\n      var self = this;\n      data = self.unmask(mask, data, true);\n      var state = clone(this.state);\n      this.messageHandlers.push(function(callback) {\n        self.onpong(data, {masked: state.masked, binary: true});\n        callback();\n      });\n      this.flush();\n      this.endPacket();\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Receiver.js\n// module id = 20\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = require('events')\n  , util = require('util')\n  , EventEmitter = events.EventEmitter\n  , ErrorCodes = require('./ErrorCodes')\n  , bufferUtil = require('./BufferUtil').BufferUtil\n  , PerMessageDeflate = require('./PerMessageDeflate');\n\n/**\n * HyBi Sender implementation\n */\n\nfunction Sender(socket, extensions) {\n  events.EventEmitter.call(this);\n\n  this._socket = socket;\n  this.extensions = extensions || {};\n  this.firstFragment = true;\n  this.compress = false;\n  this.messageHandlers = [];\n  this.processing = false;\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (typeof code !== 'undefined') {\n    if (typeof code !== 'number' ||\n      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');\n  }\n  code = code || 1000;\n  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));\n  writeUInt16BE.call(dataBuffer, code, 0);\n  if (dataBuffer.length > 2) dataBuffer.write(data, 2);\n\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0x8, dataBuffer, true, mask);\n    callback();\n    if (typeof cb == 'function') cb();\n  });\n  this.flush();\n};\n\n/**\n * Sends a ping message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0x9, data || '', true, mask);\n    callback();\n  });\n  this.flush();\n};\n\n/**\n * Sends a pong message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.frameAndSend(0xa, data || '', true, mask);\n    callback();\n  });\n  this.flush();\n};\n\n/**\n * Sends text or binary data to the remote party.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  var finalFragment = options && options.fin === false ? false : true;\n  var mask = options && options.mask;\n  var compress = options && options.compress;\n  var opcode = options && options.binary ? 2 : 1;\n  if (this.firstFragment === false) {\n    opcode = 0;\n    compress = false;\n  } else {\n    this.firstFragment = false;\n    this.compress = compress;\n  }\n  if (finalFragment) this.firstFragment = true\n\n  var compressFragment = this.compress;\n\n  var self = this;\n  this.messageHandlers.push(function(callback) {\n    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {\n      if (err) {\n        if (typeof cb == 'function') cb(err);\n        else self.emit('error', err);\n        return;\n      }\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      callback();\n    });\n  });\n  this.flush();\n};\n\n/**\n * Frames and sends a piece of data according to the HyBi WebSocket protocol.\n *\n * @api private\n */\n\nSender.prototype.frameAndSend = function(opcode, data, finalFragment, maskData, compressed, cb) {\n  var canModifyData = false;\n\n  if (!data) {\n    try {\n      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0, 0] : [])), 'binary', cb);\n    }\n    catch (e) {\n      if (typeof cb == 'function') cb(e);\n      else this.emit('error', e);\n    }\n    return;\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    canModifyData = true;\n    if (data && (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {\n      data = getArrayBuffer(data);\n    } else {\n      data = new Buffer(data);\n    }\n  }\n\n  var dataLength = data.length\n    , dataOffset = maskData ? 6 : 2\n    , secondByte = dataLength;\n\n  if (dataLength >= 65536) {\n    dataOffset += 8;\n    secondByte = 127;\n  }\n  else if (dataLength > 125) {\n    dataOffset += 2;\n    secondByte = 126;\n  }\n\n  var mergeBuffers = dataLength < 32768 || (maskData && !canModifyData);\n  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;\n  var outputBuffer = new Buffer(totalLength);\n  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;\n  if (compressed) outputBuffer[0] |= 0x40;\n\n  switch (secondByte) {\n    case 126:\n      writeUInt16BE.call(outputBuffer, dataLength, 2);\n      break;\n    case 127:\n      writeUInt32BE.call(outputBuffer, 0, 2);\n      writeUInt32BE.call(outputBuffer, dataLength, 6);\n  }\n\n  if (maskData) {\n    outputBuffer[1] = secondByte | 0x80;\n    var mask = this._randomMask || (this._randomMask = getRandomMask());\n    outputBuffer[dataOffset - 4] = mask[0];\n    outputBuffer[dataOffset - 3] = mask[1];\n    outputBuffer[dataOffset - 2] = mask[2];\n    outputBuffer[dataOffset - 1] = mask[3];\n    if (mergeBuffers) {\n      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      bufferUtil.mask(data, mask, data, 0, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n  else {\n    outputBuffer[1] = secondByte;\n    if (mergeBuffers) {\n      data.copy(outputBuffer, dataOffset);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nSender.prototype.flush = function() {\n  if (this.processing) return;\n\n  var handler = this.messageHandlers.shift();\n  if (!handler) return;\n\n  this.processing = true;\n\n  var self = this;\n\n  handler(function() {\n    self.processing = false;\n    self.flush();\n  });\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nSender.prototype.applyExtensions = function(data, fin, compress, callback) {\n  if (compress && data) {\n    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);\n  } else {\n    callback(null, data);\n  }\n};\n\nmodule.exports = Sender;\n\nfunction writeUInt16BE(value, offset) {\n  this[offset] = (value & 0xff00)>>8;\n  this[offset+1] = value & 0xff;\n}\n\nfunction writeUInt32BE(value, offset) {\n  this[offset] = (value & 0xff000000)>>24;\n  this[offset+1] = (value & 0xff0000)>>16;\n  this[offset+2] = (value & 0xff00)>>8;\n  this[offset+3] = value & 0xff;\n}\n\nfunction getArrayBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var array = new Uint8Array(data.buffer || data)\n    , l = data.byteLength || data.length\n    , o = data.byteOffset || 0\n    , buffer = new Buffer(l);\n  for (var i = 0; i < l; ++i) {\n    buffer[i] = array[o+i];\n  }\n  return buffer;\n}\n\nfunction getRandomMask() {\n  return new Buffer([\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255),\n    ~~(Math.random() * 255)\n  ]);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Sender.js\n// module id = 21\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar url = require('url')\n  , util = require('util')\n  , http = require('http')\n  , https = require('https')\n  , crypto = require('crypto')\n  , stream = require('stream')\n  , Ultron = require('ultron')\n  , Options = require('options')\n  , Sender = require('./Sender')\n  , Receiver = require('./Receiver')\n  , SenderHixie = require('./Sender.hixie')\n  , ReceiverHixie = require('./Receiver.hixie')\n  , Extensions = require('./Extensions')\n  , PerMessageDeflate = require('./PerMessageDeflate')\n  , EventEmitter = require('events').EventEmitter;\n\n/**\n * Constants\n */\n\n// Default protocol version\n\nvar protocolVersion = 13;\n\n// Close timeout\n\nvar closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly\n\n/**\n * WebSocket implementation\n *\n * @constructor\n * @param {String} address Connection address.\n * @param {String|Array} protocols WebSocket protocols.\n * @param {Object} options Additional connection options.\n * @api public\n */\nfunction WebSocket(address, protocols, options) {\n  EventEmitter.call(this);\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols;\n    protocols = null;\n  }\n\n  if ('string' === typeof protocols) {\n    protocols = [ protocols ];\n  }\n\n  if (!Array.isArray(protocols)) {\n    protocols = [];\n  }\n\n  this._socket = null;\n  this._ultron = null;\n  this._closeReceived = false;\n  this.bytesReceived = 0;\n  this.readyState = null;\n  this.supports = {};\n  this.extensions = {};\n\n  if (Array.isArray(address)) {\n    initAsServerClient.apply(this, address.concat(options));\n  } else {\n    initAsClient.apply(this, [address, protocols, options]);\n  }\n}\n\n/**\n * Inherits from EventEmitter.\n */\nutil.inherits(WebSocket, EventEmitter);\n\n/**\n * Ready States\n */\n[\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function each(state, index) {\n    WebSocket.prototype[state] = WebSocket[state] = index;\n});\n\n/**\n * Gracefully closes the connection, after sending a description message to the server\n *\n * @param {Object} data to be sent to the server\n * @api public\n */\nWebSocket.prototype.close = function close(code, data) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this.readyState === WebSocket.CONNECTING) {\n    this.readyState = WebSocket.CLOSED;\n    return;\n  }\n\n  if (this.readyState === WebSocket.CLOSING) {\n    if (this._closeReceived && this._isServer) {\n      this.terminate();\n    }\n    return;\n  }\n\n  var self = this;\n  try {\n    this.readyState = WebSocket.CLOSING;\n    this._closeCode = code;\n    this._closeMessage = data;\n    var mask = !this._isServer;\n    this._sender.close(code, data, mask, function(err) {\n      if (err) self.emit('error', err);\n\n      if (self._closeReceived && self._isServer) {\n        self.terminate();\n      } else {\n        // ensure that the connection is cleaned up even when no response of closing handshake.\n        clearTimeout(self._closeTimer);\n        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);\n      }\n    });\n  } catch (e) {\n    this.emit('error', e);\n  }\n};\n\n/**\n * Pause the client stream\n *\n * @api public\n */\nWebSocket.prototype.pause = function pauser() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n  return this._socket.pause();\n};\n\n/**\n * Sends a ping\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\nWebSocket.prototype.ping = function ping(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.ping(data, options);\n};\n\n/**\n * Sends a pong\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\nWebSocket.prototype.pong = function(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.pong(data, options);\n};\n\n/**\n * Resume the client stream\n *\n * @api public\n */\nWebSocket.prototype.resume = function resume() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n  return this._socket.resume();\n};\n\n/**\n * Sends a piece of data\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} Optional callback which is executed after the send completes\n * @api public\n */\n\nWebSocket.prototype.send = function send(data, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));\n    else throw new Error('not opened');\n    return;\n  }\n\n  if (!data) data = '';\n  if (this._queue) {\n    var self = this;\n    this._queue.push(function() { self.send(data, options, cb); });\n    return;\n  }\n\n  options = options || {};\n  options.fin = true;\n\n  if (typeof options.binary === 'undefined') {\n    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||\n      data instanceof Uint8Array ||\n      data instanceof Uint16Array ||\n      data instanceof Uint32Array ||\n      data instanceof Int8Array ||\n      data instanceof Int16Array ||\n      data instanceof Int32Array ||\n      data instanceof Float32Array ||\n      data instanceof Float64Array);\n  }\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  var readable = typeof stream.Readable === 'function'\n    ? stream.Readable\n    : stream.Stream;\n\n  if (data instanceof readable) {\n    startQueue(this);\n    var self = this;\n\n    sendStream(this, data, options, function send(error) {\n      process.nextTick(function tock() {\n        executeQueueSends(self);\n      });\n\n      if (typeof cb === 'function') cb(error);\n    });\n  } else {\n    this._sender.send(data, options, cb);\n  }\n};\n\n/**\n * Streams data through calls to a user supplied function\n *\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} 'function (error, send)' which is executed on successive ticks of which send is 'function (data, final)'.\n * @api public\n */\nWebSocket.prototype.stream = function stream(options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var self = this;\n\n  if (typeof cb !== 'function') throw new Error('callback must be provided');\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));\n    else throw new Error('not opened');\n    return;\n  }\n\n  if (this._queue) {\n    this._queue.push(function () { self.stream(options, cb); });\n    return;\n  }\n\n  options = options || {};\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  startQueue(this);\n\n  function send(data, final) {\n    try {\n      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');\n      options.fin = final === true;\n      self._sender.send(data, options);\n      if (!final) process.nextTick(cb.bind(null, null, send));\n      else executeQueueSends(self);\n    } catch (e) {\n      if (typeof cb === 'function') cb(e);\n      else {\n        delete self._queue;\n        self.emit('error', e);\n      }\n    }\n  }\n\n  process.nextTick(cb.bind(null, null, send));\n};\n\n/**\n * Immediately shuts down the connection\n *\n * @api public\n */\nWebSocket.prototype.terminate = function terminate() {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this._socket) {\n    this.readyState = WebSocket.CLOSING;\n\n    // End the connection\n    try { this._socket.end(); }\n    catch (e) {\n      // Socket error during end() call, so just destroy it right now\n      cleanupWebsocketResources.call(this, true);\n      return;\n    }\n\n    // Add a timeout to ensure that the connection is completely\n    // cleaned up within 30 seconds, even if the clean close procedure\n    // fails for whatever reason\n    // First cleanup any pre-existing timeout from an earlier \"terminate\" call,\n    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts\n    // and hold the program open for `closeTimout` time.\n    if (this._closeTimer) { clearTimeout(this._closeTimer); }\n    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);\n  } else if (this.readyState === WebSocket.CONNECTING) {\n    cleanupWebsocketResources.call(this, true);\n  }\n};\n\n/**\n * Expose bufferedAmount\n *\n * @api public\n */\nObject.defineProperty(WebSocket.prototype, 'bufferedAmount', {\n  get: function get() {\n    var amount = 0;\n    if (this._socket) {\n      amount = this._socket.bufferSize || 0;\n    }\n    return amount;\n  }\n});\n\n/**\n * Emulates the W3C Browser based WebSocket interface using function members.\n *\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\n['open', 'error', 'close', 'message'].forEach(function(method) {\n  Object.defineProperty(WebSocket.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    get: function get() {\n      var listener = this.listeners(method)[0];\n      return listener ? (listener._listener ? listener._listener : listener) : undefined;\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    set: function set(listener) {\n      this.removeAllListeners(method);\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nWebSocket.prototype.addEventListener = function(method, listener) {\n  var target = this;\n\n  function onMessage (data, flags) {\n    listener.call(target, new MessageEvent(data, flags.binary ? 'Binary' : 'Text', target));\n  }\n\n  function onClose (code, message) {\n    listener.call(target, new CloseEvent(code, message, target));\n  }\n\n  function onError (event) {\n    event.target = target;\n    listener.call(target, event);\n  }\n\n  function onOpen () {\n    listener.call(target, new OpenEvent(target));\n  }\n\n  if (typeof listener === 'function') {\n    if (method === 'message') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  }\n};\n\nmodule.exports = WebSocket;\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction MessageEvent(dataArg, typeArg, target) {\n  this.data = dataArg;\n  this.type = typeArg;\n  this.target = target;\n}\n\n/**\n * W3C CloseEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction CloseEvent(code, reason, target) {\n  this.wasClean = (typeof code === 'undefined' || code === 1000);\n  this.code = code;\n  this.reason = reason;\n  this.target = target;\n}\n\n/**\n * W3C OpenEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\nfunction OpenEvent(target) {\n  this.target = target;\n}\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\nfunction initAsServerClient(req, socket, upgradeHead, options) {\n  options = new Options({\n    protocolVersion: protocolVersion,\n    protocol: null,\n    extensions: {}\n  }).merge(options);\n\n  // expose state properties\n  this.protocol = options.value.protocol;\n  this.protocolVersion = options.value.protocolVersion;\n  this.extensions = options.value.extensions;\n  this.supports.binary = (this.protocolVersion !== 'hixie-76');\n  this.upgradeReq = req;\n  this.readyState = WebSocket.CONNECTING;\n  this._isServer = true;\n\n  // establish connection\n  if (options.value.protocolVersion === 'hixie-76') {\n    establishConnection.call(this, ReceiverHixie, SenderHixie, socket, upgradeHead);\n  } else {\n    establishConnection.call(this, Receiver, Sender, socket, upgradeHead);\n  }\n}\n\nfunction initAsClient(address, protocols, options) {\n  options = new Options({\n    origin: null,\n    protocolVersion: protocolVersion,\n    host: null,\n    headers: null,\n    protocol: protocols.join(','),\n    agent: null,\n\n    // ssl-related options\n    pfx: null,\n    key: null,\n    passphrase: null,\n    cert: null,\n    ca: null,\n    ciphers: null,\n    rejectUnauthorized: null,\n    perMessageDeflate: true\n  }).merge(options);\n\n  if (options.value.protocolVersion !== 8 && options.value.protocolVersion !== 13) {\n    throw new Error('unsupported protocol version');\n  }\n\n  // verify URL and establish http class\n  var serverUrl = url.parse(address);\n  var isUnixSocket = serverUrl.protocol === 'ws+unix:';\n  if (!serverUrl.host && !isUnixSocket) throw new Error('invalid url');\n  var isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  var httpObj = isSecure ? https : http;\n  var port = serverUrl.port || (isSecure ? 443 : 80);\n  var auth = serverUrl.auth;\n\n  // prepare extensions\n  var extensionsOffer = {};\n  var perMessageDeflate;\n  if (options.value.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(typeof options.value.perMessageDeflate !== true ? options.value.perMessageDeflate : {}, false);\n    extensionsOffer[PerMessageDeflate.extensionName] = perMessageDeflate.offer();\n  }\n\n  // expose state properties\n  this._isServer = false;\n  this.url = address;\n  this.protocolVersion = options.value.protocolVersion;\n  this.supports.binary = (this.protocolVersion !== 'hixie-76');\n\n  // begin handshake\n  var key = new Buffer(options.value.protocolVersion + '-' + Date.now()).toString('base64');\n  var shasum = crypto.createHash('sha1');\n  shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  var expectedServerKey = shasum.digest('base64');\n\n  var agent = options.value.agent;\n\n  var headerHost = serverUrl.hostname;\n  // Append port number to Host header, only if specified in the url\n  // and non-default\n  if (serverUrl.port) {\n    if ((isSecure && (port !== 443)) || (!isSecure && (port !== 80))){\n      headerHost = headerHost + ':' + port;\n    }\n  }\n\n  var requestOptions = {\n    port: port,\n    host: serverUrl.hostname,\n    headers: {\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket',\n      'Host': headerHost,\n      'Sec-WebSocket-Version': options.value.protocolVersion,\n      'Sec-WebSocket-Key': key\n    }\n  };\n\n  // If we have basic auth.\n  if (auth) {\n    requestOptions.headers.Authorization = 'Basic ' + new Buffer(auth).toString('base64');\n  }\n\n  if (options.value.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.value.protocol;\n  }\n\n  if (options.value.host) {\n    requestOptions.headers.Host = options.value.host;\n  }\n\n  if (options.value.headers) {\n    for (var header in options.value.headers) {\n       if (options.value.headers.hasOwnProperty(header)) {\n        requestOptions.headers[header] = options.value.headers[header];\n       }\n    }\n  }\n\n  if (Object.keys(extensionsOffer).length) {\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format(extensionsOffer);\n  }\n\n  if (options.isDefinedAndNonNull('pfx')\n   || options.isDefinedAndNonNull('key')\n   || options.isDefinedAndNonNull('passphrase')\n   || options.isDefinedAndNonNull('cert')\n   || options.isDefinedAndNonNull('ca')\n   || options.isDefinedAndNonNull('ciphers')\n   || options.isDefinedAndNonNull('rejectUnauthorized')) {\n\n    if (options.isDefinedAndNonNull('pfx')) requestOptions.pfx = options.value.pfx;\n    if (options.isDefinedAndNonNull('key')) requestOptions.key = options.value.key;\n    if (options.isDefinedAndNonNull('passphrase')) requestOptions.passphrase = options.value.passphrase;\n    if (options.isDefinedAndNonNull('cert')) requestOptions.cert = options.value.cert;\n    if (options.isDefinedAndNonNull('ca')) requestOptions.ca = options.value.ca;\n    if (options.isDefinedAndNonNull('ciphers')) requestOptions.ciphers = options.value.ciphers;\n    if (options.isDefinedAndNonNull('rejectUnauthorized')) requestOptions.rejectUnauthorized = options.value.rejectUnauthorized;\n\n    if (!agent) {\n        // global agent ignores client side certificates\n        agent = new httpObj.Agent(requestOptions);\n    }\n  }\n\n  requestOptions.path = serverUrl.path || '/';\n\n  if (agent) {\n    requestOptions.agent = agent;\n  }\n\n  if (isUnixSocket) {\n    requestOptions.socketPath = serverUrl.pathname;\n  }\n  if (options.value.origin) {\n    if (options.value.protocolVersion < 13) requestOptions.headers['Sec-WebSocket-Origin'] = options.value.origin;\n    else requestOptions.headers.Origin = options.value.origin;\n  }\n\n  var self = this;\n  var req = httpObj.request(requestOptions);\n\n  req.on('error', function onerror(error) {\n    self.emit('error', error);\n    cleanupWebsocketResources.call(self, error);\n  });\n\n  req.once('response', function response(res) {\n    var error;\n\n    if (!self.emit('unexpected-response', req, res)) {\n      error = new Error('unexpected server response (' + res.statusCode + ')');\n      req.abort();\n      self.emit('error', error);\n    }\n\n    cleanupWebsocketResources.call(self, error);\n  });\n\n  req.once('upgrade', function upgrade(res, socket, upgradeHead) {\n    if (self.readyState === WebSocket.CLOSED) {\n      // client closed before server accepted connection\n      self.emit('close');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverKey = res.headers['sec-websocket-accept'];\n    if (typeof serverKey === 'undefined' || serverKey !== expectedServerKey) {\n      self.emit('error', 'invalid server key');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protList = (options.value.protocol || \"\").split(/, */);\n    var protError = null;\n\n    if (!options.value.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.value.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      self.emit('error', protError);\n      self.removeAllListeners();\n      socket.end();\n      return;\n    } else if (serverProt) {\n      self.protocol = serverProt;\n    }\n\n    var serverExtensions = Extensions.parse(res.headers['sec-websocket-extensions']);\n    if (perMessageDeflate && serverExtensions[PerMessageDeflate.extensionName]) {\n      try {\n        perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        self.emit('error', 'invalid extension parameter');\n        self.removeAllListeners();\n        socket.end();\n        return;\n      }\n      self.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    establishConnection.call(self, Receiver, Sender, socket, upgradeHead);\n\n    // perform cleanup on http resources\n    req.removeAllListeners();\n    req = null;\n    agent = null;\n  });\n\n  req.end();\n  this.readyState = WebSocket.CONNECTING;\n}\n\nfunction establishConnection(ReceiverClass, SenderClass, socket, upgradeHead) {\n  var ultron = this._ultron = new Ultron(socket);\n  this._socket = socket;\n\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  var self = this;\n  this._receiver = new ReceiverClass(this.extensions);\n\n  // socket cleanup handlers\n  ultron.on('end', cleanupWebsocketResources.bind(this));\n  ultron.on('close', cleanupWebsocketResources.bind(this));\n  ultron.on('error', cleanupWebsocketResources.bind(this));\n\n  // ensure that the upgradeHead is added to the receiver\n  function firstHandler(data) {\n    if (self.readyState !== WebSocket.OPEN && self.readyState !== WebSocket.CLOSING) return;\n\n    if (upgradeHead && upgradeHead.length > 0) {\n      self.bytesReceived += upgradeHead.length;\n      var head = upgradeHead;\n      upgradeHead = null;\n      self._receiver.add(head);\n    }\n\n    dataHandler = realHandler;\n\n    if (data) {\n      self.bytesReceived += data.length;\n      self._receiver.add(data);\n    }\n  }\n\n  // subsequent packets are pushed straight to the receiver\n  function realHandler(data) {\n    if (data) self.bytesReceived += data.length;\n    self._receiver.add(data);\n  }\n\n  var dataHandler = firstHandler;\n\n  // if data was passed along with the http upgrade,\n  // this will schedule a push of that on to the receiver.\n  // this has to be done on next tick, since the caller\n  // hasn't had a chance to set event handlers on this client\n  // object yet.\n  process.nextTick(firstHandler);\n\n  // receiver event handlers\n  self._receiver.ontext = function ontext(data, flags) {\n    flags = flags || {};\n\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onbinary = function onbinary(data, flags) {\n    flags = flags || {};\n\n    flags.binary = true;\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onping = function onping(data, flags) {\n    flags = flags || {};\n\n    self.pong(data, {\n      mask: !self._isServer,\n      binary: flags.binary === true\n    }, true);\n\n    self.emit('ping', data, flags);\n  };\n\n  self._receiver.onpong = function onpong(data, flags) {\n    self.emit('pong', data, flags || {});\n  };\n\n  self._receiver.onclose = function onclose(code, data, flags) {\n    flags = flags || {};\n\n    self._closeReceived = true;\n    self.close(code, data);\n  };\n\n  self._receiver.onerror = function onerror(reason, errorCode) {\n    // close the connection when the receiver reports a HyBi error code\n    self.close(typeof errorCode !== 'undefined' ? errorCode : 1002, '');\n    self.emit('error', reason, errorCode);\n  };\n\n  // finalize the client\n  this._sender = new SenderClass(socket, this.extensions);\n  this._sender.on('error', function onerror(error) {\n    self.close(1002, '');\n    self.emit('error', error);\n  });\n\n  this.readyState = WebSocket.OPEN;\n  this.emit('open');\n\n  ultron.on('data', dataHandler);\n}\n\nfunction startQueue(instance) {\n  instance._queue = instance._queue || [];\n}\n\nfunction executeQueueSends(instance) {\n  var queue = instance._queue;\n  if (typeof queue === 'undefined') return;\n\n  delete instance._queue;\n  for (var i = 0, l = queue.length; i < l; ++i) {\n    queue[i]();\n  }\n}\n\nfunction sendStream(instance, stream, options, cb) {\n  stream.on('data', function incoming(data) {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));\n      else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = false;\n    instance._sender.send(data, options);\n  });\n\n  stream.on('end', function end() {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));\n      else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = true;\n    instance._sender.send(null, options);\n\n    if (typeof cb === 'function') cb(null);\n  });\n}\n\nfunction cleanupWebsocketResources(error) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  var emitClose = this.readyState !== WebSocket.CONNECTING;\n  this.readyState = WebSocket.CLOSED;\n\n  clearTimeout(this._closeTimer);\n  this._closeTimer = null;\n\n  if (emitClose) {\n    this.emit('close', this._closeCode || 1000, this._closeMessage || '');\n  }\n\n  if (this._socket) {\n    if (this._ultron) this._ultron.destroy();\n    this._socket.on('error', function onerror() {\n      try { this.destroy(); }\n      catch (e) {}\n    });\n\n    try {\n      if (!error) this._socket.end();\n      else this._socket.destroy();\n    } catch (e) { /* Ignore termination errors */ }\n\n    this._socket = null;\n    this._ultron = null;\n  }\n\n  if (this._sender) {\n    this._sender.removeAllListeners();\n    this._sender = null;\n  }\n\n  if (this._receiver) {\n    this._receiver.cleanup();\n    this._receiver = null;\n  }\n\n  this.removeAllListeners();\n  this.on('error', function onerror() {}); // catch all errors after this\n  delete this._queue;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/WebSocket.js\n// module id = 22\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar ConnectionImpl = (function () {\r\n    function ConnectionImpl(settings) {\r\n        this.messageHandlers = {};\r\n        this.ids = 1;\r\n        this.registry = callback_registry_1.default();\r\n        this._connected = false;\r\n        this._settings = settings;\r\n        this._logger = settings.logger;\r\n    }\r\n    ConnectionImpl.prototype.init = function (transport, protocol) {\r\n        this._protocol = protocol;\r\n        this._transport = transport;\r\n        this._transport.onConnectedChanged(this.handleConnectionChanged.bind(this));\r\n        this._transport.onMessage(this.handleTransportMessage.bind(this));\r\n    };\r\n    ConnectionImpl.prototype.send = function (product, type, message, id, options) {\r\n        if (this._transport.isObjectBasedTransport) {\r\n            var msg = this._protocol.createObjectMessage(product, type, message, id);\r\n            return this._transport.sendObject(msg, product, type, options);\r\n        }\r\n        else {\r\n            var strMessage = this._protocol.createStringMessage(product, type, message, id);\r\n            return this._transport.send(strMessage, product, type, options);\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.on = function (product, type, messageHandler) {\r\n        type = type.toLowerCase();\r\n        if (this.messageHandlers[type] === undefined) {\r\n            this.messageHandlers[type] = {};\r\n        }\r\n        var id = this.ids++;\r\n        this.messageHandlers[type][id] = messageHandler;\r\n        return {\r\n            type: type,\r\n            id: id,\r\n        };\r\n    };\r\n    ConnectionImpl.prototype.off = function (info) {\r\n        delete this.messageHandlers[info.type.toLowerCase()][info.id];\r\n    };\r\n    Object.defineProperty(ConnectionImpl.prototype, \"isConnected\", {\r\n        get: function () {\r\n            return this._connected;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ConnectionImpl.prototype.connected = function (callback) {\r\n        if (this._connected) {\r\n            callback(this._settings.ws || this._settings.http);\r\n        }\r\n        return this.registry.add(\"connected\", callback);\r\n    };\r\n    ConnectionImpl.prototype.disconnected = function (callback) {\r\n        return this.registry.add(\"disconnected\", callback);\r\n    };\r\n    ConnectionImpl.prototype.login = function (authRequest) {\r\n        this._transport.open();\r\n        return this._protocol.login(authRequest);\r\n    };\r\n    ConnectionImpl.prototype.logout = function () {\r\n        this._protocol.logout();\r\n        this._transport.close();\r\n    };\r\n    ConnectionImpl.prototype.loggedIn = function (callback) {\r\n        return this._protocol.loggedIn(callback);\r\n    };\r\n    Object.defineProperty(ConnectionImpl.prototype, \"protocolVersion\", {\r\n        get: function () {\r\n            return this._settings.protocolVersion || 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ConnectionImpl.prototype.toAPI = function () {\r\n        var that = this;\r\n        return {\r\n            send: that.send.bind(that),\r\n            on: that.on.bind(that),\r\n            off: that.off.bind(that),\r\n            login: that.login.bind(that),\r\n            logout: that.logout.bind(that),\r\n            loggedIn: that.loggedIn.bind(that),\r\n            connected: that.connected.bind(that),\r\n            disconnected: that.disconnected.bind(that),\r\n            get protocolVersion() {\r\n                return that.protocolVersion;\r\n            }\r\n        };\r\n    };\r\n    ConnectionImpl.prototype.distributeMessage = function (message, type) {\r\n        var _this = this;\r\n        var handlers = this.messageHandlers[type.toLowerCase()];\r\n        if (handlers !== undefined) {\r\n            Object.keys(handlers).forEach(function (handlerId) {\r\n                var handler = handlers[handlerId];\r\n                if (handler !== undefined) {\r\n                    try {\r\n                        handler(message);\r\n                    }\r\n                    catch (error) {\r\n                        _this._logger.error(\"Message handler failed with \" + error.stack);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.handleConnectionChanged = function (connected) {\r\n        if (this._connected === connected) {\r\n            return;\r\n        }\r\n        this._connected = connected;\r\n        if (connected) {\r\n            this.registry.execute(\"connected\");\r\n        }\r\n        else {\r\n            this.registry.execute(\"disconnected\");\r\n        }\r\n    };\r\n    ConnectionImpl.prototype.handleTransportMessage = function (msg) {\r\n        var msgObj;\r\n        if (typeof msg === \"string\") {\r\n            msgObj = this._protocol.processStringMessage(msg);\r\n        }\r\n        else {\r\n            msgObj = this._protocol.processObjectMessage(msg);\r\n        }\r\n        this.distributeMessage(msgObj.msg, msgObj.msgType);\r\n    };\r\n    return ConnectionImpl;\r\n}());\r\nexports.default = ConnectionImpl;\r\n//# sourceMappingURL=connection.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/connection.js\n// module id = 23\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GW_MESSAGE_CREATE_CONTEXT = \"create-context\";\r\nexports.GW_MESSAGE_ACTIVITY_CREATED = \"created\";\r\nexports.GW_MESSAGE_ACTIVITY_DESTROYED = \"destroyed\";\r\nexports.GW_MESSAGE_CONTEXT_CREATED = \"context-created\";\r\nexports.GW_MESSAGE_CONTEXT_ADDED = \"context-added\";\r\nexports.GW_MESSAGE_SUBSCRIBE_CONTEXT = \"subscribe-context\";\r\nexports.GW_MESSAGE_SUBSCRIBED_CONTEXT = \"subscribed-context\";\r\nexports.GW_MESSAGE_UNSUBSCRIBE_CONTEXT = \"unsubscribe-context\";\r\nexports.GW_MESSAGE_DESTROY_CONTEXT = \"destroy-context\";\r\nexports.GW_MESSAGE_CONTEXT_DESTROYED = \"context-destroyed\";\r\nexports.GW_MESSAGE_UPDATE_CONTEXT = \"update-context\";\r\nexports.GW_MESSAGE_CONTEXT_UPDATED = \"context-updated\";\r\nexports.GW_MESSAGE_JOINED_ACTIVITY = \"joined\";\r\n//# sourceMappingURL=gw3Messages.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/gw3/gw3Messages.js\n// module id = 24\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection = {\r\n    protocolVersion: -1,\r\n    send: function (product, type, message, id, options) {\r\n        return Promise.resolve(undefined);\r\n    },\r\n    on: function (product, type, messageHandler) {\r\n        return { type: \"1\", id: 1 };\r\n    },\r\n    off: function (info) {\r\n    },\r\n    login: function (message) {\r\n        return undefined;\r\n    },\r\n    logout: function () {\r\n    },\r\n    loggedIn: function (callback) {\r\n        return undefined;\r\n    },\r\n    connected: function (callback) {\r\n        return undefined;\r\n    },\r\n    disconnected: function (callback) {\r\n        return undefined;\r\n    },\r\n};\r\nexports.default = connection;\r\n//# sourceMappingURL=dummyConnection.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/dummyConnection.js\n// module id = 25\n// module chunks = 0","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 26\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 27\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar main_1 = require(\"./metrics/main\");\r\nvar main_2 = require(\"./connection/main\");\r\nvar main_3 = require(\"./logger/main\");\r\nvar main_4 = require(\"./agm/main\");\r\nvar main_5 = require(\"./bus/main\");\r\nvar config_1 = require(\"./config\");\r\nvar dummyConnection_1 = require(\"./dummyConnection\");\r\nvar timer_1 = require(\"./timer\");\r\nvar utils_1 = require(\"./utils\");\r\nvar dummyConnection_2 = require(\"./dummyConnection\");\r\nvar main_6 = require(\"./contexts/main\");\r\nvar contextMessageReplaySpec_1 = require(\"./contexts/contextMessageReplaySpec\");\r\nvar GlueCore = function (userConfig, ext) {\r\n    var gdVersion = -1;\r\n    var hc;\r\n    var glue42gd;\r\n    if (typeof window !== \"undefined\") {\r\n        gdVersion = utils_1.default.getGDMajorVersion();\r\n        if (gdVersion === 2) {\r\n            hc = window.htmlContainer;\r\n        }\r\n        else if (gdVersion >= 3) {\r\n            glue42gd = window.glue42gd;\r\n        }\r\n    }\r\n    var glueInitTimer = timer_1.default();\r\n    userConfig = userConfig || {};\r\n    ext = ext || {};\r\n    var internalConfig = config_1.default(userConfig, ext, hc, glue42gd, gdVersion);\r\n    var _connection;\r\n    var _agm;\r\n    var _logger;\r\n    var _rootMetrics;\r\n    var _metrics;\r\n    var _contexts;\r\n    var _bus;\r\n    var libs = {};\r\n    function registerLib(name, inner, t) {\r\n        inner.initStartTime = t.startTime;\r\n        if (inner.ready) {\r\n            inner.ready().then(function () {\r\n                inner.initTime = t.stop();\r\n                inner.initEndTime = t.endTime;\r\n            });\r\n        }\r\n        else {\r\n            inner.initTime = t.stop();\r\n            inner.initEndTime = t.endTime;\r\n        }\r\n        libs[name] = inner;\r\n        GlueCore[name] = inner;\r\n    }\r\n    function setupConnection() {\r\n        var initTimer = timer_1.default();\r\n        internalConfig.connection.logger = _logger.subLogger(\"connection\");\r\n        _connection = main_2.default(internalConfig.connection);\r\n        var authPromise = Promise.resolve(internalConfig.auth);\r\n        if (internalConfig.connection && !internalConfig.auth) {\r\n            var protocolVersion = internalConfig.connection.protocolVersion;\r\n            if (!protocolVersion || protocolVersion === 1) {\r\n                registerLib(\"connection\", _connection, initTimer);\r\n                return Promise.resolve({});\r\n            }\r\n            if (protocolVersion === 2) {\r\n                return Promise.reject(\"You need to provide auth information\");\r\n            }\r\n            if (protocolVersion === 3) {\r\n                if (glue42gd) {\r\n                    authPromise = glue42gd.getGWToken().then(function (token) {\r\n                        return {\r\n                            gatewayToken: token\r\n                        };\r\n                    });\r\n                }\r\n                else {\r\n                    authPromise = Promise.reject(\"You need to provide auth information\");\r\n                }\r\n            }\r\n        }\r\n        return authPromise\r\n            .then(function (authConfig) {\r\n            var authRequest;\r\n            if (typeof authConfig === \"string\" || typeof authConfig === \"number\") {\r\n                authRequest = {\r\n                    token: authConfig\r\n                };\r\n            }\r\n            else if (Object.prototype.toString.call(authConfig) === \"[object Object]\") {\r\n                authRequest = authConfig;\r\n            }\r\n            else {\r\n                throw new Error(\"Invalid auth object - \" + JSON.stringify(authConfig));\r\n            }\r\n            return authRequest;\r\n        })\r\n            .then(function (authRequest) {\r\n            return _connection.login(authRequest);\r\n        })\r\n            .then(function (identity) {\r\n            if (identity) {\r\n                if (identity.machine) {\r\n                    internalConfig.agm.instance.machine = identity.machine;\r\n                }\r\n                if (identity.user) {\r\n                    internalConfig.agm.instance.user = identity.user;\r\n                }\r\n            }\r\n            registerLib(\"connection\", _connection, initTimer);\r\n            return internalConfig;\r\n        })\r\n            .catch(function (e) {\r\n            if (_connection) {\r\n                _connection.logout();\r\n            }\r\n            throw e;\r\n        });\r\n    }\r\n    function setupLogger() {\r\n        var initTimer = timer_1.default();\r\n        var loggerConfig = {\r\n            identity: internalConfig.identity,\r\n            getConnection: function () {\r\n                return _connection || dummyConnection_1.default;\r\n            },\r\n            publish: internalConfig.logger.publish || \"off\",\r\n            console: internalConfig.logger.console || \"info\",\r\n            metrics: (internalConfig.metrics && internalConfig.logger.metrics) || \"off\"\r\n        };\r\n        _logger = main_3.default(loggerConfig);\r\n        registerLib(\"logger\", _logger, initTimer);\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupMetrics() {\r\n        if (internalConfig.metrics) {\r\n            var initTimer = timer_1.default();\r\n            _rootMetrics = main_1.default({\r\n                identity: internalConfig.metrics.identity,\r\n                connection: internalConfig.metrics ? _connection : dummyConnection_1.default,\r\n                logger: _logger.subLogger(\"metrics\")\r\n            });\r\n            _metrics = _rootMetrics.subSystem(\"App\");\r\n            var reportingSystem_1 = _metrics.subSystem(\"reporting\");\r\n            var def_1 = {\r\n                name: \"features\",\r\n                conflation: 1,\r\n            };\r\n            var _featureMetric_1;\r\n            _metrics.featureMetric = function (name, action, payload) {\r\n                if (typeof name === \"undefined\" || name === \"\") {\r\n                    throw new Error(\"name is mandatory\");\r\n                }\r\n                else if (typeof action === \"undefined\" || action === \"\") {\r\n                    throw new Error(\"action is mandatory\");\r\n                }\r\n                else if (typeof payload === \"undefined\" || payload === \"\") {\r\n                    throw new Error(\"payload is mandatory\");\r\n                }\r\n                if (!_featureMetric_1) {\r\n                    _featureMetric_1 = reportingSystem_1.objectMetric(def_1, { name: name, action: action, payload: payload });\r\n                }\r\n                else {\r\n                    _featureMetric_1.update({\r\n                        name: name,\r\n                        action: action,\r\n                        payload: payload\r\n                    });\r\n                }\r\n            };\r\n            _logger.metricsLevel(\"warn\", _metrics.parent.subSystem(\"LogEvents\"));\r\n            registerLib(\"metrics\", _metrics, initTimer);\r\n        }\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupAGM() {\r\n        var initTimer = timer_1.default();\r\n        var agmConfig = {\r\n            instance: internalConfig.agm.instance,\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"agm\"),\r\n            forceGW: internalConfig.connection && internalConfig.connection.force,\r\n            gdVersion: gdVersion,\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            main_4.default(agmConfig)\r\n                .then(function (agmLib) {\r\n                _agm = agmLib;\r\n                registerLib(\"agm\", _agm, initTimer);\r\n                resolve(internalConfig);\r\n            })\r\n                .catch(function (err) {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    function setupContexts() {\r\n        var hasActivities = (internalConfig.activities && dummyConnection_2.default.protocolVersion === 3);\r\n        var needsContexts = internalConfig.contexts || hasActivities;\r\n        if (needsContexts) {\r\n            var initTimer = timer_1.default();\r\n            _contexts = new main_6.ContextsModule({\r\n                connection: _connection,\r\n                logger: _logger.subLogger(\"contexts\"),\r\n                gdMajorVersion: gdVersion\r\n            });\r\n            registerLib(\"contexts\", _contexts, initTimer);\r\n            return _contexts;\r\n        }\r\n        else {\r\n            var replayer = dummyConnection_2.default.replayer;\r\n            if (replayer) {\r\n                replayer.drain(contextMessageReplaySpec_1.ContextMessageReplaySpec.name, null);\r\n            }\r\n        }\r\n    }\r\n    function setupExternalLibs(externalLibs) {\r\n        try {\r\n            externalLibs.forEach(function (lib) {\r\n                setupExternalLib(lib.name, lib.create);\r\n            });\r\n            return Promise.resolve();\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    function setupExternalLib(name, createCallback) {\r\n        var initTimer = timer_1.default();\r\n        var lib = createCallback(libs);\r\n        if (lib) {\r\n            registerLib(name, lib, initTimer);\r\n        }\r\n    }\r\n    function waitForLibs() {\r\n        var libsReadyPromises = Object.keys(libs).map(function (key) {\r\n            var lib = libs[key];\r\n            return lib.ready ?\r\n                lib.ready() : Promise.resolve();\r\n        });\r\n        return Promise.all(libsReadyPromises);\r\n    }\r\n    function constructGlueObject() {\r\n        var feedbackFunc = function () {\r\n            if (!_agm) {\r\n                return;\r\n            }\r\n            _agm.invoke(\"T42.ACS.Feedback\", {}, \"best\");\r\n        };\r\n        var info = { glueVersion: internalConfig.version };\r\n        glueInitTimer.stop();\r\n        var glue = {\r\n            feedback: feedbackFunc,\r\n            info: info,\r\n            version: internalConfig.version,\r\n            userConfig: userConfig,\r\n            done: function () {\r\n                _connection.logout();\r\n                return Promise.resolve();\r\n            }\r\n        };\r\n        glue.performance = {\r\n            get browser() {\r\n                return window.performance.timing.toJSON();\r\n            },\r\n            get memory() {\r\n                return window.performance.memory;\r\n            },\r\n            get initTimes() {\r\n                var result = Object.keys(glue)\r\n                    .filter(function (key) {\r\n                    if (key === \"initTimes\") {\r\n                        return false;\r\n                    }\r\n                    return glue[key].initTime;\r\n                })\r\n                    .map(function (key) {\r\n                    return {\r\n                        name: key,\r\n                        time: glue[key].initTime,\r\n                        startTime: glue[key].initStartTime,\r\n                        endTime: glue[key].initEndTime\r\n                    };\r\n                });\r\n                result.push({\r\n                    name: \"glue\",\r\n                    startTime: glueInitTimer.startTime,\r\n                    endTime: glueInitTimer.endTime,\r\n                    time: glueInitTimer.period\r\n                });\r\n                return result;\r\n            }\r\n        };\r\n        Object.keys(libs).forEach(function (key) {\r\n            var lib = libs[key];\r\n            glue[key] = lib;\r\n            info[key] = lib.version;\r\n        });\r\n        if (hc && hc.perfDataNeeded && hc.updatePerfData) {\r\n            var delay = hc.perfDataDelay || 100;\r\n            setTimeout(function () {\r\n                hc.updatePerfData(glue.performance);\r\n            }, delay);\r\n        }\r\n        if (glue42gd && glue42gd.updatePerfData) {\r\n            glue42gd.updatePerfData(glue.performance);\r\n        }\r\n        glue.config = {};\r\n        if (ext.enrichGlue) {\r\n            ext.enrichGlue(glue);\r\n        }\r\n        Object.keys(internalConfig).forEach(function (k) {\r\n            glue.config[k] = internalConfig[k];\r\n        });\r\n        if (ext.extOptions) {\r\n            Object.keys(ext.extOptions).forEach(function (k) {\r\n                glue.config[k] = ext.extOptions[k];\r\n            });\r\n        }\r\n        return glue;\r\n    }\r\n    function setupBus() {\r\n        if (!internalConfig.bus) {\r\n            return Promise.resolve(undefined);\r\n        }\r\n        var initTimer = timer_1.default();\r\n        var busSettings = {\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"bus\")\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            main_5.default(busSettings)\r\n                .then(function (busLib) {\r\n                _bus = busLib;\r\n                registerLib(\"bus\", _bus, initTimer);\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    return setupLogger()\r\n        .then(setupConnection)\r\n        .then(function () { return Promise.all([setupMetrics(), setupAGM(), setupContexts(), setupBus()]); })\r\n        .then(function () {\r\n        return setupExternalLibs(internalConfig.libs || []);\r\n    })\r\n        .then(waitForLibs)\r\n        .then(constructGlueObject)\r\n        .catch(function (err) {\r\n        return Promise.reject({\r\n            err: err,\r\n            libs: libs\r\n        });\r\n    });\r\n};\r\nexports.default = GlueCore;\r\n//# sourceMappingURL=glue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/glue.js\n// module id = 28\n// module chunks = 0","/**\n * Secure random string generator with custom alphabet.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * @param {generator} random The random bytes generator.\n * @param {string} alphabet Symbols to be used in new random string.\n * @param {size} size The number of symbols in new random string.\n *\n * @return {string} Random string.\n *\n * @example\n * const format = require('nanoid/format')\n *\n * function random (size) {\n *   const result = []\n *   for (let i = 0; i < size; i++) {\n *     result.push(randomByte())\n *   }\n *   return result\n * }\n *\n * format(random, \"abcdef\", 5) //=> \"fbaef\"\n *\n * @name format\n * @function\n */\nmodule.exports = function (random, alphabet, size) {\n  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1\n  var step = Math.ceil(1.6 * mask * size / alphabet.length)\n\n  var id = ''\n  while (true) {\n    var bytes = random(step)\n    for (var i = 0; i < step; i++) {\n      var byte = bytes[i] & mask\n      if (alphabet[byte]) {\n        id += alphabet[byte]\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\n/**\n * @callback generator\n * @param {number} bytes The number of bytes to generate.\n * @return {number[]} Random bytes.\n */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nanoid/format.js\n// module id = 29\n// module chunks = 0","var crypto = require('crypto')\n\nif (crypto.randomFillSync) {\n  var buffers = { }\n  module.exports = function (bytes) {\n    var buffer = buffers[bytes]\n    if (!buffer) {\n      buffer = Buffer.allocUnsafe(bytes)\n      if (bytes <= 255) buffers[bytes] = buffer\n    }\n    return crypto.randomFillSync(buffer)\n  }\n} else {\n  module.exports = crypto.randomBytes\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nanoid/random.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nvar generate = require('./generate');\nvar alphabet = require('./alphabet');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction build(clusterWorkerId) {\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + generate(version);\n    str = str + generate(clusterWorkerId);\n    if (counter > 0) {\n        str = str + generate(counter);\n    }\n    str = str + generate(seconds);\n    return str;\n}\n\nmodule.exports = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/build.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nvar alphabet = require('./alphabet');\nvar random = require('./random/random-byte');\nvar format = require('nanoid/format');\n\nfunction generate(number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + format(random, alphabet.get(), 1);\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = generate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/generate.js\n// module id = 32\n// module chunks = 0","'use strict';\n\nvar alphabet = require('./alphabet');\nvar build = require('./build');\nvar isValid = require('./is-valid');\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n  return build(clusterWorkerId);\n}\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.isValid = isValid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/index.js\n// module id = 33\n// module chunks = 0","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var nonAlphabetic = new RegExp('[^' +\n      alphabet.get().replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&') +\n    ']');\n    return !nonAlphabetic.test(id);\n}\n\nmodule.exports = isShortId;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/is-valid.js\n// module id = 34\n// module chunks = 0","module.exports = require('nanoid/random');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/random/random-byte.js\n// module id = 35\n// module chunks = 0","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/random/random-from-seed.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nvar cluster = require('cluster');\n\nvar clusterId = 0;\nif (!cluster.isMaster && cluster.worker) {\n    clusterId = cluster.worker.id;\n}\nmodule.exports = parseInt(process.env.NODE_UNIQUE_ID || clusterId, 10);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/util/cluster-worker-id.js\n// module id = 37\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments\n    , event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    args = [];\n\n    for (event in this.ee._events) {\n      if (has.call(this.ee._events, event)) args.push(event);\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = this.ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n        delete event.listener.__ultron;\n      } else {\n        if (event.__ultron !== this.id) continue;\n        delete event.__ultron;\n      }\n\n      this.ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n\n  this.remove();\n  this.ee = null;\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ultron/index.js\n// module id = 38\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar WS = module.exports = require('./lib/WebSocket');\n\nWS.Server = require('./lib/WebSocketServer');\nWS.Sender = require('./lib/Sender');\nWS.Receiver = require('./lib/Receiver');\n\n/**\n * Create a new WebSocket server.\n *\n * @param {Object} options Server options\n * @param {Function} fn Optional connection listener.\n * @returns {WS.Server}\n * @api public\n */\nWS.createServer = function createServer(options, fn) {\n  var server = new WS.Server(options);\n\n  if (typeof fn === 'function') {\n    server.on('connection', fn);\n  }\n\n  return server;\n};\n\n/**\n * Create a new WebSocket connection.\n *\n * @param {String} address The URL/address we need to connect to.\n * @param {Function} fn Open listener.\n * @returns {WS}\n * @api public\n */\nWS.connect = WS.createConnection = function connect(address, fn) {\n  var client = new WS(address);\n\n  if (typeof fn === 'function') {\n    client.on('open', fn);\n  }\n\n  return client;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/index.js\n// module id = 39\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util');\n\nfunction BufferPool(initialSize, growStrategy, shrinkStrategy) {\n  if (typeof initialSize === 'function') {\n    shrinkStrategy = growStrategy;\n    growStrategy = initialSize;\n    initialSize = 0;\n  }\n  else if (typeof initialSize === 'undefined') {\n    initialSize = 0;\n  }\n  this._growStrategy = (growStrategy || function(db, size) {\n    return db.used + size;\n  }).bind(null, this);\n  this._shrinkStrategy = (shrinkStrategy || function(db) {\n    return initialSize;\n  }).bind(null, this);\n  this._buffer = initialSize ? new Buffer(initialSize) : null;\n  this._offset = 0;\n  this._used = 0;\n  this._changeFactor = 0;\n  this.__defineGetter__('size', function(){\n    return this._buffer == null ? 0 : this._buffer.length;\n  });\n  this.__defineGetter__('used', function(){\n    return this._used;\n  });\n}\n\nBufferPool.prototype.get = function(length) {\n  if (this._buffer == null || this._offset + length > this._buffer.length) {\n    var newBuf = new Buffer(this._growStrategy(length));\n    this._buffer = newBuf;\n    this._offset = 0;\n  }\n  this._used += length;\n  var buf = this._buffer.slice(this._offset, this._offset + length);\n  this._offset += length;\n  return buf;\n}\n\nBufferPool.prototype.reset = function(forceNewBuffer) {\n  var len = this._shrinkStrategy();\n  if (len < this.size) this._changeFactor -= 1;\n  if (forceNewBuffer || this._changeFactor < -2) {\n    this._changeFactor = 0;\n    this._buffer = len ? new Buffer(len) : null;\n  }\n  this._offset = 0;\n  this._used = 0;\n}\n\nmodule.exports = BufferPool;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/BufferPool.js\n// module id = 40\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports.BufferUtil = {\n  merge: function(mergedBuffer, buffers) {\n    var offset = 0;\n    for (var i = 0, l = buffers.length; i < l; ++i) {\n      var buf = buffers[i];\n      buf.copy(mergedBuffer, offset);\n      offset += buf.length;\n    }\n  },\n  mask: function(source, mask, output, offset, length) {\n    var maskNum = mask.readUInt32LE(0, true);\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ source.readUInt32LE(i, true);\n      if (num < 0) num = 4294967296 + num;\n      output.writeUInt32LE(num, offset + i, true);\n    }\n    switch (length % 4) {\n      case 3: output[offset + i + 2] = source[i + 2] ^ mask[2];\n      case 2: output[offset + i + 1] = source[i + 1] ^ mask[1];\n      case 1: output[offset + i] = source[i] ^ mask[0];\n      case 0:;\n    }\n  },\n  unmask: function(data, mask) {\n    var maskNum = mask.readUInt32LE(0, true);\n    var length = data.length;\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ data.readUInt32LE(i, true);\n      if (num < 0) num = 4294967296 + num;\n      data.writeUInt32LE(num, i, true);\n    }\n    switch (length % 4) {\n      case 3: data[i + 2] = data[i + 2] ^ mask[2];\n      case 2: data[i + 1] = data[i + 1] ^ mask[1];\n      case 1: data[i] = data[i] ^ mask[0];\n      case 0:;\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/BufferUtil.fallback.js\n// module id = 41\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util');\n\n/**\n * State constants\n */\n\nvar EMPTY = 0\n  , BODY = 1;\nvar BINARYLENGTH = 2\n  , BINARYBODY = 3;\n\n/**\n * Hixie Receiver implementation\n */\n\nfunction Receiver () {\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n  this.dead = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  var self = this;\n  function doAdd() {\n    if (self.state === EMPTY) {\n      if (data.length == 2 && data[0] == 0xFF && data[1] == 0x00) {\n        self.reset();\n        self.onclose();\n        return;\n      }\n      if (data[0] === 0x80) {\n        self.messageEnd = 0;\n        self.state = BINARYLENGTH;\n        data = data.slice(1);\n      } else {\n\n      if (data[0] !== 0x00) {\n        self.error('payload must start with 0x00 byte', true);\n        return;\n      }\n      data = data.slice(1);\n      self.state = BODY;\n\n      }\n    }\n    if (self.state === BINARYLENGTH) {\n      var i = 0;\n      while ((i < data.length) && (data[i] & 0x80)) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        ++i;\n      }\n      if (i < data.length) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        self.state = BINARYBODY;\n        ++i;\n      }\n      if (i > 0)\n        data = data.slice(i);\n    }\n    if (self.state === BINARYBODY) {\n      var dataleft = self.messageEnd - self.spanLength;\n      if (data.length >= dataleft) {\n        // consume the whole buffer to finish the frame\n        self.buffers.push(data);\n        self.spanLength += dataleft;\n        self.messageEnd = dataleft;\n        return self.parse();\n      }\n      // frame's not done even if we consume it all\n      self.buffers.push(data);\n      self.spanLength += data.length;\n      return;\n    }\n    self.buffers.push(data);\n    if ((self.messageEnd = bufferIndex(data, 0xFF)) != -1) {\n      self.spanLength += self.messageEnd;\n      return self.parse();\n    }\n    else self.spanLength += data.length;\n  }\n  while(data) data = doAdd();\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.state = EMPTY;\n  this.buffers = [];\n};\n\n/**\n * Process buffered data.\n *\n * @api public\n */\n\nReceiver.prototype.parse = function() {\n  var output = new Buffer(this.spanLength);\n  var outputIndex = 0;\n  for (var bi = 0, bl = this.buffers.length; bi < bl - 1; ++bi) {\n    var buffer = this.buffers[bi];\n    buffer.copy(output, outputIndex);\n    outputIndex += buffer.length;\n  }\n  var lastBuffer = this.buffers[this.buffers.length - 1];\n  if (this.messageEnd > 0) lastBuffer.copy(output, outputIndex, 0, this.messageEnd);\n  if (this.state !== BODY) --this.messageEnd;\n  var tail = null;\n  if (this.messageEnd < lastBuffer.length - 1) {\n    tail = lastBuffer.slice(this.messageEnd + 1);\n  }\n  this.reset();\n  this.ontext(output.toString('utf8'));\n  return tail;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, terminate) {\n  this.reset();\n  this.onerror(reason, terminate);\n  return this;\n};\n\n/**\n * Reset parser state\n *\n * @api private\n */\n\nReceiver.prototype.reset = function (reason) {\n  if (this.dead) return;\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n};\n\n/**\n * Internal api\n */\n\nfunction bufferIndex(buffer, byte) {\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    if (buffer[i] === byte) return i;\n  }\n  return -1;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Receiver.hixie.js\n// module id = 42\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = require('events')\n  , util = require('util')\n  , EventEmitter = events.EventEmitter;\n\n/**\n * Hixie Sender implementation\n */\n\nfunction Sender(socket) {\n  events.EventEmitter.call(this);\n\n  this.socket = socket;\n  this.continuationFrame = false;\n  this.isClosed = false;\n}\n\nmodule.exports = Sender;\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Frames and writes data.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  if (this.isClosed) return;\n\n  var isString = typeof data == 'string'\n    , length = isString ? Buffer.byteLength(data) : data.length\n    , lengthbytes = (length > 127) ? 2 : 1 // assume less than 2**14 bytes\n    , writeStartMarker = this.continuationFrame == false\n    , writeEndMarker = !options || !(typeof options.fin != 'undefined' && !options.fin)\n    , buffer = new Buffer((writeStartMarker ? ((options && options.binary) ? (1 + lengthbytes) : 1) : 0) + length + ((writeEndMarker && !(options && options.binary)) ? 1 : 0))\n    , offset = writeStartMarker ? 1 : 0;\n\n  if (writeStartMarker) {\n    if (options && options.binary) {\n      buffer.write('\\x80', 'binary');\n      // assume length less than 2**14 bytes\n      if (lengthbytes > 1)\n        buffer.write(String.fromCharCode(128+length/128), offset++, 'binary');\n      buffer.write(String.fromCharCode(length&0x7f), offset++, 'binary');\n    } else\n      buffer.write('\\x00', 'binary');\n  }\n\n  if (isString) buffer.write(data, offset, 'utf8');\n  else data.copy(buffer, offset, 0);\n\n  if (writeEndMarker) {\n    if (options && options.binary) {\n      // sending binary, not writing end marker\n    } else\n      buffer.write('\\xff', offset + length, 'binary');\n    this.continuationFrame = false;\n  }\n  else this.continuationFrame = true;\n\n  try {\n    this.socket.write(buffer, 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (this.isClosed) return;\n  this.isClosed = true;\n  try {\n    if (this.continuationFrame) this.socket.write(new Buffer([0xff], 'binary'));\n    this.socket.write(new Buffer([0xff, 0x00]), 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a ping message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {};\n\n/**\n * Sends a pong message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nSender.prototype.error = function (reason) {\n  this.emit('error', reason);\n  return this;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Sender.hixie.js\n// module id = 43\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n \nmodule.exports.Validation = {\n  isValidUTF8: function(buffer) {\n    return true;\n  }\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Validation.fallback.js\n// module id = 44\n// module chunks = 0","'use strict';\n\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = require('utf-8-validate');\n} catch (e) {\n  module.exports = require('./Validation.fallback');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/Validation.js\n// module id = 45\n// module chunks = 0","/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util')\n  , events = require('events')\n  , http = require('http')\n  , crypto = require('crypto')\n  , Options = require('options')\n  , WebSocket = require('./WebSocket')\n  , Extensions = require('./Extensions')\n  , PerMessageDeflate = require('./PerMessageDeflate')\n  , tls = require('tls')\n  , url = require('url');\n\n/**\n * WebSocket Server implementation\n */\n\nfunction WebSocketServer(options, callback) {\n  events.EventEmitter.call(this);\n\n  options = new Options({\n    host: '0.0.0.0',\n    port: null,\n    server: null,\n    verifyClient: null,\n    handleProtocols: null,\n    path: null,\n    noServer: false,\n    disableHixie: false,\n    clientTracking: true,\n    perMessageDeflate: true\n  }).merge(options);\n\n  if (!options.isDefinedAndNonNull('port') && !options.isDefinedAndNonNull('server') && !options.value.noServer) {\n    throw new TypeError('`port` or a `server` must be provided');\n  }\n\n  var self = this;\n\n  if (options.isDefinedAndNonNull('port')) {\n    this._server = http.createServer(function (req, res) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Not implemented');\n    });\n    this._server.listen(options.value.port, options.value.host, callback);\n    this._closeServer = function() { if (self._server) self._server.close(); };\n  }\n  else if (options.value.server) {\n    this._server = options.value.server;\n    if (options.value.path) {\n      // take note of the path, to avoid collisions when multiple websocket servers are\n      // listening on the same http server\n      if (this._server._webSocketPaths && options.value.server._webSocketPaths[options.value.path]) {\n        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');\n      }\n      if (typeof this._server._webSocketPaths !== 'object') {\n        this._server._webSocketPaths = {};\n      }\n      this._server._webSocketPaths[options.value.path] = 1;\n    }\n  }\n  if (this._server) this._server.once('listening', function() { self.emit('listening'); });\n\n  if (typeof this._server != 'undefined') {\n    this._server.on('error', function(error) {\n      self.emit('error', error)\n    });\n    this._server.on('upgrade', function(req, socket, upgradeHead) {\n      //copy upgradeHead to avoid retention of large slab buffers used in node core\n      var head = new Buffer(upgradeHead.length);\n      upgradeHead.copy(head);\n\n      self.handleUpgrade(req, socket, head, function(client) {\n        self.emit('connection'+req.url, client);\n        self.emit('connection', client);\n      });\n    });\n  }\n\n  this.options = options.value;\n  this.path = options.value.path;\n  this.clients = [];\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(WebSocketServer, events.EventEmitter);\n\n/**\n * Immediately shuts down the connection.\n *\n * @api public\n */\n\nWebSocketServer.prototype.close = function() {\n  // terminate all associated clients\n  var error = null;\n  try {\n    for (var i = 0, l = this.clients.length; i < l; ++i) {\n      this.clients[i].terminate();\n    }\n  }\n  catch (e) {\n    error = e;\n  }\n\n  // remove path descriptor, if any\n  if (this.path && this._server._webSocketPaths) {\n    delete this._server._webSocketPaths[this.path];\n    if (Object.keys(this._server._webSocketPaths).length == 0) {\n      delete this._server._webSocketPaths;\n    }\n  }\n\n  // close the http server if it was internally created\n  try {\n    if (typeof this._closeServer !== 'undefined') {\n      this._closeServer();\n    }\n  }\n  finally {\n    delete this._server;\n  }\n  if (error) throw error;\n}\n\n/**\n * Handle a HTTP Upgrade request.\n *\n * @api public\n */\n\nWebSocketServer.prototype.handleUpgrade = function(req, socket, upgradeHead, cb) {\n  // check for wrong path\n  if (this.options.path) {\n    var u = url.parse(req.url);\n    if (u && u.pathname !== this.options.path) return;\n  }\n\n  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);\n  else handleHybiUpgrade.apply(this, arguments);\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\n\nfunction handleHybiUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify version\n  var version = parseInt(req.headers['sec-websocket-version']);\n  if ([8, 13].indexOf(version) === -1) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify protocol\n  var protocols = req.headers['sec-websocket-protocol'];\n\n  // verify client\n  var origin = version < 13 ?\n    req.headers['sec-websocket-origin'] :\n    req.headers['origin'];\n\n  // handle extensions offer\n  var extensionsOffer = Extensions.parse(req.headers['sec-websocket-extensions']);\n\n  // handler to call when the connection sequence completes\n  var self = this;\n  var completeHybiUpgrade2 = function(protocol) {\n\n    // calc key\n    var key = req.headers['sec-websocket-key'];\n    var shasum = crypto.createHash('sha1');\n    shasum.update(key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    key = shasum.digest('base64');\n\n    var headers = [\n        'HTTP/1.1 101 Switching Protocols'\n      , 'Upgrade: websocket'\n      , 'Connection: Upgrade'\n      , 'Sec-WebSocket-Accept: ' + key\n    ];\n\n    if (typeof protocol != 'undefined') {\n      headers.push('Sec-WebSocket-Protocol: ' + protocol);\n    }\n\n    var extensions = {};\n    try {\n      extensions = acceptExtensions.call(self, extensionsOffer);\n    } catch (err) {\n      abortConnection(socket, 400, 'Bad Request');\n      return;\n    }\n\n    if (Object.keys(extensions).length) {\n      var serverExtensions = {};\n      Object.keys(extensions).forEach(function(token) {\n        serverExtensions[token] = [extensions[token].params]\n      });\n      headers.push('Sec-WebSocket-Extensions: ' + Extensions.format(serverExtensions));\n    }\n\n    // allows external modification/inspection of handshake headers\n    self.emit('headers', headers);\n\n    socket.setTimeout(0);\n    socket.setNoDelay(true);\n    try {\n      socket.write(headers.concat('', '').join('\\r\\n'));\n    }\n    catch (e) {\n      // if the upgrade write fails, shut the connection down hard\n      try { socket.destroy(); } catch (e) {}\n      return;\n    }\n\n    var client = new WebSocket([req, socket, upgradeHead], {\n      protocolVersion: version,\n      protocol: protocol,\n      extensions: extensions\n    });\n\n    if (self.options.clientTracking) {\n      self.clients.push(client);\n      client.on('close', function() {\n        var index = self.clients.indexOf(client);\n        if (index != -1) {\n          self.clients.splice(index, 1);\n        }\n      });\n    }\n\n    // signal upgrade complete\n    socket.removeListener('error', errorHandler);\n    cb(client);\n  }\n\n  // optionally call external protocol selection handler before\n  // calling completeHybiUpgrade2\n  var completeHybiUpgrade1 = function() {\n    // choose from the sub-protocols\n    if (typeof self.options.handleProtocols == 'function') {\n        var protList = (protocols || \"\").split(/, */);\n        var callbackCalled = false;\n        var res = self.options.handleProtocols(protList, function(result, protocol) {\n          callbackCalled = true;\n          if (!result) abortConnection(socket, 401, 'Unauthorized');\n          else completeHybiUpgrade2(protocol);\n        });\n        if (!callbackCalled) {\n            // the handleProtocols handler never called our callback\n            abortConnection(socket, 501, 'Could not process protocols');\n        }\n        return;\n    } else {\n        if (typeof protocols !== 'undefined') {\n            completeHybiUpgrade2(protocols.split(/, */)[0]);\n        }\n        else {\n            completeHybiUpgrade2();\n        }\n    }\n  }\n\n  // optionally call external client verification handler\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else completeHybiUpgrade1();\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  completeHybiUpgrade1();\n}\n\nfunction handleHixieUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // bail if options prevent hixie\n  if (this.options.disableHixie) {\n    abortConnection(socket, 401, 'Hixie support disabled');\n    return;\n  }\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key2']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  var origin = req.headers['origin']\n    , self = this;\n\n  // setup handshake completion to run after client has been verified\n  var onClientVerified = function() {\n    var wshost;\n    if (!req.headers['x-forwarded-host'])\n        wshost = req.headers.host;\n    else\n        wshost = req.headers['x-forwarded-host'];\n    var location = ((req.headers['x-forwarded-proto'] === 'https' || socket.encrypted) ? 'wss' : 'ws') + '://' + wshost + req.url\n      , protocol = req.headers['sec-websocket-protocol'];\n\n    // handshake completion code to run once nonce has been successfully retrieved\n    var completeHandshake = function(nonce, rest) {\n      // calculate key\n      var k1 = req.headers['sec-websocket-key1']\n        , k2 = req.headers['sec-websocket-key2']\n        , md5 = crypto.createHash('md5');\n\n      [k1, k2].forEach(function (k) {\n        var n = parseInt(k.replace(/[^\\d]/g, ''))\n          , spaces = k.replace(/[^ ]/g, '').length;\n        if (spaces === 0 || n % spaces !== 0){\n          abortConnection(socket, 400, 'Bad Request');\n          return;\n        }\n        n /= spaces;\n        md5.update(String.fromCharCode(\n          n >> 24 & 0xFF,\n          n >> 16 & 0xFF,\n          n >> 8  & 0xFF,\n          n       & 0xFF));\n      });\n      md5.update(nonce.toString('binary'));\n\n      var headers = [\n          'HTTP/1.1 101 Switching Protocols'\n        , 'Upgrade: WebSocket'\n        , 'Connection: Upgrade'\n        , 'Sec-WebSocket-Location: ' + location\n      ];\n      if (typeof protocol != 'undefined') headers.push('Sec-WebSocket-Protocol: ' + protocol);\n      if (typeof origin != 'undefined') headers.push('Sec-WebSocket-Origin: ' + origin);\n\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n      try {\n        // merge header and hash buffer\n        var headerBuffer = new Buffer(headers.concat('', '').join('\\r\\n'));\n        var hashBuffer = new Buffer(md5.digest('binary'), 'binary');\n        var handshakeBuffer = new Buffer(headerBuffer.length + hashBuffer.length);\n        headerBuffer.copy(handshakeBuffer, 0);\n        hashBuffer.copy(handshakeBuffer, headerBuffer.length);\n\n        // do a single write, which - upon success - causes a new client websocket to be setup\n        socket.write(handshakeBuffer, 'binary', function(err) {\n          if (err) return; // do not create client if an error happens\n          var client = new WebSocket([req, socket, rest], {\n            protocolVersion: 'hixie-76',\n            protocol: protocol\n          });\n          if (self.options.clientTracking) {\n            self.clients.push(client);\n            client.on('close', function() {\n              var index = self.clients.indexOf(client);\n              if (index != -1) {\n                self.clients.splice(index, 1);\n              }\n            });\n          }\n\n          // signal upgrade complete\n          socket.removeListener('error', errorHandler);\n          cb(client);\n        });\n      }\n      catch (e) {\n        try { socket.destroy(); } catch (e) {}\n        return;\n      }\n    }\n\n    // retrieve nonce\n    var nonceLength = 8;\n    if (upgradeHead && upgradeHead.length >= nonceLength) {\n      var nonce = upgradeHead.slice(0, nonceLength);\n      var rest = upgradeHead.length > nonceLength ? upgradeHead.slice(nonceLength) : null;\n      completeHandshake.call(self, nonce, rest);\n    }\n    else {\n      // nonce not present in upgradeHead, so we must wait for enough data\n      // data to arrive before continuing\n      var nonce = new Buffer(nonceLength);\n      upgradeHead.copy(nonce, 0);\n      var received = upgradeHead.length;\n      var rest = null;\n      var handler = function (data) {\n        var toRead = Math.min(data.length, nonceLength - received);\n        if (toRead === 0) return;\n        data.copy(nonce, received, 0, toRead);\n        received += toRead;\n        if (received == nonceLength) {\n          socket.removeListener('data', handler);\n          if (toRead < data.length) rest = data.slice(toRead);\n          completeHandshake.call(self, nonce, rest);\n        }\n      }\n      socket.on('data', handler);\n    }\n  }\n\n  // verify client\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      var self = this;\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else onClientVerified.apply(self);\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  // no client verification required\n  onClientVerified();\n}\n\nfunction acceptExtensions(offer) {\n  var extensions = {};\n  var options = this.options.perMessageDeflate;\n  if (options && offer[PerMessageDeflate.extensionName]) {\n    var perMessageDeflate = new PerMessageDeflate(options !== true ? options : {}, true);\n    perMessageDeflate.accept(offer[PerMessageDeflate.extensionName]);\n    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n  }\n  return extensions;\n}\n\nfunction abortConnection(socket, code, name) {\n  try {\n    var response = [\n      'HTTP/1.1 ' + code + ' ' + name,\n      'Content-type: text/html'\n    ];\n    socket.write(response.concat('', '').join('\\r\\n'));\n  }\n  catch (e) { /* ignore errors - we've aborted this connection */ }\n  finally {\n    // ensure that an early aborted connection is shut down completely\n    try { socket.destroy(); } catch (e) {}\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws/lib/WebSocketServer.js\n// module id = 46\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar client_1 = require(\"./client/client\");\r\nvar server_1 = require(\"./server/server\");\r\nvar AGMImpl = (function () {\r\n    function AGMImpl(protocol, clientRepository, serverRepository, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.client = new client_1.default(protocol, clientRepository, instance, configuration);\r\n        this.server = new server_1.default(protocol, serverRepository, instance, configuration);\r\n    }\r\n    AGMImpl.prototype.serverRemoved = function (callback) {\r\n        return this.client.serverRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.serverAdded = function (callback) {\r\n        return this.client.serverAdded(callback);\r\n    };\r\n    AGMImpl.prototype.serverMethodRemoved = function (callback) {\r\n        return this.client.serverMethodRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.serverMethodAdded = function (callback) {\r\n        return this.client.serverMethodAdded(callback);\r\n    };\r\n    AGMImpl.prototype.methodRemoved = function (callback) {\r\n        return this.client.methodRemoved(callback);\r\n    };\r\n    AGMImpl.prototype.methodAdded = function (callback) {\r\n        return this.client.methodAdded(callback);\r\n    };\r\n    AGMImpl.prototype.methodsForInstance = function (instance) {\r\n        return this.client.methodsForInstance(instance);\r\n    };\r\n    AGMImpl.prototype.methods = function (methodFilter) {\r\n        return this.client.methods(methodFilter);\r\n    };\r\n    AGMImpl.prototype.servers = function (methodFilter) {\r\n        return this.client.servers(methodFilter);\r\n    };\r\n    AGMImpl.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        return this.client.subscribe(method, options, successCallback, errorCallback);\r\n    };\r\n    AGMImpl.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);\r\n    };\r\n    AGMImpl.prototype.unregister = function (methodFilter) {\r\n        return this.server.unregister(methodFilter);\r\n    };\r\n    AGMImpl.prototype.registerAsync = function (methodDefinition, callback) {\r\n        return this.server.registerAsync(methodDefinition, callback);\r\n    };\r\n    AGMImpl.prototype.register = function (methodDefinition, callback) {\r\n        return this.server.register(methodDefinition, callback);\r\n    };\r\n    AGMImpl.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n    };\r\n    AGMImpl.prototype.updateInstance = function (newInstance) {\r\n        if (this.instance.machine === undefined) {\r\n            this.instance.machine = newInstance.MachineName || newInstance.machine;\r\n        }\r\n        if (this.instance.user === undefined) {\r\n            this.instance.user = newInstance.UserName || newInstance.user;\r\n        }\r\n        if (this.instance.environment === undefined) {\r\n            this.instance.environment = newInstance.Environment || newInstance.environment;\r\n        }\r\n        if (this.instance.region === undefined) {\r\n            this.instance.region = newInstance.Region || newInstance.region;\r\n        }\r\n    };\r\n    return AGMImpl;\r\n}());\r\nexports.default = AGMImpl;\r\n//# sourceMappingURL=agm.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/agm.js\n// module id = 47\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar invoke_1 = require(\"./invoke\");\r\nvar promisify_1 = require(\"../helpers/promisify\");\r\nvar Client = (function () {\r\n    function Client(protocol, repo, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.repo = repo;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.clientInvocations = new invoke_1.default(protocol);\r\n    }\r\n    Client.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var callProtocolSubscribe = function (targetServers, stream, successProxy, errorProxy) {\r\n            _this.protocol.client.subscribe(stream, options.arguments, targetServers, { methodResponseTimeout: options.waitTimeoutMs }, successProxy, errorProxy);\r\n        };\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (sub) {\r\n                resolve(sub);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            var methodDef;\r\n            if (typeof method === \"string\") {\r\n                methodDef = { name: method };\r\n            }\r\n            else {\r\n                methodDef = method;\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            var target = options.target;\r\n            if (target === undefined) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject({ message: '\"' + target + '\" is not a valid target. Valid targets are \"all\", \"best\", or an instance.' });\r\n            }\r\n            if (options.methodResponseTimeout === undefined) {\r\n                options.methodResponseTimeout = options.method_response_timeout;\r\n                if (options.methodResponseTimeout === undefined) {\r\n                    options.methodResponseTimeout = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (options.waitTimeoutMs === undefined) {\r\n                options.waitTimeoutMs = options.wait_for_method_timeout;\r\n                if (options.waitTimeoutMs === undefined) {\r\n                    options.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            var delayStep = 500;\r\n            var delayTillNow = 0;\r\n            var currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n            if (currentServers.length > 0) {\r\n                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);\r\n            }\r\n            else {\r\n                var retry_1 = function () {\r\n                    delayTillNow += delayStep;\r\n                    currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n                    if (currentServers.length > 0) {\r\n                        var streamInfo = currentServers[0].methods[0];\r\n                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);\r\n                    }\r\n                    else if (delayTillNow >= options.waitTimeoutMs) {\r\n                        var def = typeof method === \"string\" ? { name: method } : method;\r\n                        var info = {\r\n                            id: undefined,\r\n                            info: def,\r\n                            getInfoForUser: function () {\r\n                                return methodDef;\r\n                            },\r\n                            protocolState: undefined,\r\n                        };\r\n                        callProtocolSubscribe(currentServers, info, successProxy, errorProxy);\r\n                    }\r\n                    else {\r\n                        setTimeout(retry_1, delayStep);\r\n                    }\r\n                };\r\n                setTimeout(retry_1, delayStep);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    Client.prototype.servers = function (methodFilter) {\r\n        return this.getServers(methodFilter).map(function (serverMethodMap) {\r\n            return serverMethodMap.server.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methods = function (methodFilter) {\r\n        return this.getMethods(methodFilter).map(function (m) {\r\n            return m.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methodsForInstance = function (instance) {\r\n        return this.getMethodsForInstance(instance).map(function (m) {\r\n            return m.getInfoForUser();\r\n        });\r\n    };\r\n    Client.prototype.methodAdded = function (callback) {\r\n        return this.repo.onMethodAdded(function (method) {\r\n            callback(method.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.methodRemoved = function (callback) {\r\n        return this.repo.onMethodRemoved(function (method) {\r\n            callback(method.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.serverAdded = function (callback) {\r\n        return this.repo.onServerAdded(function (server) {\r\n            callback(server.getInfoForUser());\r\n        });\r\n    };\r\n    Client.prototype.serverRemoved = function (callback) {\r\n        return this.repo.onServerRemoved(function (server, reason) {\r\n            callback(server.getInfoForUser(), reason);\r\n        });\r\n    };\r\n    Client.prototype.serverMethodAdded = function (callback) {\r\n        return this.repo.onServerMethodAdded(function (server, method) {\r\n            callback({ server: server.getInfoForUser(), method: method.getInfoForUser() });\r\n        });\r\n    };\r\n    Client.prototype.serverMethodRemoved = function (callback) {\r\n        return this.repo.onServerMethodRemoved(function (server, method) {\r\n            callback({ server: server.getInfoForUser(), method: method.getInfoForUser() });\r\n        });\r\n    };\r\n    Client.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (args) {\r\n                resolve(args);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            if (!argumentObj) {\r\n                argumentObj = {};\r\n            }\r\n            if (!target) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject({ message: '\"' + target + '\" is not a valid target. Valid targets are \"all\" and \"best\".' });\r\n            }\r\n            if (!additionalOptions) {\r\n                additionalOptions = {};\r\n            }\r\n            if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                additionalOptions.methodResponseTimeoutMs = additionalOptions.method_response_timeout;\r\n                if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                    additionalOptions.methodResponseTimeoutMs = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (additionalOptions.waitTimeoutMs === undefined) {\r\n                additionalOptions.waitTimeoutMs = additionalOptions.wait_for_method_timeout;\r\n                if (additionalOptions.waitTimeoutMs === undefined) {\r\n                    additionalOptions.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== \"number\") {\r\n                reject({ message: '\"' + additionalOptions.waitTimeoutMs + '\" is not a valid number for \\'waitTimeoutMs\\'' });\r\n                return;\r\n            }\r\n            if (typeof argumentObj !== \"object\") {\r\n                reject({ message: \"The method arguments must be an object.\" });\r\n                return;\r\n            }\r\n            if (typeof methodFilter === \"string\") {\r\n                methodFilter = { name: methodFilter };\r\n            }\r\n            var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodFilter, target);\r\n            if (serversMethodMap.length === 0) {\r\n                _this.invokeUnExisting(methodFilter, argumentObj, target, additionalOptions, successProxy, errorProxy);\r\n            }\r\n            else if (serversMethodMap.length === 1) {\r\n                var serverMethodPair = serversMethodMap[0];\r\n                _this.clientInvocations.invoke(serverMethodPair.methods[0], argumentObj, serverMethodPair.server, additionalOptions, successProxy, errorProxy);\r\n            }\r\n            else {\r\n                _this.invokeOnAll(serversMethodMap, argumentObj, additionalOptions, successProxy, errorProxy);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, success, error);\r\n    };\r\n    Client.prototype.invokeUnExisting = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var callError = function () {\r\n            error({\r\n                method: methodFilter,\r\n                called_with: argumentObj,\r\n                message: \"Can not find a method matching \" + JSON.stringify(methodFilter) + \" with server filter \" + JSON.stringify(target),\r\n                executed_by: undefined,\r\n                returned: undefined,\r\n                status: undefined,\r\n            });\r\n        };\r\n        if (additionalOptions.waitTimeoutMs === 0) {\r\n            callError();\r\n        }\r\n        else {\r\n            var delayStep_1 = 500;\r\n            var delayTillNow_1 = 0;\r\n            var retry_2 = function () {\r\n                delayTillNow_1 += delayStep_1;\r\n                var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodFilter, target);\r\n                if (serversMethodMap.length > 0) {\r\n                    _this.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n                }\r\n                else if (delayTillNow_1 >= additionalOptions.waitTimeoutMs) {\r\n                    callError();\r\n                }\r\n                else {\r\n                    setTimeout(retry_2, delayStep_1);\r\n                }\r\n            };\r\n            setTimeout(retry_2, delayStep_1);\r\n        }\r\n    };\r\n    Client.prototype.invokeOnAll = function (serverMethodsMap, argumentObj, additionalOptions, success, error) {\r\n        var _this = this;\r\n        var successes = [];\r\n        var errors = [];\r\n        var successCallback = function (result) {\r\n            successes.push(result);\r\n            sendResponse();\r\n        };\r\n        var errorCallback = function (err) {\r\n            errors.push(err);\r\n            sendResponse();\r\n        };\r\n        var sendResponse = function () {\r\n            if (successes.length + errors.length < serverMethodsMap.length) {\r\n                return;\r\n            }\r\n            if (successes.length !== 0) {\r\n                var result_1 = successes.reduce(function (obj, invResult) {\r\n                    obj.method = invResult.method;\r\n                    obj.called_with = invResult.called_with;\r\n                    obj.returned = invResult.returned;\r\n                    obj.all_return_values.push({\r\n                        executed_by: invResult.executed_by,\r\n                        returned: invResult.returned,\r\n                        called_with: invResult.called_with,\r\n                        method: invResult.method,\r\n                        message: undefined,\r\n                        status: undefined,\r\n                    });\r\n                    obj.executed_by = invResult.executed_by;\r\n                    return obj;\r\n                }, { all_return_values: [] });\r\n                if (errors.length !== 0) {\r\n                    result_1.all_errors = [];\r\n                    errors.forEach(function (obj) {\r\n                        result_1.all_errors.push({\r\n                            executed_by: obj.executed_by,\r\n                            called_with: obj.called_with,\r\n                            name: obj.method.name,\r\n                            message: obj.message,\r\n                        });\r\n                    });\r\n                }\r\n                success(result_1);\r\n            }\r\n            else if (errors.length !== 0) {\r\n                error(errors.reduce(function (obj, currentError) {\r\n                    obj.method = currentError.method;\r\n                    obj.called_with = currentError.called_with;\r\n                    obj.message = currentError.message;\r\n                    obj.all_errors.push({\r\n                        executed_by: currentError.executed_by,\r\n                        message: currentError.message,\r\n                    });\r\n                    return obj;\r\n                }, { all_errors: [] }));\r\n            }\r\n        };\r\n        serverMethodsMap.forEach(function (serverMethodsPair) {\r\n            _this.clientInvocations.invoke(serverMethodsPair.methods[0], argumentObj, serverMethodsPair.server, additionalOptions, successCallback, errorCallback);\r\n        });\r\n    };\r\n    Client.prototype.filterByTarget = function (target, serverMethodMap) {\r\n        var _this = this;\r\n        var targetServerMethod = [];\r\n        if (typeof target === \"string\") {\r\n            if (target === \"all\") {\r\n                targetServerMethod = serverMethodMap;\r\n            }\r\n            else if (target === \"best\") {\r\n                var matchingMachine = serverMethodMap.filter(function (serverMethodPair) {\r\n                    var serverInfo = serverMethodPair.server.info;\r\n                    return serverInfo.machine === _this.instance.machine;\r\n                })[0];\r\n                if (matchingMachine) {\r\n                    return [matchingMachine];\r\n                }\r\n                targetServerMethod = serverMethodMap[0] !== undefined ? [serverMethodMap[0]] : [];\r\n            }\r\n        }\r\n        else {\r\n            if (!Array.isArray(target)) {\r\n                target = [target];\r\n            }\r\n            if (Array.isArray(target)) {\r\n                targetServerMethod = target.reduce(function (matches, filter) {\r\n                    var myMatches = serverMethodMap.filter(function (serverMethodPair) {\r\n                        return _this.instanceMatch(filter, serverMethodPair.server.info);\r\n                    });\r\n                    return matches.concat(myMatches);\r\n                }, []);\r\n            }\r\n        }\r\n        return targetServerMethod;\r\n    };\r\n    Client.prototype.instanceMatch = function (instanceFilter, instanceDefinition) {\r\n        return this.containsProps(instanceFilter, instanceDefinition);\r\n    };\r\n    Client.prototype.methodMatch = function (methodFilter, methodDefinition) {\r\n        return this.containsProps(methodFilter, methodDefinition);\r\n    };\r\n    Client.prototype.containsProps = function (filter, object) {\r\n        return Object.keys(filter).reduce(function (match, prop) {\r\n            if (!filter[prop] || typeof filter[prop] === \"function\") {\r\n                return match;\r\n            }\r\n            if (filter[prop].constructor === RegExp) {\r\n                if (!filter[prop].test(object[prop])) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    return match;\r\n                }\r\n            }\r\n            else {\r\n                if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    return match;\r\n                }\r\n            }\r\n        }, true);\r\n    };\r\n    Client.prototype.getMethods = function (methodFilter) {\r\n        var _this = this;\r\n        if (methodFilter === undefined) {\r\n            return this.repo.getMethods();\r\n        }\r\n        if (typeof methodFilter === \"string\") {\r\n            methodFilter = { name: methodFilter };\r\n        }\r\n        return this.repo.getMethods().filter(function (method) {\r\n            return _this.methodMatch(methodFilter, method.info);\r\n        });\r\n    };\r\n    Client.prototype.getMethodsForInstance = function (instanceFilter) {\r\n        var _this = this;\r\n        var allServers = this.repo.getServers();\r\n        var matchingServers = allServers.filter(function (server) {\r\n            return _this.instanceMatch(instanceFilter, server.info);\r\n        });\r\n        if (matchingServers.length === 0) {\r\n            return [];\r\n        }\r\n        var resultMethodsObject = {};\r\n        if (matchingServers.length === 1) {\r\n            resultMethodsObject = matchingServers[0].methods;\r\n        }\r\n        else {\r\n            matchingServers.forEach(function (server) {\r\n                Object.keys(server.methods).forEach(function (methodKey) {\r\n                    var method = server.methods[methodKey];\r\n                    resultMethodsObject[method.id] = method;\r\n                });\r\n            });\r\n        }\r\n        return Object.keys(resultMethodsObject)\r\n            .map(function (key) {\r\n            return resultMethodsObject[key];\r\n        });\r\n    };\r\n    Client.prototype.getServers = function (methodFilter) {\r\n        var _this = this;\r\n        var servers = this.repo.getServers();\r\n        if (methodFilter === undefined) {\r\n            return servers.map(function (server) {\r\n                return { server: server };\r\n            });\r\n        }\r\n        var methods = this.getMethods(methodFilter);\r\n        if (methods === undefined) {\r\n            return [];\r\n        }\r\n        return servers.reduce(function (prev, current) {\r\n            var methodsForServer = _this.repo.getServerMethodsById(current.id);\r\n            var matchingMethods = methodsForServer.filter(function (method) {\r\n                return _this.methodMatch(methodFilter, method.info);\r\n            });\r\n            if (matchingMethods.length > 0) {\r\n                prev.push({ server: current, methods: matchingMethods });\r\n            }\r\n            return prev;\r\n        }, []);\r\n    };\r\n    Client.prototype.getServerMethodsByFilterAndTarget = function (methodFilter, target) {\r\n        var serversMethodMap = this.getServers(methodFilter);\r\n        return this.filterByTarget(target, serversMethodMap);\r\n    };\r\n    return Client;\r\n}());\r\nexports.default = Client;\r\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/client/client.js\n// module id = 48\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"../helpers/random\");\r\nvar ClientInvocations = (function () {\r\n    function ClientInvocations(_protocol) {\r\n        var _this = this;\r\n        this._protocol = _protocol;\r\n        this._pendingCallbacks = {};\r\n        _protocol.client.onInvocationResult(function (invocationId, executedBy, status, result, resultMessage) {\r\n            return _this.processInvocationResult(invocationId, executedBy, status, result, resultMessage);\r\n        });\r\n    }\r\n    ClientInvocations.prototype.invoke = function (method, argumentsObj, target, stuff, success, error) {\r\n        var invocationId = random_1.default();\r\n        this.registerInvocation(invocationId, {\r\n            method: method,\r\n            calledWith: argumentsObj,\r\n        }, success, error, stuff.methodResponseTimeoutMs);\r\n        this._protocol.client.invoke(invocationId, method, argumentsObj, target, stuff);\r\n    };\r\n    ClientInvocations.prototype.registerInvocation = function (invocationId, invocationInfo, success, error, timeout) {\r\n        var _this = this;\r\n        this._pendingCallbacks[invocationId] = { invocationInfo: invocationInfo, success: success, error: error };\r\n        setTimeout(function () {\r\n            if (_this._pendingCallbacks[invocationId] === undefined) {\r\n                return;\r\n            }\r\n            error({\r\n                method: invocationInfo.method.getInfoForUser(),\r\n                called_with: invocationInfo.calledWith,\r\n                executed_by: undefined,\r\n                status: undefined,\r\n                returned: undefined,\r\n                message: \"Invocation timeout (\" + timeout + \" ms) reached\",\r\n            });\r\n            delete _this._pendingCallbacks[invocationId];\r\n        }, timeout);\r\n    };\r\n    ClientInvocations.prototype.processInvocationResult = function (invocationId, executedBy, status, result, resultMessage) {\r\n        var callback = this._pendingCallbacks[invocationId];\r\n        if (callback === undefined) {\r\n            return;\r\n        }\r\n        if (status === 0 && typeof callback.success === \"function\") {\r\n            callback.success({\r\n                method: callback.invocationInfo.method.getInfoForUser(),\r\n                called_with: callback.invocationInfo.calledWith,\r\n                executed_by: executedBy,\r\n                returned: result,\r\n                message: resultMessage,\r\n                status: status,\r\n            });\r\n        }\r\n        else if (typeof callback.error === \"function\") {\r\n            callback.error({\r\n                method: callback.invocationInfo.method.getInfoForUser(),\r\n                called_with: callback.invocationInfo.calledWith,\r\n                executed_by: executedBy,\r\n                message: resultMessage,\r\n                status: status,\r\n                returned: result,\r\n            });\r\n        }\r\n        delete this._pendingCallbacks[invocationId];\r\n    };\r\n    return ClientInvocations;\r\n}());\r\nexports.default = ClientInvocations;\r\n//# sourceMappingURL=invoke.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/client/invoke.js\n// module id = 49\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar ClientRepository = (function () {\r\n    function ClientRepository() {\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n        this.callbacks = callback_registry_1.default();\r\n    }\r\n    ClientRepository.prototype.addServer = function (info, serverId) {\r\n        var _this = this;\r\n        var current = this.servers[serverId];\r\n        if (current) {\r\n            return current.id;\r\n        }\r\n        var serverEntry = {\r\n            id: serverId,\r\n            info: info,\r\n            methods: {},\r\n            getInfoForUser: function () {\r\n                var serverInfo = _this.createUserServerInfo(serverEntry.info);\r\n                serverInfo.getMethods = function () {\r\n                    return _this.getServerMethodsById(serverEntry.id).map(function (m) {\r\n                        return m.getInfoForUser();\r\n                    });\r\n                };\r\n                serverInfo.getStreams = function () {\r\n                    return _this.getServerMethodsById(serverEntry.id)\r\n                        .filter(function (method) {\r\n                        return method.info.supportsStreaming;\r\n                    })\r\n                        .map(function (m) {\r\n                        return m.getInfoForUser();\r\n                    });\r\n                };\r\n                return serverInfo;\r\n            },\r\n        };\r\n        this.servers[serverId] = serverEntry;\r\n        this.callbacks.execute(\"onServerAdded\", serverEntry);\r\n        return serverId;\r\n    };\r\n    ClientRepository.prototype.removeServerById = function (id, reason) {\r\n        var _this = this;\r\n        var server = this.servers[id];\r\n        Object.keys(server.methods).forEach(function (methodId) {\r\n            _this.removeServerMethod(id, methodId);\r\n        });\r\n        delete this.servers[id];\r\n        this.callbacks.execute(\"onServerRemoved\", server, reason);\r\n    };\r\n    ClientRepository.prototype.addServerMethod = function (serverId, method, protocolState) {\r\n        if (!protocolState) {\r\n            protocolState = {};\r\n        }\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var methodId = this.createMethodId(method);\r\n        if (server.methods[methodId]) {\r\n            return;\r\n        }\r\n        var that = this;\r\n        var methodEntity = {\r\n            id: methodId,\r\n            info: method,\r\n            getInfoForUser: function () {\r\n                var result = that.createUserMethodInfo(methodEntity.info);\r\n                result.getServers = function () {\r\n                    return that.getServersByMethod(methodId);\r\n                };\r\n                return result;\r\n            },\r\n            protocolState: protocolState,\r\n        };\r\n        server.methods[methodId] = methodEntity;\r\n        if (!this.methodsCount[methodId]) {\r\n            this.methodsCount[methodId] = 0;\r\n            this.callbacks.execute(\"onMethodAdded\", methodEntity);\r\n        }\r\n        this.methodsCount[methodId] = this.methodsCount[methodId] + 1;\r\n        this.callbacks.execute(\"onServerMethodAdded\", server, methodEntity);\r\n    };\r\n    ClientRepository.prototype.createMethodId = function (methodInfo) {\r\n        var accepts = methodInfo.accepts !== undefined ? methodInfo.accepts : \"\";\r\n        var returns = methodInfo.returns !== undefined ? methodInfo.returns : \"\";\r\n        return (methodInfo.name + accepts + returns).toLowerCase();\r\n    };\r\n    ClientRepository.prototype.removeServerMethod = function (serverId, methodId) {\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var method = server.methods[methodId];\r\n        delete server.methods[methodId];\r\n        this.methodsCount[methodId] = this.methodsCount[methodId] - 1;\r\n        if (this.methodsCount[methodId] === 0) {\r\n            this.callbacks.execute(\"onMethodRemoved\", method);\r\n        }\r\n        this.callbacks.execute(\"onServerMethodRemoved\", server, method);\r\n    };\r\n    ClientRepository.prototype.getMethods = function () {\r\n        var _this = this;\r\n        var allMethods = {};\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            Object.keys(server.methods).forEach(function (methodId) {\r\n                var method = server.methods[methodId];\r\n                allMethods[method.id] = method;\r\n            });\r\n        });\r\n        var methodsAsArray = Object.keys(allMethods).map(function (id) {\r\n            return allMethods[id];\r\n        });\r\n        return methodsAsArray;\r\n    };\r\n    ClientRepository.prototype.getServers = function () {\r\n        var _this = this;\r\n        var allServers = [];\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            allServers.push(server);\r\n        });\r\n        return allServers;\r\n    };\r\n    ClientRepository.prototype.getServerMethodsById = function (serverId) {\r\n        var server = this.servers[serverId];\r\n        return Object.keys(server.methods).map(function (id) {\r\n            return server.methods[id];\r\n        });\r\n    };\r\n    ClientRepository.prototype.onServerAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerAdded\", callback);\r\n        this.getServers().forEach(function (server) {\r\n            callback(server);\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodAdded\", callback);\r\n        this.getMethods().forEach(function (method) {\r\n            callback(method);\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodAdded\", callback);\r\n        this.getServers().forEach(function (server) {\r\n            var methods = server.methods;\r\n            Object.keys(methods).forEach(function (methodId) {\r\n                callback(server, methods[methodId]);\r\n            });\r\n        });\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.getServerById = function (id) {\r\n        return this.servers[id];\r\n    };\r\n    ClientRepository.prototype.reset = function () {\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n    };\r\n    ClientRepository.prototype.createUserServerInfo = function (serverInfo) {\r\n        return {\r\n            machine: serverInfo.machine,\r\n            pid: serverInfo.pid,\r\n            user: serverInfo.user,\r\n            application: serverInfo.application,\r\n            environment: serverInfo.environment,\r\n            region: serverInfo.region,\r\n            instance: serverInfo.instance,\r\n            windowId: serverInfo.windowId,\r\n            peerId: serverInfo.peerId,\r\n        };\r\n    };\r\n    ClientRepository.prototype.createUserMethodInfo = function (methodInfo) {\r\n        var result = {\r\n            name: methodInfo.name,\r\n            accepts: methodInfo.accepts,\r\n            returns: methodInfo.returns,\r\n            description: methodInfo.description,\r\n            displayName: methodInfo.displayName,\r\n            objectTypes: methodInfo.objectTypes,\r\n            supportsStreaming: methodInfo.supportsStreaming,\r\n        };\r\n        result.object_types = methodInfo.objectTypes;\r\n        result.display_name = methodInfo.displayName;\r\n        result.version = methodInfo.version;\r\n        return result;\r\n    };\r\n    ClientRepository.prototype.getServersByMethod = function (id) {\r\n        var _this = this;\r\n        var allServers = [];\r\n        Object.keys(this.servers).forEach(function (serverId) {\r\n            var server = _this.servers[serverId];\r\n            Object.keys(server.methods).forEach(function (methodId) {\r\n                if (methodId === id) {\r\n                    allServers.push(server.getInfoForUser());\r\n                }\r\n            });\r\n        });\r\n        return allServers;\r\n    };\r\n    return ClientRepository;\r\n}());\r\nexports.default = ClientRepository;\r\n//# sourceMappingURL=repository.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/client/repository.js\n// module id = 50\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar promisify_1 = require(\"../helpers/promisify\");\r\nvar NativeAGM = (function () {\r\n    function NativeAGM(instance, helpers, agmFacade) {\r\n        this.instance = instance;\r\n        this.helpers = helpers;\r\n        this.agmFacade = agmFacade;\r\n        this.protocolVersion = this.agmFacade.protocolVersion;\r\n    }\r\n    NativeAGM.prototype.register = function (name, handler) {\r\n        var methodInfoAsObject = this.helpers.stringToObject(name, \"name\");\r\n        this.helpers.validateMethodInfo(methodInfoAsObject);\r\n        if (this.protocolVersion && this.protocolVersion >= 3) {\r\n            this.agmFacade.register(JSON.stringify(methodInfoAsObject), handler, true);\r\n        }\r\n        else {\r\n            this.agmFacade.register(JSON.stringify(methodInfoAsObject), function (arg, caller) {\r\n                var methodResult = handler(JSON.parse(arg), caller);\r\n                return JSON.stringify(methodResult);\r\n            });\r\n        }\r\n    };\r\n    NativeAGM.prototype.registerAsync = function (name, handler) {\r\n        if (!this.agmFacade.registerAsync) {\r\n            throw new Error(\"not supported in that version of HtmlContainer\");\r\n        }\r\n        var methodInfoAsObject = this.helpers.stringToObject(name, \"name\");\r\n        this.helpers.validateMethodInfo(methodInfoAsObject);\r\n        this.agmFacade.registerAsync(methodInfoAsObject, function (args, instance, tracker) {\r\n            handler(args, instance, function (successArgs) {\r\n                tracker.success(successArgs);\r\n            }, function (error) {\r\n                tracker.error(error);\r\n            });\r\n        });\r\n    };\r\n    NativeAGM.prototype.unregister = function (definition) {\r\n        this.agmFacade.unregister(JSON.stringify(this.helpers.stringToObject(definition, \"name\")));\r\n    };\r\n    NativeAGM.prototype.invoke = function (method, argumentObj, target, options, success, error) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (argumentObj === undefined) {\r\n                argumentObj = {};\r\n            }\r\n            if (typeof argumentObj !== \"object\") {\r\n                reject({ message: \"The method arguments must be an object.\" });\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            target = _this.helpers.targetArgToObject(target);\r\n            if (_this.agmFacade.invoke2) {\r\n                _this.agmFacade.invoke2(JSON.stringify(_this.helpers.stringToObject(method, \"name\")), argumentObj, JSON.stringify(target), JSON.stringify(options), function (a) {\r\n                    resolve(a);\r\n                }, function (err) {\r\n                    reject(err);\r\n                });\r\n            }\r\n            else {\r\n                var successProxy = void 0;\r\n                var errorProxy = void 0;\r\n                successProxy = function (args) {\r\n                    var parsed = JSON.parse(args);\r\n                    resolve(parsed);\r\n                };\r\n                errorProxy = function (args) {\r\n                    var parsed = JSON.parse(args);\r\n                    reject(parsed);\r\n                };\r\n                _this.agmFacade.invoke(JSON.stringify(_this.helpers.stringToObject(method, \"name\")), JSON.stringify(argumentObj), JSON.stringify(target), JSON.stringify(options), successProxy, errorProxy);\r\n            }\r\n        });\r\n        return promisify_1.default(promise, success, error);\r\n    };\r\n    NativeAGM.prototype.createStream = function (methodDefinition, options, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof methodDefinition === \"string\") {\r\n                methodDefinition = {\r\n                    name: methodDefinition,\r\n                    getServers: function () { return []; },\r\n                };\r\n            }\r\n            if (!options) {\r\n                options = {\r\n                    subscriptionRequestHandler: undefined,\r\n                    subscriptionAddedHandler: undefined,\r\n                    subscriptionRemovedHandler: undefined,\r\n                };\r\n            }\r\n            _this.agmFacade.createStream2(JSON.stringify(methodDefinition), options.subscriptionRequestHandler, options.subscriptionAddedHandler, options.subscriptionRemovedHandler, function (stream) {\r\n                resolve(stream);\r\n            }, function (error) {\r\n                reject(error);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    NativeAGM.prototype.subscribe = function (methodDefinition, parameters, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof methodDefinition === \"undefined\") {\r\n                reject(\"method definition param is required\");\r\n            }\r\n            if (parameters === undefined) {\r\n                parameters = {};\r\n            }\r\n            parameters.args = JSON.stringify(parameters.arguments || {});\r\n            parameters.target = _this.helpers.targetArgToObject(parameters.target);\r\n            var name;\r\n            if (typeof methodDefinition === \"string\") {\r\n                name = methodDefinition;\r\n            }\r\n            else {\r\n                name = methodDefinition.name;\r\n            }\r\n            _this.agmFacade.subscribe2(name, JSON.stringify(parameters), function (sub) {\r\n                resolve(sub);\r\n            }, function (error) {\r\n                reject(error);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    NativeAGM.prototype.servers = function (filter) {\r\n        var _this = this;\r\n        var jsonResult = this.agmFacade.servers(JSON.stringify(this.helpers.stringToObject(filter, \"name\")));\r\n        var parsedResult = this.helpers.agmParse(jsonResult);\r\n        return parsedResult.map(function (server) {\r\n            return _this.transformServerObject(server);\r\n        });\r\n    };\r\n    NativeAGM.prototype.methods = function (filter) {\r\n        var _this = this;\r\n        var jsonResult = this.agmFacade.methods(JSON.stringify(this.helpers.stringToObject(filter, \"name\")));\r\n        var parsedResult = this.helpers.agmParse(jsonResult);\r\n        return parsedResult.map(function (method) {\r\n            return _this.transformMethodObject(method);\r\n        });\r\n    };\r\n    NativeAGM.prototype.methodAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.methodAdded(function (method) {\r\n            if (subscribed) {\r\n                callback(_this.transformMethodObject(method));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.methodRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.methodRemoved(function (method) {\r\n            if (subscribed) {\r\n                callback(_this.transformMethodObject(method));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverAdded(function (server) {\r\n            if (subscribed) {\r\n                callback(_this.transformServerObject(server));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverRemoved(function (server) {\r\n            if (subscribed) {\r\n                callback(_this.transformServerObject(server));\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverMethodAdded = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverMethodAdded(function (info) {\r\n            if (subscribed) {\r\n                callback({\r\n                    server: _this.transformServerObject(info.server),\r\n                    method: _this.transformMethodObject(info.method),\r\n                });\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.serverMethodRemoved = function (callback) {\r\n        var _this = this;\r\n        var subscribed = true;\r\n        this.agmFacade.serverMethodRemoved(function (info) {\r\n            if (subscribed) {\r\n                callback({\r\n                    server: _this.transformServerObject(info.server),\r\n                    method: _this.transformMethodObject(info.method),\r\n                });\r\n            }\r\n        });\r\n        return function () {\r\n            subscribed = false;\r\n        };\r\n    };\r\n    NativeAGM.prototype.methodsForInstance = function (server) {\r\n        var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(server));\r\n        var methods = this.helpers.agmParse(jsonResult);\r\n        return methods.map(this.transformMethodObject);\r\n    };\r\n    NativeAGM.prototype.transformMethodObject = function (method) {\r\n        var _this = this;\r\n        if (!method) {\r\n            return undefined;\r\n        }\r\n        if (!method.displayName) {\r\n            method.displayName = method.display_name;\r\n        }\r\n        if (!method.objectTypes) {\r\n            method.objectTypes = method.object_types;\r\n        }\r\n        method.getServers = function () {\r\n            return _this.servers(method.name);\r\n        };\r\n        return method;\r\n    };\r\n    NativeAGM.prototype.transformServerObject = function (server) {\r\n        var _this = this;\r\n        if (!server) {\r\n            return undefined;\r\n        }\r\n        server.getMethods = function () {\r\n            return _this.methodsForInstance(server);\r\n        };\r\n        server.getStreams = function () {\r\n            return _this.methodsForInstance(server).filter(function (method) {\r\n                return method.supportsStreaming;\r\n            });\r\n        };\r\n        return server;\r\n    };\r\n    return NativeAGM;\r\n}());\r\nexports.NativeAGM = NativeAGM;\r\n//# sourceMappingURL=agm.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/hc/agm.js\n// module id = 51\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Helpers = (function () {\r\n    function Helpers(facade) {\r\n        this.facade = facade;\r\n        this.dateTimeIdentifier = facade.jsonValueDatePrefix;\r\n        this.lenOfIdentifier = this.dateTimeIdentifier.length;\r\n    }\r\n    Helpers.prototype.agmParse = function (str) {\r\n        var _this = this;\r\n        return JSON.parse(str, function (k, v) {\r\n            if (typeof v !== \"string\") {\r\n                return v;\r\n            }\r\n            if (v[0] !== _this.dateTimeIdentifier[0]) {\r\n                return v;\r\n            }\r\n            if (v.indexOf(_this.dateTimeIdentifier) !== 0) {\r\n                return v;\r\n            }\r\n            var unixTimestampMs = v.substr(_this.lenOfIdentifier);\r\n            return new Date(parseFloat(unixTimestampMs));\r\n        });\r\n    };\r\n    Helpers.prototype.targetArgToObject = function (target) {\r\n        var _this = this;\r\n        target = target || \"best\";\r\n        if (typeof target === \"string\") {\r\n            if (target !== \"all\" && target !== \"best\") {\r\n                throw new Error(target + \" is not a valid target. Valid targets are 'all' and 'best'\");\r\n            }\r\n            return { target: target };\r\n        }\r\n        else {\r\n            if (!Array.isArray(target)) {\r\n                target = [target];\r\n            }\r\n            target = target.map(function (e) {\r\n                return _this.convertInstanceToRegex(e);\r\n            });\r\n            return { serverFilter: target };\r\n        }\r\n    };\r\n    Helpers.prototype.convertInstanceToRegex = function (instance) {\r\n        var instanceConverted = {};\r\n        Object.keys(instance).forEach(function (key) {\r\n            var propValue = instance[key];\r\n            instanceConverted[key] = propValue;\r\n            if (typeof propValue === \"undefined\" || propValue === null) {\r\n                return;\r\n            }\r\n            if (typeof propValue === \"string\" && propValue !== \"\") {\r\n                instanceConverted[key] = \"^\" + instance[key] + \"$\";\r\n            }\r\n            else if (instance[key].constructor === RegExp) {\r\n                instanceConverted[key] = instance[key].source;\r\n            }\r\n            else {\r\n                instanceConverted[key] = instance[key];\r\n            }\r\n        });\r\n        return instanceConverted;\r\n    };\r\n    Helpers.prototype.validateMethodInfo = function (methodInfo) {\r\n        if (typeof methodInfo === \"undefined\") {\r\n            throw Error(\"methodInfo is required argument\");\r\n        }\r\n        if (!methodInfo.name) {\r\n            throw Error(\"methodInfo object must contain name property\");\r\n        }\r\n        if (methodInfo.objectTypes) {\r\n            methodInfo.object_types = methodInfo.objectTypes;\r\n        }\r\n        if (methodInfo.displayName) {\r\n            methodInfo.display_name = methodInfo.displayName;\r\n        }\r\n    };\r\n    Helpers.prototype.stringToObject = function (param, stringPropName) {\r\n        if (typeof param === \"string\") {\r\n            var obj = {};\r\n            obj[stringPropName] = param;\r\n            return obj;\r\n        }\r\n        return param;\r\n    };\r\n    return Helpers;\r\n}());\r\nexports.Helpers = Helpers;\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/hc/helpers.js\n// module id = 52\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar agm_1 = require(\"./agm\");\r\nvar helpers_1 = require(\"./helpers\");\r\nfunction default_1(configuration) {\r\n    var facade = window.htmlContainer.jsAgmFacade;\r\n    var cfgAsString = createConfig(configuration);\r\n    return new Promise(function (resolve, reject) {\r\n        var successInit = function (instance) {\r\n            var nativeAGM = new agm_1.NativeAGM(instance, new helpers_1.Helpers(facade), facade);\r\n            nativeAGM.create_stream = nativeAGM.createStream;\r\n            nativeAGM.methods_for_instance = nativeAGM.methodsForInstance;\r\n            nativeAGM.method_added = nativeAGM.methodAdded;\r\n            nativeAGM.method_removed = nativeAGM.methodRemoved;\r\n            nativeAGM.server_added = nativeAGM.serverAdded;\r\n            nativeAGM.server_removed = nativeAGM.serverRemoved;\r\n            nativeAGM.server_method_added = nativeAGM.serverMethodAdded;\r\n            nativeAGM.server_method_removed = nativeAGM.serverMethodRemoved;\r\n            resolve(nativeAGM);\r\n        };\r\n        if (facade.protocolVersion && facade.protocolVersion >= 5 && facade.initAsync) {\r\n            facade.initAsync(cfgAsString, successInit, function (err) {\r\n                reject(err);\r\n            });\r\n        }\r\n        else {\r\n            var instance = facade.init(cfgAsString);\r\n            successInit(instance);\r\n        }\r\n    });\r\n}\r\nexports.default = default_1;\r\nvar createConfig = function (configuration) {\r\n    if (configuration !== undefined && configuration.metrics !== undefined) {\r\n        configuration.metrics.metricsIdentity = configuration.metrics.identity;\r\n        var metricsConfig = {\r\n            metricsIdentity: configuration.metrics.metricsIdentity,\r\n            path: configuration.metrics.path,\r\n        };\r\n        configuration.metrics = metricsConfig;\r\n    }\r\n    delete configuration.logger;\r\n    return JSON.stringify(configuration);\r\n};\r\n//# sourceMappingURL=native.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/hc/native.js\n// module id = 53\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"./helpers/random\");\r\nfunction createOwnInstance(userSubmittedProperties, resolvedIdentity, peerId) {\r\n    var document = global.document || global.process;\r\n    var instance = {\r\n        application: document.title + random_1.default(),\r\n        pid: Math.floor(Math.random() * 10000000000),\r\n    };\r\n    instance.peerId = peerId;\r\n    if (typeof userSubmittedProperties === \"object\") {\r\n        if (userSubmittedProperties.application !== undefined) {\r\n            instance.application = userSubmittedProperties.application;\r\n        }\r\n        instance.machine = userSubmittedProperties.machine;\r\n        instance.user = userSubmittedProperties.user;\r\n        instance.environment = userSubmittedProperties.environment;\r\n        instance.region = userSubmittedProperties.region;\r\n    }\r\n    if (typeof resolvedIdentity !== \"undefined\") {\r\n        instance.user = resolvedIdentity.user;\r\n        instance.instance = resolvedIdentity.instance;\r\n        instance.application = resolvedIdentity.application;\r\n        instance.pid = resolvedIdentity.process;\r\n        instance.machine = resolvedIdentity.machine;\r\n        instance.environment = resolvedIdentity.environment;\r\n        instance.region = resolvedIdentity.region;\r\n        instance.windowId = resolvedIdentity.windowId;\r\n    }\r\n    return instance;\r\n}\r\nexports.createOwnInstance = createOwnInstance;\r\n//# sourceMappingURL=instance.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/instance.js\n// module id = 54\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar instance_1 = require(\"./instance\");\r\nvar native_1 = require(\"./hc/native\");\r\nvar factory_1 = require(\"./protocols/gw1/factory\");\r\nvar factory_2 = require(\"./protocols/gw3/factory\");\r\nvar agm_1 = require(\"./agm\");\r\nvar repository_1 = require(\"./client/repository\");\r\nvar repository_2 = require(\"./server/repository\");\r\nexports.default = (function (configuration) {\r\n    if (!configuration.forceGW && configuration.gdVersion === 2) {\r\n        return native_1.default(configuration);\r\n    }\r\n    if (typeof configuration === \"undefined\") {\r\n        throw new Error(\"configuration is required\");\r\n    }\r\n    if (typeof configuration.connection === \"undefined\") {\r\n        throw new Error(\"configuration.connections is required\");\r\n    }\r\n    var connection = configuration.connection;\r\n    if (typeof configuration.methodResponseTimeout !== \"number\") {\r\n        configuration.methodResponseTimeout = 3000;\r\n    }\r\n    if (typeof configuration.waitTimeoutMs !== \"number\") {\r\n        configuration.waitTimeoutMs = 3000;\r\n    }\r\n    var myIdentity = connection.resolvedIdentity;\r\n    var myInstance = instance_1.createOwnInstance(configuration.instance, myIdentity, connection.peerId);\r\n    var clientRepository = new repository_1.default();\r\n    var serverRepository = new repository_2.default();\r\n    var protocolPromise;\r\n    var agmImpl;\r\n    if (connection.protocolVersion === 3) {\r\n        protocolPromise = factory_2.default(myInstance, connection, clientRepository, serverRepository, configuration, function () { return agmImpl; });\r\n    }\r\n    else {\r\n        protocolPromise = factory_1.default(myInstance, connection, clientRepository, serverRepository, configuration, function () { return agmImpl; });\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n        protocolPromise.then(function (protocol) {\r\n            agmImpl = new agm_1.default(protocol, clientRepository, serverRepository, myInstance, configuration);\r\n            resolve(agmImpl);\r\n        }).catch(function (err) {\r\n            reject(err);\r\n        });\r\n    });\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/main.js\n// module id = 55\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"./../../helpers/random\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(configuration, instance, sendRequest, nextResponseSubject) {\r\n        this.configuration = configuration;\r\n        this.instance = instance;\r\n        this.sendRequest = sendRequest;\r\n        this.nextResponseSubject = nextResponseSubject;\r\n        this.subscriptionsList = {};\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: stream.getInfoForUser(),\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n                called_with: args,\r\n            });\r\n            return;\r\n        }\r\n        var subscriptionId = \"subscriptionId_\" + random_1.default();\r\n        var pendingSub = this.registerSubscription(subscriptionId, stream, args, success, error, options.methodResponseTimeout);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: stream.getInfoForUser(),\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n                called_with: args,\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var responseSubject = _this.nextResponseSubject();\r\n            var requestSubject = stream.info.requestSubject;\r\n            pendingSub.trackedServers.push({\r\n                server: undefined,\r\n                streamId: undefined,\r\n                streamSubjects: {\r\n                    global: undefined,\r\n                    private: undefined,\r\n                },\r\n                methodRequestSubject: requestSubject,\r\n                methodResponseSubject: responseSubject,\r\n            });\r\n            var message = {\r\n                EventStreamAction: 1,\r\n                MethodRequestSubject: requestSubject,\r\n                MethodResponseSubject: responseSubject,\r\n                Client: helpers_1.convertInstance(_this.instance),\r\n                Context: {\r\n                    ArgumentsJson: args,\r\n                    InvocationId: subscriptionId,\r\n                    MethodName: stream.info.name,\r\n                    ExecutionServer: target.server.info,\r\n                    Timeout: options.methodResponseTimeout,\r\n                },\r\n            };\r\n            _this.sendRequest(message);\r\n        });\r\n    };\r\n    ClientStreaming.prototype.processPublisherMsg = function (msg) {\r\n        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {\r\n            return;\r\n        }\r\n        if (msg.EventStreamAction === 2) {\r\n            this.serverIsKickingASubscriber(msg);\r\n        }\r\n        else if (msg.EventStreamAction === 3) {\r\n            this.serverAcknowledgesGoodSubscription(msg);\r\n        }\r\n        else if (msg.EventStreamAction === 5) {\r\n            this.serverHasPushedSomeDataIntoTheStream(msg);\r\n        }\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subscriptionId, method, args, success, error, timeout) {\r\n        var _this = this;\r\n        this.subscriptionsList[subscriptionId] = {\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            arguments: args,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: [],\r\n                onClosed: [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n        };\r\n        this.subscriptionsList[subscriptionId].timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subscriptionId] === undefined) {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subscriptionId];\r\n            if (subscription.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method,\r\n                    called_with: args,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \"ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subscriptionId];\r\n            }\r\n            else if (subscription.status === STATUS_SUBSCRIBED &&\r\n                subscription.trackedServers.length > 0) {\r\n                subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                    return (typeof server.streamId === \"string\" && server.streamId !== \"\");\r\n                });\r\n                subscription.timeoutId = undefined;\r\n                if (subscription.trackedServers.length === 0) {\r\n                    var closersCount = subscription.queued.closers.length;\r\n                    var closingServer_1 = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n                    subscription.handlers.onClosed.forEach(function (callback) {\r\n                        if (typeof callback === \"function\") {\r\n                            callback({\r\n                                message: ON_CLOSE_MSG_SERVER_INIT,\r\n                                requestArguments: subscription.arguments,\r\n                                server: closingServer_1,\r\n                                stream: subscription.method,\r\n                            });\r\n                        }\r\n                    });\r\n                    delete _this.subscriptionsList[subscriptionId];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return this.subscriptionsList[subscriptionId];\r\n    };\r\n    ClientStreaming.prototype.serverIsKickingASubscriber = function (msg) {\r\n        var _this = this;\r\n        var keys = Object.keys(this.subscriptionsList);\r\n        if (typeof msg.InvocationId === \"string\" && msg.InvocationId !== \"\") {\r\n            keys = keys.filter(function (k) { return k === msg.InvocationId; });\r\n        }\r\n        var deletionsList = [];\r\n        keys.forEach(function (key) {\r\n            if (typeof _this.subscriptionsList[key] !== \"object\") {\r\n                return;\r\n            }\r\n            _this.subscriptionsList[key].trackedServers = _this.subscriptionsList[key].trackedServers.filter(function (server) {\r\n                var isRejecting = (server.methodRequestSubject === msg.MethodRequestSubject && server.methodResponseSubject === msg.MethodResponseSubject);\r\n                var isKicking = (server.streamId === msg.StreamId &&\r\n                    (server.streamSubjects.global === msg.EventStreamSubject || server.streamSubjects.private === msg.EventStreamSubject));\r\n                var isRejectingOrKicking = isRejecting || isKicking;\r\n                return !isRejectingOrKicking;\r\n            });\r\n            if (_this.subscriptionsList[key].trackedServers.length === 0) {\r\n                deletionsList.push(key);\r\n            }\r\n        });\r\n        deletionsList.forEach(function (key) {\r\n            if (typeof _this.subscriptionsList[key] !== \"object\") {\r\n                return;\r\n            }\r\n            if (_this.subscriptionsList[key].status === STATUS_AWAITING_ACCEPT &&\r\n                typeof _this.subscriptionsList[key].timeoutId === \"number\") {\r\n                var reason = (typeof msg.ResultMessage === \"string\" && msg.ResultMessage !== \"\") ?\r\n                    ' Publisher said \"' + msg.ResultMessage + '\".' :\r\n                    \" No reason given.\";\r\n                var callArgs = typeof _this.subscriptionsList[key].arguments === \"object\" ?\r\n                    JSON.stringify(_this.subscriptionsList[key].arguments) :\r\n                    \"{}\";\r\n                _this.subscriptionsList[key].error(ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs);\r\n                clearTimeout(_this.subscriptionsList[key].timeoutId);\r\n            }\r\n            else {\r\n                _this.subscriptionsList[key].handlers.onClosed.forEach(function (callback) {\r\n                    if (typeof callback !== \"function\") {\r\n                        return;\r\n                    }\r\n                    callback({\r\n                        message: ON_CLOSE_MSG_SERVER_INIT,\r\n                        requestArguments: _this.subscriptionsList[key].arguments,\r\n                        server: helpers_1.convertInfoToInstance(msg.Server),\r\n                        stream: _this.subscriptionsList[key].method,\r\n                    });\r\n                });\r\n            }\r\n            delete _this.subscriptionsList[key];\r\n        });\r\n    };\r\n    ClientStreaming.prototype.serverAcknowledgesGoodSubscription = function (msg) {\r\n        var _this = this;\r\n        var subscriptionId = msg.InvocationId;\r\n        var subscription = this.subscriptionsList[subscriptionId];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        var acceptingServer = subscription.trackedServers.filter(function (server) {\r\n            return (server.methodRequestSubject === msg.MethodRequestSubject &&\r\n                server.methodResponseSubject === msg.MethodResponseSubject);\r\n        })[0];\r\n        if (typeof acceptingServer !== \"object\") {\r\n            return;\r\n        }\r\n        var isFirstResponse = (subscription.status === STATUS_AWAITING_ACCEPT);\r\n        subscription.status = STATUS_SUBSCRIBED;\r\n        var privateStreamSubject = this.generatePrivateStreamSubject(subscription.method.name);\r\n        if (typeof acceptingServer.streamId === \"string\" && acceptingServer.streamId !== \"\") {\r\n            return;\r\n        }\r\n        acceptingServer.server = helpers_1.convertInfoToInstance(msg.Server);\r\n        acceptingServer.streamId = msg.StreamId;\r\n        acceptingServer.streamSubjects.global = msg.EventStreamSubject;\r\n        acceptingServer.streamSubjects.private = privateStreamSubject;\r\n        var confirmatoryRequest = {\r\n            EventStreamAction: 3,\r\n            EventStreamSubject: privateStreamSubject,\r\n            StreamId: msg.StreamId,\r\n            MethodRequestSubject: msg.MethodRequestSubject,\r\n            MethodResponseSubject: acceptingServer.methodResponseSubject,\r\n            Client: helpers_1.convertInstance(this.instance),\r\n            Context: {\r\n                ArgumentsJson: subscription.arguments,\r\n                MethodName: subscription.method.name,\r\n            },\r\n        };\r\n        this.sendRequest(confirmatoryRequest);\r\n        if (isFirstResponse) {\r\n            subscription.success({\r\n                onData: function (dataCallback) {\r\n                    if (typeof dataCallback !== \"function\") {\r\n                        throw new TypeError(\"The data callback must be a function.\");\r\n                    }\r\n                    this.handlers.onData.push(dataCallback);\r\n                    if (this.handlers.onData.length === 1 && this.queued.data.length > 0) {\r\n                        this.queued.data.forEach(function (dataItem) {\r\n                            dataCallback(dataItem);\r\n                        });\r\n                    }\r\n                }.bind(subscription),\r\n                onClosed: function (closedCallback) {\r\n                    if (typeof closedCallback !== \"function\") {\r\n                        throw new TypeError(\"The callback must be a function.\");\r\n                    }\r\n                    this.handlers.onClosed.push(closedCallback);\r\n                }.bind(subscription),\r\n                onFailed: function () { },\r\n                close: function () { return _this.closeSubscription(subscription, subscriptionId); },\r\n                requestArguments: subscription.arguments,\r\n                serverInstance: helpers_1.convertInfoToInstance(msg.Server),\r\n                stream: subscription.method,\r\n            });\r\n        }\r\n    };\r\n    ClientStreaming.prototype.serverHasPushedSomeDataIntoTheStream = function (msg) {\r\n        var _loop_1 = function (key) {\r\n            if (this_1.subscriptionsList.hasOwnProperty(key) && typeof this_1.subscriptionsList[key] === \"object\") {\r\n                var isPrivateData = void 0;\r\n                var trackedServersFound = this_1.subscriptionsList[key].trackedServers.filter(function (ls) {\r\n                    return (ls.streamId === msg.StreamId &&\r\n                        (ls.streamSubjects.global === msg.EventStreamSubject ||\r\n                            ls.streamSubjects.private === msg.EventStreamSubject));\r\n                });\r\n                if (trackedServersFound.length === 0) {\r\n                    isPrivateData = undefined;\r\n                }\r\n                else if (trackedServersFound[0].streamSubjects.global === msg.EventStreamSubject) {\r\n                    isPrivateData = false;\r\n                }\r\n                else if (trackedServersFound[0].streamSubjects.private === msg.EventStreamSubject) {\r\n                    isPrivateData = true;\r\n                }\r\n                if (isPrivateData !== undefined) {\r\n                    var receivedStreamData_1 = {\r\n                        data: msg.ResultContextJson,\r\n                        server: helpers_1.convertInfoToInstance(msg.Server),\r\n                        requestArguments: this_1.subscriptionsList[key].arguments || {},\r\n                        message: msg.ResultMessage,\r\n                        private: isPrivateData,\r\n                    };\r\n                    var onDataHandlers = this_1.subscriptionsList[key].handlers.onData;\r\n                    var queuedData = this_1.subscriptionsList[key].queued.data;\r\n                    if (Array.isArray(onDataHandlers)) {\r\n                        if (onDataHandlers.length > 0) {\r\n                            onDataHandlers.forEach(function (callback) {\r\n                                if (typeof callback === \"function\") {\r\n                                    callback(receivedStreamData_1);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            queuedData.push(receivedStreamData_1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var key in this.subscriptionsList) {\r\n            _loop_1(key);\r\n        }\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (sub, subId) {\r\n        var _this = this;\r\n        var responseSubject = this.nextResponseSubject();\r\n        sub.trackedServers.forEach(function (server) {\r\n            _this.sendRequest({\r\n                EventStreamAction: 2,\r\n                Client: helpers_1.convertInstance(_this.instance),\r\n                MethodRequestSubject: server.methodRequestSubject,\r\n                MethodResponseSubject: responseSubject,\r\n                StreamId: server.streamId,\r\n                EventStreamSubject: server.streamSubjects.private,\r\n            });\r\n        });\r\n        sub.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback === \"function\") {\r\n                callback({\r\n                    message: ON_CLOSE_MSG_CLIENT_INIT,\r\n                    requestArguments: sub.arguments || {},\r\n                    server: sub.trackedServers[sub.trackedServers.length - 1].server,\r\n                    stream: sub.method,\r\n                });\r\n            }\r\n        });\r\n        delete this.subscriptionsList[subId];\r\n    };\r\n    ClientStreaming.prototype.generatePrivateStreamSubject = function (methodName) {\r\n        var appInfo = helpers_1.convertInstance(this.instance);\r\n        return \"ESSpriv-jsb_\" +\r\n            appInfo.ApplicationName +\r\n            \"_on_\" +\r\n            methodName +\r\n            \"_\" +\r\n            random_1.default();\r\n    };\r\n    return ClientStreaming;\r\n}());\r\nexports.default = ClientStreaming;\r\n//# sourceMappingURL=client-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/client-streaming.js\n// module id = 56\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"../../helpers/random\");\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar client_streaming_1 = require(\"./client-streaming\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar numberMissingHeartbeatsToRemove = 3;\r\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(connection, instance, configuration, repository) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.repository = repository;\r\n        this.respCounter = 0;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.timers = {};\r\n        this.timers = {};\r\n        this.streaming = new client_streaming_1.default(configuration, instance, function (msg) {\r\n            connection.send(\"agm\", \"MethodInvocationRequestMessage\", msg);\r\n        }, function () { return _this.nextResponseSubject(); });\r\n        this.listenForEvents();\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        this.streaming.subscribe(stream, args, targetServers, options, success, error);\r\n    };\r\n    ClientProtocol.prototype.onInvocationResult = function (callback) {\r\n        this.callbacks.add(\"onResult\", callback);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target, stuff) {\r\n        var methodInfo = method.info;\r\n        var message = {\r\n            MethodRequestSubject: methodInfo.requestSubject,\r\n            MethodResponseSubject: this.nextResponseSubject(),\r\n            Client: helpers_1.convertInstance(this.instance),\r\n            Context: {\r\n                ArgumentsJson: args,\r\n                InvocationId: id,\r\n                MethodName: methodInfo.name,\r\n                ExecutionServer: target.info,\r\n                Timeout: stuff.methodResponseTimeoutMs,\r\n            },\r\n        };\r\n        this.connection.send(\"agm\", \"MethodInvocationRequestMessage\", message);\r\n    };\r\n    ClientProtocol.prototype.nextResponseSubject = function () {\r\n        return \"resp_\" + (this.respCounter++) + \"_\" + random_1.default();\r\n    };\r\n    ClientProtocol.prototype.createServerInfo = function (instance) {\r\n        return {\r\n            machine: instance.MachineName,\r\n            pid: instance.ProcessId,\r\n            user: instance.UserName,\r\n            application: instance.ApplicationName,\r\n            environment: instance.Environment,\r\n            region: instance.Region,\r\n        };\r\n    };\r\n    ClientProtocol.prototype.createMethod = function (methodInfo) {\r\n        var method = methodInfo.Method;\r\n        return {\r\n            name: method.Name,\r\n            accepts: method.InputSignature,\r\n            returns: method.ResultSignature,\r\n            requestSubject: methodInfo.MethodRequestSubject,\r\n            description: method.Description,\r\n            displayName: method.DisplayName,\r\n            version: method.Version,\r\n            objectTypes: method.ObjectTypeRestrictions,\r\n            supportsStreaming: helpers_1.isStreamingFlagSet(method.Flags),\r\n        };\r\n    };\r\n    ClientProtocol.prototype.createServerId = function (serverInfo) {\r\n        if (serverInfo === undefined) {\r\n            return undefined;\r\n        }\r\n        return [serverInfo.application,\r\n            serverInfo.user,\r\n            serverInfo.machine,\r\n            serverInfo.started,\r\n            serverInfo.pid].join(\"/\").toLowerCase();\r\n    };\r\n    ClientProtocol.prototype.processServerPresence = function (presence, isPresence) {\r\n        var instance = presence.Instance;\r\n        var serverInfo = this.createServerInfo(instance);\r\n        var serverId = this.createServerId(serverInfo);\r\n        if (isPresence) {\r\n            serverId = this.repository.addServer(serverInfo, serverId);\r\n            if (presence.PublishingInterval) {\r\n                this.scheduleTimeout(serverId, presence.PublishingInterval);\r\n            }\r\n        }\r\n        else if (presence.PublishingInterval === 0) {\r\n            var server = this.repository.getServerById(serverId);\r\n            if (typeof server !== \"undefined\") {\r\n                this.repository.removeServerById(serverId);\r\n            }\r\n        }\r\n        if (presence.MethodDefinitions !== undefined) {\r\n            this.updateServerMethods(serverId, presence.MethodDefinitions);\r\n        }\r\n    };\r\n    ClientProtocol.prototype.scheduleTimeout = function (serverId, duration) {\r\n        var _this = this;\r\n        if (duration === -1) {\r\n            return;\r\n        }\r\n        var timer = this.timers[serverId];\r\n        if (timer !== undefined) {\r\n            clearTimeout(timer);\r\n        }\r\n        this.timers[serverId] = setTimeout(function () {\r\n            _this.repository.removeServerById(serverId);\r\n        }, duration * (numberMissingHeartbeatsToRemove + 1));\r\n    };\r\n    ClientProtocol.prototype.updateServerMethods = function (serverId, newMethods) {\r\n        var _this = this;\r\n        var oldMethods = this.repository.getServerMethodsById(serverId);\r\n        var newMethodsReduced = newMethods\r\n            .map(function (nm) { return _this.createMethod(nm); })\r\n            .reduce(function (obj, method) {\r\n            var methodId = _this.repository.createMethodId(method);\r\n            obj[methodId] = method;\r\n            return obj;\r\n        }, {});\r\n        oldMethods.forEach(function (method) {\r\n            if (newMethodsReduced[method.id] === undefined) {\r\n                _this.repository.removeServerMethod(serverId, method.id);\r\n            }\r\n            else {\r\n                delete newMethodsReduced[method.id];\r\n            }\r\n        });\r\n        Object.keys(newMethodsReduced).forEach(function (key) {\r\n            var method = newMethodsReduced[key];\r\n            _this.repository.addServerMethod(serverId, method);\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleInvokeResultMessage = function (message) {\r\n        if (message && message.EventStreamAction && message.EventStreamAction !== 0) {\r\n            this.streaming.processPublisherMsg(message);\r\n            return;\r\n        }\r\n        var server = message.Server ? this.createServerInfo(message.Server) : undefined;\r\n        var result = message.ResultContextJson;\r\n        if (result && Object.keys(result).length === 0) {\r\n            result = undefined;\r\n        }\r\n        this.callbacks.execute(\"onResult\", message.InvocationId, server, message.Status, result, message.ResultMessage);\r\n    };\r\n    ClientProtocol.prototype.listenForEvents = function () {\r\n        var _this = this;\r\n        this.connection.on(\"agm\", \"ServerPresenceMessage\", function (msg) {\r\n            _this.processServerPresence(msg, true);\r\n        });\r\n        this.connection.on(\"agm\", \"ServerHeartbeatMessage\", function (msg) {\r\n            _this.processServerPresence(msg, false);\r\n        });\r\n        this.connection.on(\"agm\", \"MethodInvocationResultMessage\", function (msg) {\r\n            _this.handleInvokeResultMessage(msg);\r\n        });\r\n    };\r\n    return ClientProtocol;\r\n}());\r\nexports.default = ClientProtocol;\r\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/client.js\n// module id = 57\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar server_1 = require(\"./server\");\r\nvar client_1 = require(\"./client\");\r\nfunction default_1(instance, connection, clientRepository, serverRepository, configuration, getAGM) {\r\n    var unsubscribe = connection.on(\"agm\", \"Instance\", function (newInstance) {\r\n        getAGM().updateInstance(newInstance);\r\n        connection.off(unsubscribe);\r\n    });\r\n    var server = new server_1.default(connection, instance, configuration, serverRepository);\r\n    var client = new client_1.default(connection, instance, configuration, clientRepository);\r\n    return new Promise(function (resolve) {\r\n        resolve({\r\n            server: server,\r\n            client: client,\r\n        });\r\n    });\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=factory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/factory.js\n// module id = 58\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"./../../helpers/random\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(connection, instance) {\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n    }\r\n    ServerStreaming.prototype.isStreamMsg = function (msg, method) {\r\n        return (msg &&\r\n            msg.EventStreamAction &&\r\n            msg.EventStreamAction !== 0 &&\r\n            typeof method === \"object\" &&\r\n            method.definition.supportsStreaming === true);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = null;\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            return (branches === null || (Boolean(br) && typeof br.key === \"string\" && branches.indexOf(br.key) >= 0));\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        var server = helpers_1.convertInstance(this.instance);\r\n        streamIdList.forEach(function (streamId) {\r\n            _this.sendResult({\r\n                EventStreamAction: 5,\r\n                EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                ResultContextJson: data,\r\n                Server: server,\r\n                StreamId: streamId,\r\n            });\r\n        });\r\n    };\r\n    ServerStreaming.prototype.closeAllSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        var streamList = streamingMethod.protocolState.branchKeyToStreamIdMap;\r\n        if (typeof branchKey === \"string\") {\r\n            streamList = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (br) {\r\n                return (typeof br === \"object\" && br.key === branchKey);\r\n            });\r\n        }\r\n        streamList.forEach(function (br) {\r\n            var streamId = br.streamId;\r\n            _this.sendResult({\r\n                EventStreamAction: 2,\r\n                EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                Server: helpers_1.convertInstance(_this.instance),\r\n                StreamId: streamId,\r\n                Status: 0,\r\n            });\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        return this.getUniqueBranchNames(streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = streamingMethod.protocolState.subscriptions;\r\n        }\r\n        else {\r\n            subscriptions = streamingMethod.protocolState.subscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.subAddedHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.subRemovedHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (handlerFunc) {\r\n        if (typeof handlerFunc !== \"function\") {\r\n            return;\r\n        }\r\n        this.requestHandler = handlerFunc;\r\n    };\r\n    ServerStreaming.prototype.generateNewStreamId = function (streamingMethodName) {\r\n        var appInfo = helpers_1.convertInstance(this.instance);\r\n        return \"streamId-jsb_of_\" +\r\n            streamingMethodName +\r\n            \"__by_\" +\r\n            appInfo.ApplicationName +\r\n            \"_\" +\r\n            random_1.default();\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        var msg = requestContext.msg;\r\n        this.sendResult({\r\n            EventStreamAction: 2,\r\n            EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            MethodResponseSubject: msg.MethodResponseSubject,\r\n            MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n            ResultMessage: reason,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: \"default_rejection_streamId\",\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (streamingMethod, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this.sendResult({\r\n            EventStreamAction: 5,\r\n            EventStreamSubject: subscription.privateEventStreamSubject,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            ResultContextJson: data,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: subscription.streamId,\r\n        });\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        this.closeIndividualSubscription(streamingMethod, subscription.streamId, subscription.privateEventStreamSubject, true);\r\n    };\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var msg = requestContext.msg;\r\n        this.sendResult({\r\n            EventStreamAction: 3,\r\n            EventStreamSubject: streamingMethod.protocolState.globalEventStreamSubject,\r\n            InvocationId: msg.Context.InvocationId,\r\n            MethodName: streamingMethod.protocolState.method.Method.Name,\r\n            MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n            MethodResponseSubject: msg.MethodResponseSubject,\r\n            MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n            ResultMessage: \"Accepted\",\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            StreamId: streamId,\r\n        });\r\n    };\r\n    ServerStreaming.prototype.processSubscriberMsg = function (msg, streamingMethod) {\r\n        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {\r\n            return;\r\n        }\r\n        if (msg.EventStreamAction === 1) {\r\n            this.clientWishesToSubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 2) {\r\n            this.clientWishesToUnsubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 3) {\r\n            this.clientAcknowledgesItDidSubscribe(msg, streamingMethod);\r\n        }\r\n        else if (msg.EventStreamAction === 4) {\r\n            this.clientPerSubHeartbeat(msg);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.sendResult = function (message) {\r\n        if (typeof message !== \"object\") {\r\n            throw new Error(\"Invalid message.\");\r\n        }\r\n        if (typeof message.Status !== \"number\") {\r\n            message.Status = 0;\r\n        }\r\n        this.connection.send(\"agm\", \"MethodInvocationResultMessage\", message);\r\n    };\r\n    ServerStreaming.prototype.clientWishesToSubscribe = function (msg, streamingMethod) {\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.Context.ArgumentsJson || {},\r\n            instance: helpers_1.convertInfoToInstance(msg.Client),\r\n        };\r\n        if (typeof this.requestHandler === \"function\") {\r\n            this.requestHandler(requestContext, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.clientWishesToUnsubscribe = function (msg, streamingMethod) {\r\n        if (!(streamingMethod &&\r\n            Array.isArray(streamingMethod.protocolState.subscriptions) &&\r\n            streamingMethod.protocolState.subscriptions.length > 0)) {\r\n            return;\r\n        }\r\n        this.closeIndividualSubscription(streamingMethod, msg.StreamId, msg.EventStreamSubject, false);\r\n    };\r\n    ServerStreaming.prototype.clientAcknowledgesItDidSubscribe = function (msg, streamingMethod) {\r\n        if (typeof msg.StreamId !== \"string\" || msg.StreamId === \"\") {\r\n            return;\r\n        }\r\n        var branchKey = this.getBranchKey(streamingMethod, msg.StreamId);\r\n        if (typeof branchKey !== \"string\") {\r\n            return;\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.subscriptions)) {\r\n            return;\r\n        }\r\n        var subscription = {\r\n            branchKey: branchKey,\r\n            instance: helpers_1.convertInfoToInstance(msg.Client),\r\n            arguments: msg.Context.ArgumentsJson,\r\n            streamId: msg.StreamId,\r\n            privateEventStreamSubject: msg.EventStreamSubject,\r\n            methodResponseSubject: msg.MethodResponseSubject,\r\n        };\r\n        streamingMethod.protocolState.subscriptions.push(subscription);\r\n        if (typeof this.subAddedHandler === \"function\") {\r\n            this.subAddedHandler(subscription, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.clientPerSubHeartbeat = function (msg) {\r\n    };\r\n    ServerStreaming.prototype.getBranchKey = function (streamingMethod, streamId) {\r\n        if (typeof streamId !== \"string\" || typeof streamingMethod !== \"object\") {\r\n            return;\r\n        }\r\n        var needle = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.streamId === streamId;\r\n        })[0];\r\n        if (typeof needle !== \"object\" || typeof needle.key !== \"string\") {\r\n            return;\r\n        }\r\n        return needle.key;\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.generateNewStreamId(streamingMethod.protocolState.method.Method.Name);\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    ServerStreaming.prototype.closeIndividualSubscription = function (streamingMethod, streamId, privateEventStreamSubject, sendKickMessage) {\r\n        var subscription = streamingMethod.protocolState.subscriptions.filter(function (subItem) {\r\n            return (subItem.privateEventStreamSubject === privateEventStreamSubject &&\r\n                subItem.streamId === streamId);\r\n        })[0];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        var initialLength = streamingMethod.protocolState.subscriptions.length;\r\n        streamingMethod.protocolState.subscriptions = streamingMethod.protocolState.subscriptions.filter(function (subItem) {\r\n            return !(subItem.privateEventStreamSubject === subscription.privateEventStreamSubject &&\r\n                subItem.streamId === subscription.streamId);\r\n        });\r\n        var filteredLength = streamingMethod.protocolState.subscriptions.length;\r\n        if (filteredLength !== (initialLength - 1)) {\r\n            return;\r\n        }\r\n        if (sendKickMessage === true) {\r\n            this.sendResult({\r\n                EventStreamAction: 2,\r\n                EventStreamSubject: privateEventStreamSubject,\r\n                MethodName: streamingMethod.protocolState.method.Method.Name,\r\n                MethodRequestSubject: streamingMethod.protocolState.method.MethodRequestSubject,\r\n                MethodResponseSubject: subscription.methodResponseSubject,\r\n                MethodVersion: streamingMethod.protocolState.method.Method.Version,\r\n                ResponseContextJson: {},\r\n                Server: helpers_1.convertInstance(this.instance),\r\n                StreamId: subscription.streamId,\r\n                Status: 0,\r\n            });\r\n        }\r\n        if (typeof this.subRemovedHandler === \"function\") {\r\n            this.subRemovedHandler(subscription, streamingMethod);\r\n        }\r\n    };\r\n    ServerStreaming.prototype.getUniqueBranchNames = function (streamingMethod) {\r\n        var keysWithDuplicates = streamingMethod.protocolState.subscriptions.map(function (sub) {\r\n            var result = null;\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                result = sub.branchKey;\r\n            }\r\n            return result;\r\n        });\r\n        var seen = [];\r\n        var branchArray = keysWithDuplicates.filter(function (bKey) {\r\n            if (bKey === null || seen.indexOf(bKey) >= 0) {\r\n                return false;\r\n            }\r\n            seen.push(bKey);\r\n            return true;\r\n        });\r\n        return branchArray;\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=server-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/server-streaming.js\n// module id = 59\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar random_1 = require(\"../../helpers/random\");\r\nvar server_streaming_1 = require(\"./server-streaming\");\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar helpers_1 = require(\"./helpers\");\r\nvar HeartbeatInterval = 5000;\r\nvar PresenceInterval = 10000;\r\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(connection, instance, configuration, serverRepository) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.instance = instance;\r\n        this.serverRepository = serverRepository;\r\n        this.invocationMessagesMap = {};\r\n        this.reqCounter = 0;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.streaming = new server_streaming_1.default(connection, instance);\r\n        connection.on(\"agm\", \"MethodInvocationRequestMessage\", function (msg) { return _this.handleMethodInvocationMessage(msg); });\r\n        connection.disconnected(this.stopTimers.bind(this));\r\n        this.sendHeartbeat();\r\n        if (this.heartbeatTimer === undefined) {\r\n            this.heartbeatTimer = setInterval(function () { return _this.sendHeartbeat(); }, HeartbeatInterval);\r\n        }\r\n        this.getBranchList = this.streaming.getBranchList;\r\n        this.getSubscriptionList = this.streaming.getSubscriptionList;\r\n        this.closeAllSubscriptions = this.streaming.closeAllSubscriptions;\r\n        this.closeSingleSubscription = this.streaming.closeSingleSubscription;\r\n        this.pushDataToSingle = this.streaming.pushDataToSingle;\r\n        this.pushData = this.streaming.pushData;\r\n        this.onSubRequest = this.streaming.onSubRequest;\r\n        this.acceptRequestOnBranch = this.streaming.acceptRequestOnBranch;\r\n        this.rejectRequest = this.streaming.rejectRequest;\r\n        this.onSubAdded = this.streaming.onSubAdded;\r\n        this.onSubRemoved = this.streaming.onSubRemoved;\r\n    }\r\n    ServerProtocol.prototype.stopTimers = function () {\r\n        clearInterval(this.presenceTimer);\r\n        clearInterval(this.heartbeatTimer);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (info) {\r\n        this.sendPresence();\r\n        return Promise.resolve();\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, success, error) {\r\n        var reqSubj = this.nextRequestSubject();\r\n        repoMethod.protocolState.method = this.createNewMethodMessage(repoMethod.definition, reqSubj, false);\r\n        this.announceNewMethod();\r\n        success();\r\n        return Promise.resolve();\r\n    };\r\n    ServerProtocol.prototype.createStream = function (repoMethod, success, error) {\r\n        var reqSubj = this.nextRequestSubject();\r\n        var streamConverted = this.createNewMethodMessage(repoMethod.definition, reqSubj, true);\r\n        repoMethod.protocolState.method = streamConverted;\r\n        repoMethod.protocolState.globalEventStreamSubject = repoMethod.definition.name + \".jsStream.\" + random_1.default();\r\n        repoMethod.protocolState.subscriptions = [];\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        this.announceNewMethod();\r\n        success();\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (executedMethod, invocationId, err, result) {\r\n        var message = this.invocationMessagesMap[invocationId];\r\n        if (!message) {\r\n            return;\r\n        }\r\n        if (message.MethodResponseSubject === \"null\") {\r\n            return;\r\n        }\r\n        if (executedMethod === undefined) {\r\n            return;\r\n        }\r\n        var resultMessage = {\r\n            MethodRequestSubject: message.MethodRequestSubject,\r\n            MethodResponseSubject: message.MethodResponseSubject,\r\n            MethodName: executedMethod.protocolState.method.Method.Name,\r\n            InvocationId: invocationId,\r\n            ResultContextJson: result,\r\n            Server: helpers_1.convertInstance(this.instance),\r\n            ResultMessage: err,\r\n            Status: err ? 1 : 0,\r\n        };\r\n        this.connection.send(\"agm\", \"MethodInvocationResultMessage\", resultMessage);\r\n        delete this.invocationMessagesMap[invocationId];\r\n    };\r\n    ServerProtocol.prototype.nextRequestSubject = function () {\r\n        return \"req_\" + (this.reqCounter++) + \"_\" + random_1.default();\r\n    };\r\n    ServerProtocol.prototype.sendHeartbeat = function () {\r\n        this.connection.send(\"agm\", \"ServerHeartbeatMessage\", this.constructHeartbeat());\r\n    };\r\n    ServerProtocol.prototype.constructHeartbeat = function () {\r\n        return {\r\n            PublishingInterval: HeartbeatInterval,\r\n            Instance: helpers_1.convertInstance(this.instance),\r\n        };\r\n    };\r\n    ServerProtocol.prototype.constructPresence = function () {\r\n        var methods = this.serverRepository.getList();\r\n        return {\r\n            PublishingInterval: PresenceInterval,\r\n            Instance: helpers_1.convertInstance(this.instance),\r\n            MethodDefinitions: methods.map(function (m) { return m.protocolState.method; }),\r\n        };\r\n    };\r\n    ServerProtocol.prototype.sendPresence = function () {\r\n        this.connection.send(\"agm\", \"ServerPresenceMessage\", this.constructPresence());\r\n    };\r\n    ServerProtocol.prototype.announceNewMethod = function () {\r\n        var _this = this;\r\n        this.sendPresence();\r\n        if (this.presenceTimer === undefined) {\r\n            this.presenceTimer = setInterval(function () { return _this.sendPresence(); }, PresenceInterval);\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleMethodInvocationMessage = function (message) {\r\n        var subject = message.MethodRequestSubject;\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.protocolState.method.MethodRequestSubject === subject;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        if (this.streaming.isStreamMsg(message, method)) {\r\n            this.streaming.processSubscriberMsg(message, method);\r\n            return;\r\n        }\r\n        var invocationId = message.Context.InvocationId;\r\n        this.invocationMessagesMap[invocationId] = message;\r\n        var invocationArgs = {\r\n            args: message.Context.ArgumentsJson,\r\n            instance: helpers_1.convertInfoToInstance(message.Client),\r\n        };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    ServerProtocol.prototype.createNewMethodMessage = function (methodIdentifier, subject, stream) {\r\n        if (typeof methodIdentifier === \"string\") {\r\n            methodIdentifier = { name: methodIdentifier };\r\n        }\r\n        if (typeof methodIdentifier.version !== \"number\") {\r\n            methodIdentifier.version = 0;\r\n        }\r\n        return {\r\n            Method: {\r\n                Name: methodIdentifier.name,\r\n                InputSignature: methodIdentifier.accepts,\r\n                ResultSignature: methodIdentifier.returns,\r\n                Description: methodIdentifier.description,\r\n                DisplayName: methodIdentifier.displayName,\r\n                Version: methodIdentifier.version,\r\n                ObjectTypeRestrictions: methodIdentifier.objectTypes,\r\n                Flags: stream ? 32 : undefined,\r\n            },\r\n            MethodRequestSubject: subject,\r\n        };\r\n    };\r\n    return ServerProtocol;\r\n}());\r\nexports.default = ServerProtocol;\r\n//# sourceMappingURL=server.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw1/server.js\n// module id = 60\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(instance, session, repository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        this.nextSubLocalKey = 0;\r\n        this.handleErrorSubscribing = function (errorResponse) {\r\n            var tag = errorResponse._tag;\r\n            var subLocalKey = tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                return server.serverId !== tag.serverId;\r\n            });\r\n            if (pendingSub.trackedServers.length <= 0) {\r\n                clearTimeout(pendingSub.timeoutId);\r\n                if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                    var reason = (typeof errorResponse.reason === \"string\" && errorResponse.reason !== \"\") ?\r\n                        ' Publisher said \"' + errorResponse.reason + '\".' :\r\n                        \" No reason given.\";\r\n                    var callArgs = typeof pendingSub.arguments === \"object\" ?\r\n                        JSON.stringify(pendingSub.arguments) :\r\n                        \"{}\";\r\n                    pendingSub.error({\r\n                        message: ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs,\r\n                        called_with: pendingSub.arguments,\r\n                        method: pendingSub.method.getInfoForUser(),\r\n                    });\r\n                }\r\n                else if (pendingSub.status === STATUS_SUBSCRIBED) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                }\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n        };\r\n        this.handleSubscribed = function (msg) {\r\n            var subLocalKey = msg._tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            var serverId = msg._tag.serverId;\r\n            var acceptingServer = pendingSub.trackedServers\r\n                .filter(function (server) {\r\n                return server.serverId === serverId;\r\n            })[0];\r\n            if (typeof acceptingServer !== \"object\") {\r\n                return;\r\n            }\r\n            acceptingServer.subscriptionId = msg.subscription_id;\r\n            _this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;\r\n            var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);\r\n            pendingSub.status = STATUS_SUBSCRIBED;\r\n            var that = _this;\r\n            if (isFirstResponse) {\r\n                pendingSub.success({\r\n                    onData: function (dataCallback) {\r\n                        if (typeof dataCallback !== \"function\") {\r\n                            throw new TypeError(\"The data callback must be a function.\");\r\n                        }\r\n                        pendingSub.handlers.onData.push(dataCallback);\r\n                        if (pendingSub.handlers.onData.length === 1 && pendingSub.queued.data.length > 0) {\r\n                            pendingSub.queued.data.forEach(function (dataItem) {\r\n                                dataCallback(dataItem);\r\n                            });\r\n                        }\r\n                    },\r\n                    onClosed: function (closedCallback) {\r\n                        if (typeof closedCallback !== \"function\") {\r\n                            throw new TypeError(\"The callback must be a function.\");\r\n                        }\r\n                        pendingSub.handlers.onClosed.push(closedCallback);\r\n                    },\r\n                    onFailed: function () {\r\n                    },\r\n                    close: function () { return that.closeSubscription(subLocalKey); },\r\n                    requestArguments: pendingSub.arguments,\r\n                    serverInstance: that.repository.getServerById(serverId).getInfoForUser(),\r\n                    stream: pendingSub.method.info,\r\n                });\r\n            }\r\n        };\r\n        this.handleEventData = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var trackedServersFound = subscription.trackedServers.filter(function (server) {\r\n                return server.subscriptionId === msg.subscription_id;\r\n            });\r\n            if (trackedServersFound.length !== 1) {\r\n                return;\r\n            }\r\n            var isPrivateData = msg.oob && msg.snapshot;\r\n            var sendingServerId = trackedServersFound[0].serverId;\r\n            var receivedStreamData = function () {\r\n                return {\r\n                    data: msg.data,\r\n                    server: _this.repository.getServerById(sendingServerId).getInfoForUser(),\r\n                    requestArguments: subscription.arguments || {},\r\n                    message: null,\r\n                    private: isPrivateData,\r\n                };\r\n            };\r\n            var onDataHandlers = subscription.handlers.onData;\r\n            var queuedData = subscription.queued.data;\r\n            if (onDataHandlers.length > 0) {\r\n                onDataHandlers.forEach(function (callback) {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(receivedStreamData());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                queuedData.push(receivedStreamData());\r\n            }\r\n        };\r\n        this.handleSubscriptionCancelled = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var expectedNewLength = subscription.trackedServers.length - 1;\r\n            subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                if (server.subscriptionId === msg.subscription_id) {\r\n                    subscription.queued.closers.push(server.serverId);\r\n                    return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            });\r\n            if (subscription.trackedServers.length !== expectedNewLength) {\r\n                return;\r\n            }\r\n            if (subscription.trackedServers.length <= 0) {\r\n                clearTimeout(subscription.timeoutId);\r\n                _this.callOnClosedHandlers(subscription);\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            delete _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n        };\r\n        session.on(\"subscribed\", this.handleSubscribed);\r\n        session.on(\"event\", this.handleEventData);\r\n        session.on(\"subscription-cancelled\", this.handleSubscriptionCancelled);\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (streamingMethod, argumentObj, targetServers, stuff, success, error) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: streamingMethod.getInfoForUser(),\r\n                called_with: argumentObj,\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n            });\r\n            return;\r\n        }\r\n        var subLocalKey = this.getNextSubscriptionLocalKey();\r\n        var pendingSub = this.registerSubscription(subLocalKey, streamingMethod, argumentObj, success, error, stuff.methodResponseTimeout);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: streamingMethod.getInfoForUser(),\r\n                called_with: argumentObj,\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var serverId = target.server.id;\r\n            pendingSub.trackedServers.push({\r\n                serverId: serverId,\r\n                subscriptionId: undefined,\r\n            });\r\n            var msg = {\r\n                type: \"subscribe\",\r\n                server_id: serverId,\r\n                method_id: streamingMethod.protocolState.id,\r\n                arguments_kv: argumentObj,\r\n            };\r\n            _this.session.send(msg, { serverId: serverId, subLocalKey: subLocalKey })\r\n                .then(function (m) { return _this.handleSubscribed(m); })\r\n                .catch(function (err) { return _this.handleErrorSubscribing(err); });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.getNextSubscriptionLocalKey = function () {\r\n        var current = this.nextSubLocalKey;\r\n        this.nextSubLocalKey += 1;\r\n        return current;\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subLocalKey, method, args, success, error, timeout) {\r\n        var _this = this;\r\n        this.subscriptionsList[subLocalKey] = {\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            arguments: args,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: [],\r\n                onClosed: [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n        };\r\n        this.subscriptionsList[subLocalKey].timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subLocalKey] === undefined) {\r\n                return;\r\n            }\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method.getInfoForUser(),\r\n                    called_with: args,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \" ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {\r\n                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                    return (typeof server.subscriptionId !== \"undefined\");\r\n                });\r\n                delete pendingSub.timeoutId;\r\n                if (pendingSub.trackedServers.length <= 0) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                    delete _this.subscriptionsList[subLocalKey];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return this.subscriptionsList[subLocalKey];\r\n    };\r\n    ClientStreaming.prototype.callOnClosedHandlers = function (subscription, reason) {\r\n        var closersCount = subscription.queued.closers.length;\r\n        var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n        var closingServer = null;\r\n        if (typeof closingServerId === \"number\") {\r\n            closingServer = this.repository.getServerById(closingServerId).getInfoForUser();\r\n        }\r\n        subscription.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback !== \"function\") {\r\n                return;\r\n            }\r\n            callback({\r\n                message: reason || ON_CLOSE_MSG_SERVER_INIT,\r\n                requestArguments: subscription.arguments,\r\n                server: closingServer,\r\n                stream: subscription.method,\r\n            });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (subLocalKey) {\r\n        var _this = this;\r\n        var subscription = this.subscriptionsList[subLocalKey];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        subscription.trackedServers.forEach(function (server) {\r\n            if (typeof server.subscriptionId === \"undefined\") {\r\n                return;\r\n            }\r\n            _this.session.sendFireAndForget({\r\n                type: \"unsubscribe\",\r\n                subscription_id: server.subscriptionId,\r\n                reason_uri: \"\",\r\n                reason: ON_CLOSE_MSG_CLIENT_INIT,\r\n            });\r\n            delete _this.subscriptionIdToLocalKeyMap[server.subscriptionId];\r\n        });\r\n        subscription.trackedServers = [];\r\n        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);\r\n        delete this.subscriptionsList[subLocalKey];\r\n    };\r\n    return ClientStreaming;\r\n}());\r\nexports.default = ClientStreaming;\r\n//# sourceMappingURL=client-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/client-streaming.js\n// module id = 61\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar client_streaming_1 = require(\"./client-streaming\");\r\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(instance, session, repository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.callbacks = callback_registry_1.default();\r\n        session.on(\"peer-added\", function (msg) { return _this.handlePeerAdded(msg); });\r\n        session.on(\"peer-removed\", function (msg) { return _this.handlePeerRemoved(msg); });\r\n        session.on(\"methods-added\", function (msg) { return _this.handleMethodsAddedMessage(msg); });\r\n        session.on(\"methods-removed\", function (msg) { return _this.handleMethodsRemovedMessage(msg); });\r\n        this.streaming = new client_streaming_1.default(instance, session, repository, logger);\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, args, targetServers, options, success, error) {\r\n        this.streaming.subscribe(stream, args, targetServers, options, success, error);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target) {\r\n        var _this = this;\r\n        var serverId = target.id;\r\n        var methodId = method.protocolState.id;\r\n        var msg = {\r\n            type: \"call\",\r\n            server_id: serverId,\r\n            method_id: methodId,\r\n            arguments_kv: args,\r\n        };\r\n        this.session.send(msg, { invocationId: id, serverId: serverId })\r\n            .then(function (m) { return _this.handleResultMessage(m); })\r\n            .catch(function (err) { return _this.handleInvocationError(err); });\r\n    };\r\n    ClientProtocol.prototype.onInvocationResult = function (callback) {\r\n        this.callbacks.add(\"onResult\", callback);\r\n    };\r\n    ClientProtocol.prototype.handlePeerAdded = function (msg) {\r\n        var newPeerId = msg.new_peer_id;\r\n        var remoteId = msg.identity;\r\n        var pid = Number(remoteId.process);\r\n        var serverInfo = {\r\n            machine: remoteId.machine,\r\n            pid: isNaN(pid) ? remoteId.process : pid,\r\n            instance: remoteId.instance,\r\n            application: remoteId.application,\r\n            environment: remoteId.environment,\r\n            region: remoteId.region,\r\n            user: remoteId.user,\r\n            windowId: remoteId.windowId,\r\n            peerId: newPeerId,\r\n        };\r\n        this.repository.addServer(serverInfo, newPeerId);\r\n    };\r\n    ClientProtocol.prototype.handlePeerRemoved = function (msg) {\r\n        var removedPeerId = msg.removed_id;\r\n        var reason = msg.reason;\r\n        this.repository.removeServerById(removedPeerId, reason);\r\n    };\r\n    ClientProtocol.prototype.handleMethodsAddedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methods = msg.methods;\r\n        methods.forEach(function (method) {\r\n            var methodInfo = {\r\n                name: method.name,\r\n                displayName: method.display_name,\r\n                description: method.description,\r\n                version: method.version,\r\n                objectTypes: method.object_types || [],\r\n                accepts: method.input_signature,\r\n                returns: method.result_signature,\r\n                supportsStreaming: typeof method.flags !== \"undefined\" ? method.flags.streaming : false,\r\n            };\r\n            _this.repository.addServerMethod(serverId, methodInfo, { id: method.id });\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleMethodsRemovedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methodIdList = msg.methods;\r\n        var server = this.repository.getServerById(serverId);\r\n        var serverMethodKeys = Object.keys(server.methods);\r\n        serverMethodKeys.forEach(function (methodKey) {\r\n            var method = server.methods[methodKey];\r\n            if (methodIdList.indexOf(method.protocolState.id) > -1) {\r\n                _this.repository.removeServerMethod(serverId, methodKey);\r\n            }\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleResultMessage = function (msg) {\r\n        var invocationId = msg._tag.invocationId;\r\n        var result = msg.result;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        this.callbacks.execute(\"onResult\", invocationId, server.getInfoForUser(), 0, result, \"\");\r\n    };\r\n    ClientProtocol.prototype.handleInvocationError = function (msg) {\r\n        this.logger.debug(\"handle invocation error \" + JSON.stringify(msg));\r\n        var invocationId = msg._tag.invocationId;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        var message = msg.reason;\r\n        var context = msg.context;\r\n        this.callbacks.execute(\"onResult\", invocationId, server.getInfoForUser(), 1, context, message);\r\n    };\r\n    return ClientProtocol;\r\n}());\r\nexports.default = ClientProtocol;\r\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/client.js\n// module id = 62\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar server_1 = require(\"./server\");\r\nvar client_1 = require(\"./client\");\r\nfunction default_1(instance, connection, clientRepository, serverRepository, libConfig, getAGM) {\r\n    var logger = libConfig.logger.subLogger(\"gw3-protocol\");\r\n    var resolveReadyPromise;\r\n    var readyPromise = new Promise(function (resolve) {\r\n        resolveReadyPromise = resolve;\r\n    });\r\n    var session = connection.domain(\"agm\", logger.subLogger(\"domain\"), [\"subscribed\"]);\r\n    var server = new server_1.default(instance, session, clientRepository, serverRepository, logger.subLogger(\"server\"));\r\n    var client = new client_1.default(instance, session, clientRepository, logger.subLogger(\"client\"));\r\n    function handleReconnect() {\r\n        logger.info(\"reconnected - will replay registered methods and subscriptions\");\r\n        clientRepository.reset();\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        var registeredMethods = serverRepository.getList();\r\n        serverRepository.reset();\r\n        registeredMethods.forEach(function (method) {\r\n            var def = method.definition;\r\n            if (method.theFunction.userCallback) {\r\n                getAGM().register(def, method.theFunction.userCallback);\r\n            }\r\n            else if (method.theFunction.userCallbackAsync) {\r\n                getAGM().registerAsync(def, method.theFunction.userCallbackAsync);\r\n            }\r\n        });\r\n    }\r\n    function handleInitialJoin() {\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        resolveReadyPromise({\r\n            client: client,\r\n            server: server,\r\n        });\r\n        resolveReadyPromise = undefined;\r\n    }\r\n    session.onJoined(function (reconnect) {\r\n        if (reconnect) {\r\n            handleReconnect();\r\n        }\r\n        else {\r\n            handleInitialJoin();\r\n        }\r\n    });\r\n    session.join();\r\n    return readyPromise;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=factory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/factory.js\n// module id = 63\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar SUBSCRIPTION_REQUEST = \"onSubscriptionRequest\";\r\nvar SUBSCRIPTION_ADDED = \"onSubscriptionAdded\";\r\nvar SUBSCRIPTION_REMOVED = \"onSubscriptionRemoved\";\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(instance, session, repository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.instance = instance;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.ERR_URI_SUBSCRIPTION_FAILED = \"com.tick42.agm.errors.subscription.failure\";\r\n        this.callbacks = callback_registry_1.default();\r\n        this.nextStreamId = 0;\r\n        session.on(\"add-interest\", function (msg) { _this.handleAddInterest(msg); });\r\n        session.on(\"remove-interest\", function (msg) { _this.handleRemoveInterest(msg); });\r\n    }\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            throw new TypeError(\"The streaming method is missing its subscriptions.\");\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            throw new TypeError(\"The streaming method is missing its branches.\");\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var key = requestContext.msg.subscription_id;\r\n        var subscription = {\r\n            id: key,\r\n            arguments: requestContext.arguments,\r\n            instance: requestContext.instance,\r\n            branchKey: branch,\r\n            streamId: streamId,\r\n            subscribeMsg: requestContext.msg,\r\n        };\r\n        streamingMethod.protocolState.subscriptionsMap[key] = subscription;\r\n        this.session.sendFireAndForget({\r\n            type: \"accepted\",\r\n            subscription_id: key,\r\n            stream_id: streamId,\r\n        });\r\n        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        this.sendSubscriptionFailed(\"Subscription rejected by user. \" + reason, requestContext.msg.subscription_id);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = null;\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            return (branches === null || (Boolean(br) && typeof br.key === \"string\" && branches.indexOf(br.key) >= 0));\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        streamIdList.forEach(function (streamId) {\r\n            var publishMessage = {\r\n                type: \"publish\",\r\n                stream_id: streamId,\r\n                data: data,\r\n            };\r\n            _this.session.sendFireAndForget(publishMessage);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        var postMessage = {\r\n            type: \"post\",\r\n            subscription_id: subscription.id,\r\n            data: data,\r\n        };\r\n        this.session.sendFireAndForget(postMessage);\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n        var dropSubscriptionMessage = {\r\n            type: \"drop-subscription\",\r\n            subscription_id: subscription.id,\r\n            reason: \"Server dropping a single subscription\",\r\n        };\r\n        this.session.sendFireAndForget(dropSubscriptionMessage);\r\n        var subscriber = subscription.instance;\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.closeMultipleSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            return;\r\n        }\r\n        var subscriptionsToClose = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey === \"string\") {\r\n            subscriptionsToClose = subscriptionsToClose.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        subscriptionsToClose.forEach(function (subscription) {\r\n            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n            var drop = {\r\n                type: \"drop-subscription\",\r\n                subscription_id: subscription.id,\r\n                reason: \"Server dropping all subscriptions on stream_id: \" + subscription.streamId,\r\n            };\r\n            _this.session.sendFireAndForget(drop);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        var allSubscriptions = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = allSubscriptions;\r\n        }\r\n        else {\r\n            subscriptions = allSubscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var allSubscriptions = Object.keys(streamingMethod.protocolState.subscriptionsMap)\r\n            .map(function (key) {\r\n            return streamingMethod.protocolState.subscriptionsMap[key];\r\n        });\r\n        var keysWithDuplicates = allSubscriptions.map(function (sub) {\r\n            var result = null;\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                result = sub.branchKey;\r\n            }\r\n            return result;\r\n        });\r\n        var seen = [];\r\n        var branchArray = keysWithDuplicates.filter(function (bKey) {\r\n            if (bKey === null || seen.indexOf(bKey) >= 0) {\r\n                return false;\r\n            }\r\n            seen.push(bKey);\r\n            return true;\r\n        });\r\n        return branchArray;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);\r\n    };\r\n    ServerStreaming.prototype.handleRemoveInterest = function (msg) {\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (typeof msg.subscription_id !== \"string\" ||\r\n            typeof streamingMethod !== \"object\" ||\r\n            typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== \"object\") {\r\n            return;\r\n        }\r\n        var subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.onSubscriptionLifetimeEvent = function (eventName, handlerFunc) {\r\n        this.callbacks.add(eventName, handlerFunc);\r\n    };\r\n    ServerStreaming.prototype.getNextStreamId = function () {\r\n        return this.nextStreamId++ + \"\";\r\n    };\r\n    ServerStreaming.prototype.handleAddInterest = function (msg) {\r\n        var caller = this.repository.getServerById(msg.caller_id);\r\n        var instance = (typeof caller.getInfoForUser === \"function\") ? caller.getInfoForUser() : null;\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.arguments_kv || {},\r\n            instance: instance,\r\n        };\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (streamingMethod === undefined) {\r\n            var errorMsg = \"No method with id \" + msg.method_id + \" on this server.\";\r\n            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);\r\n            return;\r\n        }\r\n        if (streamingMethod.protocolState.subscriptionsMap &&\r\n            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {\r\n            this.sendSubscriptionFailed(\"A subscription with id \" + msg.subscription_id + \" already exists.\", msg.subscription_id);\r\n            return;\r\n        }\r\n        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.sendSubscriptionFailed = function (reason, subscriptionId) {\r\n        var errorMessage = {\r\n            type: \"error\",\r\n            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,\r\n            reason: reason,\r\n            request_id: subscriptionId,\r\n        };\r\n        this.session.sendFireAndForget(errorMessage);\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.getNextStreamId();\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=server-streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/server-streaming.js\n// module id = 64\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar server_streaming_1 = require(\"./server-streaming\");\r\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(instance, session, clientRepository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.callbacks = callback_registry_1.default();\r\n        this.streaming = new server_streaming_1.default(instance, session, clientRepository, serverRepository, logger);\r\n        this.session.on(\"invoke\", function (msg) { return _this.handleInvokeMessage(msg); });\r\n    }\r\n    ServerProtocol.prototype.createStream = function (repoMethod, success, error) {\r\n        var isStreaming = true;\r\n        repoMethod.protocolState.subscriptionsMap = {};\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        this.register(repoMethod, success, error, isStreaming);\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, success, error, isStreaming) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDef, flags, registerMsg;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodDef = repoMethod.definition;\r\n                        repoMethod.protocolState.registrationCallbacks = {\r\n                            success: success,\r\n                            fail: error,\r\n                        };\r\n                        flags = { streaming: isStreaming || false };\r\n                        this.logger.debug('registering method \"' + methodDef.name + '\"');\r\n                        registerMsg = {\r\n                            type: \"register\",\r\n                            methods: [{\r\n                                    id: repoMethod.repoId,\r\n                                    name: methodDef.name,\r\n                                    display_name: methodDef.displayName,\r\n                                    description: methodDef.description,\r\n                                    version: methodDef.version,\r\n                                    flags: flags,\r\n                                    object_types: methodDef.objectTypes || methodDef.object_types,\r\n                                    input_signature: methodDef.accepts,\r\n                                    result_signature: methodDef.returns,\r\n                                    restrictions: undefined,\r\n                                }],\r\n                        };\r\n                        return [4, this.session.send(registerMsg, { methodId: repoMethod.repoId })\r\n                                .then(function (msg) { return _this.handleRegisteredMessage(msg); })\r\n                                .catch(function (err) { return _this.handleErrorRegister(err); })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (method, invocationId, err, result) {\r\n        var msg;\r\n        if (err) {\r\n            msg = {\r\n                type: \"error\",\r\n                request_id: invocationId,\r\n                reason_uri: \"agm.errors.client_error\",\r\n                reason: err,\r\n                context: result,\r\n                peer_id: undefined,\r\n            };\r\n        }\r\n        else {\r\n            msg = {\r\n                type: \"yield\",\r\n                invocation_id: invocationId,\r\n                peer_id: this.session.peerId,\r\n                result: result,\r\n                request_id: undefined,\r\n            };\r\n        }\r\n        this.session.sendFireAndForget(msg);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (method) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var msg;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        msg = {\r\n                            type: \"unregister\",\r\n                            methods: [method.repoId],\r\n                        };\r\n                        return [4, this.session.send(msg)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.getBranchList = function (method) {\r\n        return this.streaming.getBranchList(method);\r\n    };\r\n    ServerProtocol.prototype.getSubscriptionList = function (method, branchKey) {\r\n        return this.streaming.getSubscriptionList(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.closeAllSubscriptions = function (method, branchKey) {\r\n        this.streaming.closeMultipleSubscriptions(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.pushData = function (method, data, branches) {\r\n        this.streaming.pushData(method, data, branches);\r\n    };\r\n    ServerProtocol.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        this.streaming.pushDataToSingle(method, subscription, data);\r\n    };\r\n    ServerProtocol.prototype.closeSingleSubscription = function (method, subscription) {\r\n        this.streaming.closeSingleSubscription(method, subscription);\r\n    };\r\n    ServerProtocol.prototype.acceptRequestOnBranch = function (requestContext, method, branch) {\r\n        this.streaming.acceptRequestOnBranch(requestContext, method, branch);\r\n    };\r\n    ServerProtocol.prototype.rejectRequest = function (requestContext, method, reason) {\r\n        this.streaming.rejectRequest(requestContext, method, reason);\r\n    };\r\n    ServerProtocol.prototype.onSubRequest = function (callback) {\r\n        this.streaming.onSubRequest(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubAdded = function (callback) {\r\n        this.streaming.onSubAdded(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubRemoved = function (callback) {\r\n        this.streaming.onSubRemoved(callback);\r\n    };\r\n    ServerProtocol.prototype.handleRegisteredMessage = function (msg) {\r\n        var methodId = msg._tag.methodId;\r\n        var repoMethod = this.serverRepository.getById(methodId);\r\n        if (repoMethod && repoMethod.protocolState.registrationCallbacks) {\r\n            this.logger.debug(\"registered method \" + repoMethod.definition.name + \" with id \" + methodId);\r\n            repoMethod.protocolState.registrationCallbacks.success();\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleErrorRegister = function (msg) {\r\n        this.logger.warn(JSON.stringify(msg));\r\n        var methodId = msg._tag.methodId;\r\n        var repoMethod = this.serverRepository.getById(methodId);\r\n        if (repoMethod && repoMethod.protocolState.registrationCallbacks) {\r\n            this.logger.debug(\"failed to register method \" + repoMethod.definition.name + \" with id \" + methodId);\r\n            repoMethod.protocolState.registrationCallbacks.fail();\r\n        }\r\n    };\r\n    ServerProtocol.prototype.handleInvokeMessage = function (msg) {\r\n        var invocationId = msg.invocation_id;\r\n        var callerId = msg.caller_id;\r\n        var methodId = msg.method_id;\r\n        var args = msg.arguments_kv;\r\n        this.logger.debug('received invocation for method id \"' + methodId + '\" from peer ' + callerId);\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.repoId === methodId;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        var client = this.clientRepository.getServerById(callerId);\r\n        var invocationArgs = { args: args, instance: client.getInfoForUser() };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    return ServerProtocol;\r\n}());\r\nexports.default = ServerProtocol;\r\n//# sourceMappingURL=server.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/protocols/gw3/server.js\n// module id = 65\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = require(\"./subscription\");\r\nvar ServerBranch = (function () {\r\n    function ServerBranch(key, protocol, repoMethod) {\r\n        this.key = key;\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n    }\r\n    ServerBranch.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);\r\n        return subList.map(function (sub) {\r\n            return new subscription_1.default(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    ServerBranch.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);\r\n    };\r\n    ServerBranch.prototype.push = function (data) {\r\n        this.protocol.server.pushData(this.repoMethod, data, [this.key]);\r\n    };\r\n    return ServerBranch;\r\n}());\r\nexports.default = ServerBranch;\r\n//# sourceMappingURL=branch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/branch.js\n// module id = 66\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerRepository = (function () {\r\n    function ServerRepository() {\r\n        this.nextId = 0;\r\n        this.methods = [];\r\n    }\r\n    ServerRepository.prototype.add = function (method) {\r\n        if (typeof method !== \"object\") {\r\n            return;\r\n        }\r\n        if (method.repoId !== undefined) {\r\n            return;\r\n        }\r\n        method.repoId = String(this.nextId);\r\n        this.nextId += 1;\r\n        this.methods.push(method);\r\n        return method;\r\n    };\r\n    ServerRepository.prototype.remove = function (repoId) {\r\n        if (typeof repoId !== \"string\") {\r\n            return new TypeError(\"Expecting a string\");\r\n        }\r\n        this.methods = this.methods.filter(function (m) {\r\n            return m.repoId !== repoId;\r\n        });\r\n    };\r\n    ServerRepository.prototype.getById = function (id) {\r\n        if (typeof id !== \"string\") {\r\n            return undefined;\r\n        }\r\n        return this.methods.filter(function (m) {\r\n            return m.repoId === id;\r\n        })[0];\r\n    };\r\n    ServerRepository.prototype.getList = function () {\r\n        return this.methods.map(function (m) { return m; });\r\n    };\r\n    ServerRepository.prototype.length = function () {\r\n        return this.methods.length;\r\n    };\r\n    ServerRepository.prototype.reset = function () {\r\n        this.methods = [];\r\n    };\r\n    return ServerRepository;\r\n}());\r\nexports.default = ServerRepository;\r\n//# sourceMappingURL=repository.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/repository.js\n// module id = 67\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Request = (function () {\r\n    function Request(protocol, repoMethod, requestContext) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.requestContext = requestContext;\r\n        this.arguments = requestContext.arguments;\r\n        this.instance = requestContext.instance;\r\n    }\r\n    Request.prototype.accept = function () {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, \"\");\r\n    };\r\n    Request.prototype.acceptOnBranch = function (branch) {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);\r\n    };\r\n    Request.prototype.reject = function (reason) {\r\n        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);\r\n    };\r\n    return Request;\r\n}());\r\nexports.default = Request;\r\n//# sourceMappingURL=request.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/request.js\n// module id = 68\n// module chunks = 0","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar promisify_1 = require(\"../helpers/promisify\");\r\nvar streaming_1 = require(\"./streaming\");\r\nvar stream_1 = require(\"./stream\");\r\nvar Server = (function () {\r\n    function Server(protocol, serverRepository, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.serverRepository = serverRepository;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n        this.invocations = 0;\r\n        this.streaming = new streaming_1.default(protocol, this);\r\n        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));\r\n    }\r\n    Server.prototype.register = function (methodDefinition, callback) {\r\n        if (methodDefinition === undefined) {\r\n            return Promise.reject(\"Please supply either a string of the Unique name or an object with property name\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be the callback function\");\r\n        }\r\n        var wrappedCallbackFunction = function (context, resultCallback) {\r\n            try {\r\n                var result = callback(context.args, context.instance);\r\n                resultCallback(null, result);\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, e);\r\n            }\r\n        };\r\n        wrappedCallbackFunction.userCallback = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallbackFunction);\r\n    };\r\n    Server.prototype.registerAsync = function (methodDefinition, callback) {\r\n        if (methodDefinition === undefined) {\r\n            return Promise.reject(\"Please supply either a string of the Unique name or an object with property name\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be the callback function\");\r\n        }\r\n        var wrappedCallback = function (context, resultCallback) {\r\n            try {\r\n                callback(context.args, context.instance, function (result) {\r\n                    resultCallback(null, result);\r\n                }, function (e) {\r\n                    resultCallback(e, e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, null);\r\n            }\r\n        };\r\n        wrappedCallback.userCallbackAsync = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallback);\r\n    };\r\n    Server.prototype.registerCore = function (method, theFunction) {\r\n        var _this = this;\r\n        var methodDefinition;\r\n        if (typeof method === \"string\") {\r\n            methodDefinition = { name: \"\" + method };\r\n        }\r\n        else {\r\n            methodDefinition = __assign({}, method);\r\n        }\r\n        var nameAlreadyExists = this.serverRepository.getList()\r\n            .some(function (serverMethod) { return serverMethod.definition.name === methodDefinition.name; });\r\n        if (nameAlreadyExists) {\r\n            return Promise.reject(\"Name already exists !\");\r\n        }\r\n        if (methodDefinition.supportsStreaming) {\r\n            return Promise.reject(\"supportsStreaming can not be true ! If you want to create a stream please use glue.agm.createStream\");\r\n        }\r\n        var repoMethod = this.serverRepository.add({\r\n            definition: methodDefinition,\r\n            theFunction: theFunction,\r\n            protocolState: {},\r\n        });\r\n        return this.protocol.server.register(repoMethod, function () {\r\n        }, function () {\r\n            _this.serverRepository.remove(repoMethod.repoId);\r\n        });\r\n    };\r\n    Server.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (typeof streamDef === \"string\") {\r\n                if (streamDef === \"\") {\r\n                    reject(\"Invalid stream name - can not be empty\");\r\n                }\r\n                streamDef = { name: streamDef };\r\n            }\r\n            streamDef.supportsStreaming = true;\r\n            if (!callbacks) {\r\n                callbacks = {};\r\n            }\r\n            if (typeof callbacks.subscriptionRequestHandler !== \"function\") {\r\n                callbacks.subscriptionRequestHandler = function (request) {\r\n                    request.accept();\r\n                };\r\n            }\r\n            var repoMethod = {\r\n                definition: streamDef,\r\n                streamCallbacks: callbacks,\r\n                protocolState: {},\r\n            };\r\n            _this.serverRepository.add(repoMethod);\r\n            _this.protocol.server.createStream(repoMethod, function () {\r\n                var streamFrontObject = new stream_1.default(_this.protocol, repoMethod, _this);\r\n                repoMethod.stream = streamFrontObject;\r\n                resolve(streamFrontObject);\r\n            }, function (err) {\r\n                _this.serverRepository.remove(repoMethod.repoId);\r\n                reject(err);\r\n            });\r\n        });\r\n        return promisify_1.default(promise, successCallback, errorCallback);\r\n    };\r\n    Server.prototype.unregister = function (methodFilter, forStream) {\r\n        if (forStream === void 0) { forStream = false; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDefinition, methodToBeRemoved;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (methodFilter === undefined) {\r\n                            return [2, Promise.reject(\"Please supply either a string of the Unique name or an object with property name\")];\r\n                        }\r\n                        if (!(typeof methodFilter === \"function\")) return [3, 2];\r\n                        return [4, this.unregisterWithPredicate(methodFilter, forStream)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                    case 2:\r\n                        if (typeof methodFilter === \"string\") {\r\n                            methodDefinition = { name: methodFilter };\r\n                        }\r\n                        else {\r\n                            methodDefinition = methodFilter;\r\n                        }\r\n                        if (methodDefinition.name === undefined) {\r\n                            return [2, Promise.reject(\"Method with undefined name does not exist !\")];\r\n                        }\r\n                        methodToBeRemoved = this.serverRepository.getList().find(function (serverMethod) {\r\n                            return serverMethod.definition.name === methodDefinition.name\r\n                                && (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodToBeRemoved) {\r\n                            return [2, Promise.reject(\"Method does not exist or it is not registered by your application !\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams([methodToBeRemoved])];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.unregisterWithPredicate = function (filterPredicate, forStream) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodsOrStreamsToRemove;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodsOrStreamsToRemove = this.serverRepository.getList()\r\n                            .filter(function (sm) { return filterPredicate(sm.definition); })\r\n                            .filter(function (serverMethod) {\r\n                            return (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {\r\n                            return [2, Promise.reject(\"No \" + (forStream ? \"stream\" : \"method\") + \" matches the condition !\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams(methodsOrStreamsToRemove)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.removeMethodsOrStreams = function (methodsToRemove) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, Promise.all(methodsToRemove.map(function (method) { return __awaiter(_this, void 0, void 0, function () {\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0: return [4, this.protocol.server.unregister(method)];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        this.serverRepository.remove(method.repoId);\r\n                                        return [2];\r\n                                }\r\n                            });\r\n                        }); }))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.containsProps = function (filter, methodDefinition) {\r\n        var filterProps = Object.keys(filter)\r\n            .filter(function (prop) {\r\n            return typeof filter[prop] !== \"function\"\r\n                && prop !== \"object_types\"\r\n                && prop !== \"display_name\";\r\n        });\r\n        var methodDefProps = Object.keys(methodDefinition);\r\n        var uniqProps = Array.from(new Set(filterProps.concat(methodDefProps)));\r\n        return uniqProps.reduce(function (isMatch, prop) {\r\n            var filterValue = filter[prop];\r\n            var methodDefValue = methodDefinition[prop];\r\n            if (prop === \"supportsStreaming\") {\r\n                methodDefValue = methodDefValue || false;\r\n                filterValue = filterValue || false;\r\n            }\r\n            if (prop === \"objectTypes\" && filterValue !== undefined && methodDefValue !== undefined) {\r\n                if (filterValue.length !== methodDefValue.length) {\r\n                    isMatch = false;\r\n                }\r\n                else {\r\n                    var firstObjType = filterValue.sort();\r\n                    var secondObjTypes_1 = methodDefValue.sort();\r\n                    var hasADifference = firstObjType.some(function (objType, index) { return objType !== secondObjTypes_1[index]; });\r\n                    if (hasADifference) {\r\n                        isMatch = false;\r\n                    }\r\n                }\r\n            }\r\n            else if (filterValue !== methodDefValue) {\r\n                isMatch = false;\r\n            }\r\n            return isMatch;\r\n        }, true);\r\n    };\r\n    Server.prototype.onMethodInvoked = function (methodToExecute, invocationId, invocationArgs) {\r\n        var _this = this;\r\n        if (!methodToExecute) {\r\n            return;\r\n        }\r\n        methodToExecute.theFunction(invocationArgs, function (err, result) {\r\n            if (err) {\r\n                if (typeof err.message === \"string\") {\r\n                    err = err.message;\r\n                }\r\n                else if (typeof err !== \"string\") {\r\n                    try {\r\n                        err = JSON.stringify(err);\r\n                    }\r\n                    catch (unStrException) {\r\n                        err = \"un-stringifyable error in onMethodInvoked ! Top level prop names: \" + Object.keys(err);\r\n                    }\r\n                }\r\n            }\r\n            if (!result || typeof result !== \"object\" || result.constructor === Array) {\r\n                result = { _result: result };\r\n            }\r\n            _this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);\r\n        });\r\n    };\r\n    return Server;\r\n}());\r\nexports.default = Server;\r\n//# sourceMappingURL=server.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/server.js\n// module id = 69\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = require(\"./subscription\");\r\nvar branch_1 = require(\"./branch\");\r\nvar ServerStream = (function () {\r\n    function ServerStream(protocol, repoMethod, server) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.server = server;\r\n        this.def = repoMethod.definition;\r\n    }\r\n    Object.defineProperty(ServerStream.prototype, \"name\", {\r\n        get: function () { return this.def.name; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.branches = function (key) {\r\n        var _this = this;\r\n        var bList = this.protocol.server.getBranchList(this.repoMethod);\r\n        if (key) {\r\n            if (bList.indexOf(key) > -1) {\r\n                return new branch_1.default(key, this.protocol, this.repoMethod);\r\n            }\r\n            return undefined;\r\n        }\r\n        else {\r\n            return bList.map(function (branchKey) {\r\n                return new branch_1.default(branchKey, _this.protocol, _this.repoMethod);\r\n            });\r\n        }\r\n    };\r\n    ServerStream.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod);\r\n        return subList.map(function (sub) {\r\n            return new subscription_1.default(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    Object.defineProperty(ServerStream.prototype, \"definition\", {\r\n        get: function () {\r\n            var def2 = this.def;\r\n            return {\r\n                accepts: def2.accepts,\r\n                description: def2.description,\r\n                displayName: def2.displayName,\r\n                name: def2.name,\r\n                objectTypes: def2.objectTypes,\r\n                returns: def2.returns,\r\n                supportsStreaming: def2.supportsStreaming,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod);\r\n        this.server.unregister(this.repoMethod.definition, true);\r\n    };\r\n    ServerStream.prototype.push = function (data, branches) {\r\n        if (typeof branches !== \"string\" && !Array.isArray(branches) && branches !== undefined) {\r\n            throw new Error(\"invalid branches should be string or string array\");\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this.protocol.server.pushData(this.repoMethod, data, branches);\r\n    };\r\n    return ServerStream;\r\n}());\r\nexports.default = ServerStream;\r\n//# sourceMappingURL=stream.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/stream.js\n// module id = 70\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar subscription_1 = require(\"./subscription\");\r\nvar request_1 = require(\"./request\");\r\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(protocol, server) {\r\n        var _this = this;\r\n        this.protocol = protocol;\r\n        this.server = server;\r\n        protocol.server.onSubRequest(function (rc, rm) { return _this.handleSubRequest(rc, rm); });\r\n        protocol.server.onSubAdded(function (sub, rm) { return _this.handleSubAdded(sub, rm); });\r\n        protocol.server.onSubRemoved(function (sub, rm) { return _this.handleSubRemoved(sub, rm); });\r\n    }\r\n    ServerStreaming.prototype.handleSubRequest = function (requestContext, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var request = new request_1.default(this.protocol, repoMethod, requestContext);\r\n        repoMethod.streamCallbacks.subscriptionRequestHandler(request);\r\n    };\r\n    ServerStreaming.prototype.handleSubAdded = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new subscription_1.default(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);\r\n    };\r\n    ServerStreaming.prototype.handleSubRemoved = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new subscription_1.default(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);\r\n    };\r\n    return ServerStreaming;\r\n}());\r\nexports.default = ServerStreaming;\r\n//# sourceMappingURL=streaming.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/agm/server/streaming.js\n// module id = 71\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar protocol_1 = require(\"./protocol\");\r\nvar successMessages = ['subscribed', 'success'];\r\nexports.default = (function (configuration) {\r\n    var connection = configuration.connection, logger = configuration.logger;\r\n    var session = connection.domain('bus', logger, successMessages);\r\n    return new Promise(function (resolve, reject) {\r\n        session.join()\r\n            .then(function () {\r\n            var protocol = protocol_1.default(connection, logger, session);\r\n            resolve(protocol);\r\n        })\r\n            .catch(reject);\r\n    });\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/bus/main.js\n// module id = 72\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = require(\"./utils\");\r\n;\r\nvar Protocol = (function () {\r\n    function Protocol(connection, logger, session) {\r\n        var _this = this;\r\n        this.publish = function (topic, data, options) {\r\n            var _a = options || {}, _b = _a.routingKey, routingKey = _b === void 0 ? undefined : _b, _c = _a.target, target = _c === void 0 ? undefined : _c;\r\n            var args = utils_1.removeEmptyValues({\r\n                type: 'publish',\r\n                topic: topic,\r\n                data: data,\r\n                peer_id: _this.peerId,\r\n                routing_key: routingKey,\r\n                target_identity: target\r\n            });\r\n            _this.session.send(args);\r\n        };\r\n        this.subscribe = function (topic, callback, options) {\r\n            return new Promise(function (resolve, reject) {\r\n                var _a = options || {}, _b = _a.routingKey, routingKey = _b === void 0 ? undefined : _b, _c = _a.target, target = _c === void 0 ? undefined : _c;\r\n                var args = utils_1.removeEmptyValues({\r\n                    type: 'subscribe',\r\n                    topic: topic,\r\n                    peer_id: _this.peerId,\r\n                    routing_key: routingKey,\r\n                    source: target\r\n                });\r\n                _this.session.send(args)\r\n                    .then(function (response) {\r\n                    var subscription_id = response.subscription_id;\r\n                    _this.subscriptions.push({ subscription_id: subscription_id, topic: topic, callback: callback, source: target });\r\n                    resolve({\r\n                        unsubscribe: function () {\r\n                            _this.session.send({ type: 'unsubscribe', subscription_id: subscription_id, peer_id: _this.peerId });\r\n                            _this.subscriptions = _this.subscriptions.filter(function (s) { return s.subscription_id !== subscription_id; });\r\n                            return Promise.resolve();\r\n                        }\r\n                    });\r\n                })\r\n                    .catch(function (error) { return reject(error); });\r\n            });\r\n        };\r\n        this.watchOnEvent = function () {\r\n            _this.session.on('event', function (args) {\r\n                var data = args.data, subscription_id = args.subscription_id;\r\n                var source = args['publisher-identity'];\r\n                var subscription = _this.subscriptions.find(function (s) { return s.subscription_id === subscription_id; });\r\n                if (subscription) {\r\n                    if (!subscription.source) {\r\n                        subscription.callback(data, subscription.topic, source);\r\n                    }\r\n                    else {\r\n                        if (utils_1.keysMatch(subscription.source, source)) {\r\n                            subscription.callback(data, subscription.topic, source);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        this.connection = connection;\r\n        this.logger = logger;\r\n        this.session = session;\r\n        this.peerId = connection.peerId;\r\n        this.subscriptions = [];\r\n    }\r\n    return Protocol;\r\n}());\r\nfunction default_1(connection, logger, session) {\r\n    var protocol = new Protocol(connection, logger, session);\r\n    protocol.watchOnEvent();\r\n    return protocol;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=protocol.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/bus/protocol.js\n// module id = 73\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction removeEmptyValues(obj) {\r\n    var cleaned = {};\r\n    Object.keys(obj).forEach(function (key) {\r\n        if (obj[key] !== undefined && obj[key] !== null) {\r\n            cleaned[key] = obj[key];\r\n        }\r\n    });\r\n    return cleaned;\r\n}\r\nexports.removeEmptyValues = removeEmptyValues;\r\nfunction keysMatch(obj1, obj2) {\r\n    var keysObj1 = Object.keys(obj1);\r\n    var allMatch = true;\r\n    keysObj1.forEach(function (key) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            allMatch = false;\r\n        }\r\n    });\r\n    return allMatch;\r\n}\r\nexports.keysMatch = keysMatch;\r\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/bus/utils.js\n// module id = 74\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar shortid_1 = require(\"shortid\");\r\nvar utils_1 = require(\"./utils\");\r\nvar contextMessageReplaySpec_1 = require(\"./contexts/contextMessageReplaySpec\");\r\nvar pjson = require(\"../package.json\");\r\nfunction default_1(configuration, ext, hc, glue42gd, gdVersion) {\r\n    if (typeof window !== \"undefined\") {\r\n        global = global || window;\r\n    }\r\n    global = global || {};\r\n    var uid = shortid_1.generate();\r\n    var masterConfig = global.GLUE_CONFIG || {};\r\n    var dynamicDefaults = global.GLUE_DEFAULT_CONFIG || {};\r\n    var hardDefaults = getHardDefaults();\r\n    var metricsIdentity = {\r\n        system: getConfigProp(\"metrics\", \"system\"),\r\n        service: getConfigProp(\"metrics\", \"service\"),\r\n        instance: getConfigProp(\"metrics\", \"instance\")\r\n    };\r\n    function getMetrics() {\r\n        return ifNotFalse(getConfigProp(\"metrics\"), {\r\n            identity: metricsIdentity\r\n        });\r\n    }\r\n    function getGateway() {\r\n        var force = getConfigProp(\"gateway\", \"force\");\r\n        var gw = hc === undefined || force;\r\n        if (gw) {\r\n            var gwConfig = getConfigProp(\"gateway\");\r\n            var protocolVersion = getConfigProp(\"gateway\", \"protocolVersion\");\r\n            var reconnectInterval = getConfigProp(\"gateway\", \"reconnectInterval\");\r\n            var reconnectAttempts = getConfigProp(\"gateway\", \"reconnectAttempts\");\r\n            var ws = gwConfig.ws;\r\n            var http = gwConfig.http;\r\n            var inproc = gwConfig.inproc;\r\n            if (!ws && !http && !inproc) {\r\n                if (utils_1.default.isNode() || (\"WebSocket\" in window && window.WebSocket.CLOSING === 2)) {\r\n                    ws = getConfigProp(\"gateway\", \"ws\");\r\n                }\r\n                else {\r\n                    http = getConfigProp(\"gateway\", \"http\");\r\n                }\r\n            }\r\n            var windowId = void 0;\r\n            var pid = void 0;\r\n            if (hc) {\r\n                windowId = hc.windowId;\r\n            }\r\n            else if (typeof glue42gd !== \"undefined\") {\r\n                windowId = glue42gd.windowId;\r\n                pid = glue42gd.pid;\r\n            }\r\n            else if (utils_1.default.isNode()) {\r\n                pid = process.pid;\r\n            }\r\n            var replaySpecs = getConfigProp(\"gateway\", \"replaySpecs\") || [];\r\n            replaySpecs.push(contextMessageReplaySpec_1.ContextMessageReplaySpec);\r\n            return {\r\n                identity: {\r\n                    application: getApplication(),\r\n                    windowId: windowId,\r\n                    process: pid,\r\n                },\r\n                reconnectInterval: reconnectInterval,\r\n                ws: ws,\r\n                http: http,\r\n                gw: inproc,\r\n                protocolVersion: protocolVersion,\r\n                reconnectAttempts: reconnectAttempts,\r\n                force: true,\r\n                replaySpecs: replaySpecs,\r\n                gdVersion: gdVersion,\r\n            };\r\n        }\r\n        return { gdVersion: gdVersion };\r\n    }\r\n    function getLogger() {\r\n        return getConfigProp(\"logger\");\r\n    }\r\n    function getAgm() {\r\n        return ifNotFalse(configuration.agm, {\r\n            instance: {\r\n                application: getApplication()\r\n            }\r\n        });\r\n    }\r\n    function getContexts(connectionConfig) {\r\n        if (connectionConfig.protocolVersion < 3) {\r\n            return false;\r\n        }\r\n        var contextConfig = getConfigProp(\"contexts\");\r\n        if (typeof contextConfig === \"boolean\" && !contextConfig) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function getChannels(contextsEnabled) {\r\n        if (!contextsEnabled) {\r\n            return false;\r\n        }\r\n        var channelsConfig = getConfigProp(\"channels\");\r\n        if (typeof channelsConfig === \"boolean\" && !channelsConfig) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function getBus(connectionConfig) {\r\n        var contextConfig = getConfigProp(\"bus\");\r\n        if (typeof contextConfig === \"boolean\" && contextConfig) {\r\n            if (connectionConfig.protocolVersion && connectionConfig.protocolVersion < 3) {\r\n                return false;\r\n            }\r\n            if (gdVersion === 2) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getApplication() {\r\n        return getConfigProp(\"application\");\r\n    }\r\n    function getAuth() {\r\n        return getConfigProp(\"auth\");\r\n    }\r\n    function getHardDefaults() {\r\n        function getMetricsDefaults() {\r\n            var documentTitle = typeof document !== \"undefined\" ? document.title : \"unknown\";\r\n            documentTitle = documentTitle || \"none\";\r\n            if (typeof hc === \"undefined\") {\r\n                return {\r\n                    system: \"Connect.Browser\",\r\n                    service: configuration.application || documentTitle,\r\n                    instance: \"~\" + uid\r\n                };\r\n            }\r\n            if (typeof hc.metricsFacade.getIdentity !== \"undefined\") {\r\n                var identity = hc.metricsFacade.getIdentity();\r\n                return {\r\n                    system: identity.system,\r\n                    service: identity.service,\r\n                    instance: identity.instance\r\n                };\r\n            }\r\n            return {\r\n                system: \"HtmlContainer.\" + hc.containerName,\r\n                service: \"JS.\" + hc.browserWindowName,\r\n                instance: \"~\" + hc.machineName\r\n            };\r\n        }\r\n        function getGatewayDefaults() {\r\n            var defaultProtocol = 3;\r\n            var gatewayURL = \"localhost:8385\";\r\n            var defaultWs = \"ws://\" + gatewayURL;\r\n            var defaultHttp = \"http://\" + gatewayURL;\r\n            if (glue42gd) {\r\n                defaultProtocol = 3;\r\n                defaultWs = glue42gd.gwURL;\r\n            }\r\n            return {\r\n                ws: defaultWs,\r\n                http: defaultHttp,\r\n                protocolVersion: defaultProtocol,\r\n                reconnectInterval: 1000\r\n            };\r\n        }\r\n        function getDefaultApplicationName() {\r\n            if (hc) {\r\n                return hc.containerName + \".\" + hc.browserWindowName;\r\n            }\r\n            if (glue42gd) {\r\n                return glue42gd.appName;\r\n            }\r\n            if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n                return (window.agm_application || document.title) + uid;\r\n            }\r\n            else {\r\n                return \"NodeJS\" + uid;\r\n            }\r\n        }\r\n        function getDefaultLogger() {\r\n            return {\r\n                publish: \"off\",\r\n                console: \"info\",\r\n                metrics: \"off\",\r\n            };\r\n        }\r\n        return {\r\n            application: getDefaultApplicationName(),\r\n            metrics: getMetricsDefaults(),\r\n            agm: {},\r\n            gateway: getGatewayDefaults(),\r\n            logger: getDefaultLogger(),\r\n            bus: false\r\n        };\r\n    }\r\n    function getConfigProp(prop1, prop2) {\r\n        var masterConfigProp1 = masterConfig[prop1];\r\n        var userProp1 = configuration[prop1];\r\n        var dynamicDefaultsProp1 = dynamicDefaults[prop1];\r\n        var hardDefaultsProp1 = hardDefaults[prop1];\r\n        if (prop2) {\r\n            if (masterConfigProp1 && masterConfigProp1[prop2] !== undefined) {\r\n                return masterConfigProp1[prop2];\r\n            }\r\n            if (userProp1 && userProp1[prop2] !== undefined) {\r\n                return userProp1[prop2];\r\n            }\r\n            if (dynamicDefaultsProp1 && dynamicDefaultsProp1[prop2] !== undefined) {\r\n                return dynamicDefaultsProp1[prop2];\r\n            }\r\n            if (hardDefaultsProp1 && hardDefaultsProp1[prop2] !== undefined) {\r\n                return hardDefaultsProp1[prop2];\r\n            }\r\n        }\r\n        else {\r\n            if (masterConfigProp1 !== undefined) {\r\n                return masterConfigProp1;\r\n            }\r\n            if (userProp1 !== undefined) {\r\n                return userProp1;\r\n            }\r\n            if (dynamicDefaultsProp1 !== undefined) {\r\n                return dynamicDefaultsProp1;\r\n            }\r\n            if (hardDefaultsProp1 !== undefined) {\r\n                return hardDefaultsProp1;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    function ifNotFalse(what, then) {\r\n        if (typeof what === \"boolean\" && !what) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return then;\r\n        }\r\n    }\r\n    var connection = getGateway();\r\n    var contexts = getContexts(connection);\r\n    var channels = getChannels(contexts);\r\n    var bus = getBus(connection);\r\n    return {\r\n        bus: bus,\r\n        identity: metricsIdentity,\r\n        application: getApplication(),\r\n        auth: getAuth(),\r\n        logger: getLogger(),\r\n        connection: connection,\r\n        metrics: getMetrics(),\r\n        agm: getAgm(),\r\n        contexts: contexts,\r\n        channels: channels,\r\n        version: ext.version || pjson.version,\r\n        libs: ext.libs\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=config.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/config.js\n// module id = 75\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection_1 = require(\"./connection\");\r\nvar messageReplayer_1 = require(\"./messageReplayer\");\r\nvar GW3ConnectionImpl = (function (_super) {\r\n    __extends(GW3ConnectionImpl, _super);\r\n    function GW3ConnectionImpl(settings) {\r\n        var _this = _super.call(this, settings) || this;\r\n        if (settings.replaySpecs &&\r\n            settings.replaySpecs.length) {\r\n            _this.replayer = new messageReplayer_1.MessageReplayerImpl(settings.replaySpecs);\r\n        }\r\n        return _this;\r\n    }\r\n    GW3ConnectionImpl.prototype.init = function (transport, protocol) {\r\n        _super.prototype.init.call(this, transport, protocol);\r\n        if (this.replayer) {\r\n            this.replayer.init(this);\r\n        }\r\n        this.gw3Protocol = protocol;\r\n    };\r\n    GW3ConnectionImpl.prototype.toAPI = function () {\r\n        var that = this;\r\n        var superAPI = _super.prototype.toAPI.call(this);\r\n        return {\r\n            domain: that.domain.bind(that),\r\n            get peerId() { return that.peerId; },\r\n            get token() { return that.token; },\r\n            get info() { return that.info; },\r\n            get resolvedIdentity() { return that.resolvedIdentity; },\r\n            get availableDomains() { return that.availableDomains; },\r\n            get gatewayToken() { return that.gatewayToken; },\r\n            get replayer() { return that.replayer; },\r\n            on: superAPI.on,\r\n            send: superAPI.send,\r\n            off: superAPI.off,\r\n            login: superAPI.login,\r\n            logout: superAPI.logout,\r\n            loggedIn: superAPI.loggedIn,\r\n            connected: superAPI.connected,\r\n            disconnected: superAPI.disconnected,\r\n            authToken: that.authToken.bind(that),\r\n            get protocolVersion() { return superAPI.protocolVersion; },\r\n        };\r\n    };\r\n    GW3ConnectionImpl.prototype.domain = function (domain, logger, successMessages, errorMessages) {\r\n        return this.gw3Protocol.domain(domain, logger, successMessages, errorMessages);\r\n    };\r\n    GW3ConnectionImpl.prototype.authToken = function () {\r\n        return this.gw3Protocol.authToken();\r\n    };\r\n    return GW3ConnectionImpl;\r\n}(connection_1.default));\r\nexports.default = GW3ConnectionImpl;\r\n//# sourceMappingURL=gw3Connection.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/gw3Connection.js\n// module id = 76\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar connection_1 = require(\"./connection\");\r\nvar gw3_1 = require(\"./protocols/gw3\");\r\nvar hc_1 = require(\"./protocols/hc\");\r\nvar ws_1 = require(\"./transports/ws\");\r\nvar gw3Connection_1 = require(\"./gw3Connection\");\r\nvar gw1_1 = require(\"./protocols/gw1\");\r\nvar hc_2 = require(\"./transports/hc\");\r\nvar inproc_1 = require(\"./transports/inproc\");\r\nexports.default = (function (settings) {\r\n    settings = settings || {};\r\n    settings.reconnectAttempts = settings.reconnectAttempts || 10;\r\n    settings.reconnectInterval = settings.reconnectInterval || 500;\r\n    var connection = new connection_1.default(settings);\r\n    var logger = settings.logger;\r\n    if (!logger) {\r\n        throw new Error(\"please pass a logger object\");\r\n    }\r\n    var protocol = new hc_1.default();\r\n    var transport = new hc_2.default();\r\n    var outsideHC = settings.gdVersion !== 2 || settings.force;\r\n    if (outsideHC) {\r\n        if (settings.gw && settings.gw.facade && settings.gw.token && settings.protocolVersion === 3) {\r\n            transport = new inproc_1.default(settings.gw.token, settings.gw.facade, logger.subLogger(\"inproc\"));\r\n        }\r\n        else if (settings.ws !== undefined) {\r\n            transport = new ws_1.default(settings, logger.subLogger(\"ws\"));\r\n        }\r\n        else {\r\n            throw new Error(\"No connection information specified\");\r\n        }\r\n        if (settings.protocolVersion === 3) {\r\n            var gw3Connection = new gw3Connection_1.default(settings);\r\n            var gw3Port = gw3_1.default(gw3Connection, settings, logger.subLogger(\"gw3\"));\r\n            gw3Connection.init(transport, gw3Port);\r\n            return gw3Connection.toAPI();\r\n        }\r\n        else {\r\n            protocol = new gw1_1.default(connection, settings);\r\n        }\r\n    }\r\n    connection.init(transport, protocol);\r\n    return connection.toAPI();\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/main.js\n// module id = 77\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar MessageReplayerImpl = (function () {\r\n    function MessageReplayerImpl(specs) {\r\n        this.specsNames = [];\r\n        this.messages = {};\r\n        this.subs = {};\r\n        this.subsRefCount = {};\r\n        this.specs = {};\r\n        for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\r\n            var spec = specs_1[_i];\r\n            this.specs[spec.name] = spec;\r\n            this.specsNames.push(spec.name);\r\n        }\r\n    }\r\n    MessageReplayerImpl.prototype.init = function (connection) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var _loop_1 = function (type) {\r\n                var refCount = this_1.subsRefCount[type];\r\n                if (!refCount) {\r\n                    refCount = 0;\r\n                }\r\n                refCount += 1;\r\n                this_1.subsRefCount[type] = refCount;\r\n                if (refCount > 1) {\r\n                    return \"continue\";\r\n                }\r\n                var sub = connection.on(\"glue-core\", type, function (msg) { return _this.processMessage(type, msg); });\r\n                this_1.subs[type] = sub;\r\n            };\r\n            var this_1 = this;\r\n            for (var _b = 0, _c = this.specs[name_1].types; _b < _c.length; _b++) {\r\n                var type = _c[_b];\r\n                _loop_1(type);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.processMessage = function (type, msg) {\r\n        if (this.isDone || !msg) {\r\n            return;\r\n        }\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_2 = _a[_i];\r\n            if (this.specs[name_2].types.indexOf(type) !== -1) {\r\n                var messages = this.messages[name_2] || [];\r\n                this.messages[name_2] = messages;\r\n                messages.push(msg);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.drain = function (name, callback) {\r\n        if (callback) {\r\n            (this.messages[name] || []).forEach(callback);\r\n        }\r\n        delete this.messages[name];\r\n        for (var _i = 0, _a = this.specs[name].types; _i < _a.length; _i++) {\r\n            var type = _a[_i];\r\n            this.subsRefCount[type] -= 1;\r\n            if (this.subsRefCount[type] <= 0) {\r\n                this.connection.off(this.subs[type]);\r\n                delete this.subs[type];\r\n                delete this.subsRefCount[type];\r\n            }\r\n        }\r\n        delete this.specs[name];\r\n        if (!this.specs.length) {\r\n            this.isDone = true;\r\n        }\r\n    };\r\n    return MessageReplayerImpl;\r\n}());\r\nexports.MessageReplayerImpl = MessageReplayerImpl;\r\n//# sourceMappingURL=messageReplayer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/messageReplayer.js\n// module id = 78\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GW1Protocol = (function () {\r\n    function GW1Protocol(connection, settings) {\r\n        this._connection = connection;\r\n        this._settings = settings;\r\n    }\r\n    GW1Protocol.prototype.processStringMessage = function (message) {\r\n        var messageObj = JSON.parse(message);\r\n        return {\r\n            msg: messageObj.message,\r\n            msgType: messageObj.type,\r\n        };\r\n    };\r\n    GW1Protocol.prototype.createStringMessage = function (product, type, message, id) {\r\n        return JSON.stringify({\r\n            type: type,\r\n            message: message,\r\n            id: id,\r\n        });\r\n    };\r\n    GW1Protocol.prototype.login = function (message) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var sendOptions = {\r\n                retryInterval: _this._settings.reconnectInterval,\r\n                maxRetries: _this._settings.reconnectAttempts\r\n            };\r\n            _this._connection.send(\"hello\", \"hello\", {}, null, sendOptions)\r\n                .then(function () { return resolve({ application: undefined }); })\r\n                .catch(reject);\r\n        });\r\n    };\r\n    GW1Protocol.prototype.logout = function () {\r\n    };\r\n    GW1Protocol.prototype.loggedIn = function (callback) {\r\n        callback();\r\n        return function () {\r\n        };\r\n    };\r\n    GW1Protocol.prototype.processObjectMessage = function (message) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    GW1Protocol.prototype.createObjectMessage = function (product, type, message, id) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    return GW1Protocol;\r\n}());\r\nexports.default = GW1Protocol;\r\n//# sourceMappingURL=gw1.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/gw1.js\n// module id = 79\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3Domain_1 = require(\"./gw3Domain\");\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nfunction default_1(connection, settings, logger) {\r\n    var datePrefix = \"#T42_DATE#\";\r\n    var datePrefixLen = datePrefix.length;\r\n    var dateMinLen = datePrefixLen + 1;\r\n    var datePrefixFirstChar = datePrefix[0];\r\n    var registry = callback_registry_1.default();\r\n    var globalDomain;\r\n    var isLoggedIn = false;\r\n    var shouldTryLogin = true;\r\n    var initialLogin = true;\r\n    var initialLoginAttempts = 3;\r\n    var initialLoginAttemptsInterval = 500;\r\n    var pingTimer;\r\n    var sessions = [];\r\n    var loginConfig;\r\n    connection.disconnected(handleDisconnected.bind(this));\r\n    ping();\r\n    function processStringMessage(message) {\r\n        var msg = JSON.parse(message, function (key, value) {\r\n            if (typeof value !== \"string\") {\r\n                return value;\r\n            }\r\n            if (value.length < dateMinLen) {\r\n                return value;\r\n            }\r\n            if (value[0] !== datePrefixFirstChar) {\r\n                return value;\r\n            }\r\n            if (value.substring(0, datePrefixLen) !== datePrefix) {\r\n                return value;\r\n            }\r\n            try {\r\n                var milliseconds = parseInt(value.substring(datePrefixLen, value.length), 10);\r\n                if (isNaN(milliseconds)) {\r\n                    return value;\r\n                }\r\n                return new Date(milliseconds);\r\n            }\r\n            catch (ex) {\r\n                return value;\r\n            }\r\n        });\r\n        return {\r\n            msg: msg,\r\n            msgType: msg.type,\r\n        };\r\n    }\r\n    function createStringMessage(product, type, message, id) {\r\n        var oldToJson = Date.prototype.toJSON;\r\n        try {\r\n            Date.prototype.toJSON = function () {\r\n                return datePrefix + this.getTime();\r\n            };\r\n            var result = JSON.stringify(message);\r\n            return result;\r\n        }\r\n        finally {\r\n            Date.prototype.toJSON = oldToJson;\r\n        }\r\n    }\r\n    function processObjectMessage(message) {\r\n        if (!message.type) {\r\n            throw new Error(\"Object should have type property\");\r\n        }\r\n        return {\r\n            msg: message,\r\n            msgType: message.type,\r\n        };\r\n    }\r\n    function createObjectMessage(product, type, message, id) {\r\n        return message;\r\n    }\r\n    function login(config) {\r\n        logger.debug(\"logging in...\");\r\n        loginConfig = config;\r\n        if (!loginConfig) {\r\n            loginConfig = { username: \"\", password: \"\" };\r\n        }\r\n        shouldTryLogin = true;\r\n        return new Promise(function (resolve, reject) {\r\n            var authentication = {};\r\n            connection.gatewayToken = config.gatewayToken;\r\n            if (connection.gatewayToken) {\r\n                authentication.method = \"gateway-token\";\r\n                authentication.token = connection.gatewayToken;\r\n            }\r\n            else if (config.token) {\r\n                authentication.method = \"access-token\";\r\n                authentication.token = config.token;\r\n            }\r\n            else if (config.username) {\r\n                authentication.method = \"secret\";\r\n                authentication.login = config.username;\r\n                authentication.secret = config.password;\r\n            }\r\n            else {\r\n                throw new Error(\"invalid auth message\" + JSON.stringify(config));\r\n            }\r\n            var helloMsg = {\r\n                type: \"hello\",\r\n                identity: settings.identity,\r\n                authentication: authentication,\r\n            };\r\n            globalDomain = gw3Domain_1.default(\"global\", connection, logger, [\r\n                \"welcome\",\r\n                \"token\"\r\n            ]);\r\n            var sendOptions = { skipPeerId: true };\r\n            if (initialLogin) {\r\n                sendOptions.retryInterval = settings.reconnectInterval;\r\n                sendOptions.maxRetries = settings.reconnectAttempts;\r\n            }\r\n            globalDomain.send(helloMsg, undefined, sendOptions)\r\n                .then(function (msg) {\r\n                initialLogin = false;\r\n                logger.debug(\"login successful with PeerId \" + msg.peer_id);\r\n                connection.peerId = msg.peer_id;\r\n                connection.resolvedIdentity = msg.resolved_identity;\r\n                connection.availableDomains = msg.available_domains;\r\n                if (msg.options) {\r\n                    connection.token = msg.options.access_token;\r\n                    connection.info = msg.options.info;\r\n                }\r\n                setLoggedIn(true);\r\n                resolve(msg.resolved_identity);\r\n            })\r\n                .catch(function (err) {\r\n                logger.error(\"error sending hello message - \" + err);\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function logout() {\r\n        logger.debug(\"logging out...\");\r\n        shouldTryLogin = false;\r\n        if (pingTimer) {\r\n            clearTimeout(pingTimer);\r\n        }\r\n        sessions.forEach(function (session) {\r\n            session.leave();\r\n        });\r\n    }\r\n    function loggedIn(callback) {\r\n        if (isLoggedIn) {\r\n            callback();\r\n        }\r\n        return registry.add(\"onLoggedIn\", callback);\r\n    }\r\n    function domain(domainName, domainLogger, successMessages, errorMessages) {\r\n        var session = sessions.filter(function (s) { return s.domain === domainName; })[0];\r\n        if (!session) {\r\n            session = gw3Domain_1.default(domainName, connection, domainLogger, successMessages, errorMessages);\r\n            sessions.push(session);\r\n        }\r\n        return session;\r\n    }\r\n    function handleDisconnected() {\r\n        setLoggedIn(false);\r\n        var tryToLogin = shouldTryLogin;\r\n        if (tryToLogin && initialLogin) {\r\n            if (initialLoginAttempts <= 0) {\r\n                return;\r\n            }\r\n            initialLoginAttempts--;\r\n        }\r\n        logger.debug(\"disconnected - will try new login?\" + shouldTryLogin);\r\n        if (shouldTryLogin) {\r\n            connection.login(loginConfig)\r\n                .catch(function () {\r\n                setTimeout(handleDisconnected, 1000);\r\n            });\r\n        }\r\n    }\r\n    function setLoggedIn(value) {\r\n        isLoggedIn = value;\r\n        if (isLoggedIn) {\r\n            registry.execute(\"onLoggedIn\");\r\n        }\r\n    }\r\n    function ping() {\r\n        if (!shouldTryLogin) {\r\n            return;\r\n        }\r\n        if (isLoggedIn) {\r\n            connection.send(\"\", \"\", { type: \"ping\" });\r\n        }\r\n        pingTimer = setTimeout(ping, 30 * 1000);\r\n    }\r\n    function authToken() {\r\n        var createTokenReq = {\r\n            type: \"create-token\"\r\n        };\r\n        return globalDomain.send(createTokenReq)\r\n            .then(function (res) {\r\n            return res.token;\r\n        });\r\n    }\r\n    return {\r\n        processStringMessage: processStringMessage,\r\n        createStringMessage: createStringMessage,\r\n        createObjectMessage: createObjectMessage,\r\n        processObjectMessage: processObjectMessage,\r\n        login: login,\r\n        logout: logout,\r\n        loggedIn: loggedIn,\r\n        domain: domain,\r\n        authToken: authToken,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/gw3.js\n// module id = 80\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callbackRegistry = require(\"callback-registry\");\r\nvar shortid_1 = require(\"shortid\");\r\nfunction default_1(domain, connection, logger, successMessages, errorMessages) {\r\n    if (domain == null) {\r\n        domain = \"global\";\r\n    }\r\n    var isJoined = false;\r\n    var tryReconnecting = false;\r\n    var _latestOptions;\r\n    var _connectionOn = false;\r\n    var callbacks = callbackRegistry();\r\n    connection.disconnected(handleConnectionDisconnected);\r\n    connection.loggedIn(handleConnectionLoggedIn);\r\n    connection.on(domain, \"success\", function (msg) { return handleSuccessMessage(msg); });\r\n    connection.on(domain, \"error\", function (msg) { return handleErrorMessage(msg); });\r\n    connection.on(domain, \"result\", function (msg) { return handleSuccessMessage(msg); });\r\n    if (successMessages) {\r\n        successMessages.forEach(function (sm) {\r\n            connection.on(domain, sm, function (msg) { return handleSuccessMessage(msg); });\r\n        });\r\n    }\r\n    if (errorMessages) {\r\n        errorMessages.forEach(function (sm) {\r\n            connection.on(domain, sm, function (msg) { return handleErrorMessage(msg); });\r\n        });\r\n    }\r\n    var requestsMap = {};\r\n    function join(options) {\r\n        _latestOptions = options;\r\n        return new Promise(function (resolve, reject) {\r\n            if (isJoined) {\r\n                resolve();\r\n                return;\r\n            }\r\n            var joinPromise;\r\n            if (domain === \"global\") {\r\n                joinPromise = _connectionOn ? Promise.resolve({}) : Promise.reject(\"not connected to gateway\");\r\n            }\r\n            else {\r\n                logger.debug(\"joining \" + domain);\r\n                var joinMsg = {\r\n                    type: \"join\",\r\n                    destination: domain,\r\n                    domain: \"global\",\r\n                    options: options,\r\n                };\r\n                joinPromise = send(joinMsg);\r\n            }\r\n            joinPromise\r\n                .then(function () {\r\n                handleJoined();\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                logger.debug(\"error joining \" + domain + \" domain: \" + JSON.stringify(err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function leave() {\r\n        if (domain === \"global\") {\r\n            return;\r\n        }\r\n        logger.debug(\"stopping session \" + domain + \"...\");\r\n        var leaveMsg = {\r\n            type: \"leave\",\r\n            destination: domain,\r\n            domain: \"global\",\r\n        };\r\n        send(leaveMsg).then(function () {\r\n            isJoined = false;\r\n            callbacks.execute(\"onLeft\");\r\n        });\r\n    }\r\n    function handleJoined() {\r\n        logger.debug(\"did join \" + domain);\r\n        isJoined = true;\r\n        var wasReconnect = tryReconnecting;\r\n        tryReconnecting = false;\r\n        callbacks.execute(\"onJoined\", wasReconnect);\r\n    }\r\n    function handleConnectionDisconnected() {\r\n        _connectionOn = false;\r\n        logger.warn(\"connection is down\");\r\n        isJoined = false;\r\n        tryReconnecting = true;\r\n        callbacks.execute(\"onLeft\", { disconnected: true });\r\n    }\r\n    function handleConnectionLoggedIn() {\r\n        _connectionOn = true;\r\n        if (tryReconnecting) {\r\n            logger.info(\"connection is now up - trying to reconnect...\");\r\n            join(_latestOptions);\r\n        }\r\n    }\r\n    function onJoined(callback) {\r\n        if (isJoined) {\r\n            callback(false);\r\n        }\r\n        return callbacks.add(\"onJoined\", callback);\r\n    }\r\n    function onLeft(callback) {\r\n        if (!isJoined) {\r\n            callback();\r\n        }\r\n        return callbacks.add(\"onLeft\", callback);\r\n    }\r\n    function handleErrorMessage(msg) {\r\n        if (domain !== msg.domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.error(msg);\r\n    }\r\n    function handleSuccessMessage(msg) {\r\n        if (msg.domain !== domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.success(msg);\r\n    }\r\n    function getNextRequestId() {\r\n        return shortid_1.generate();\r\n    }\r\n    function send(msg, tag, options) {\r\n        options = options || {};\r\n        msg.request_id = msg.request_id || getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        if (!options.skipPeerId) {\r\n            msg.peer_id = connection.peerId;\r\n        }\r\n        var requestId = msg.request_id;\r\n        return new Promise(function (resolve, reject) {\r\n            requestsMap[requestId] = {\r\n                success: function (successMsg) {\r\n                    delete requestsMap[requestId];\r\n                    successMsg._tag = tag;\r\n                    resolve(successMsg);\r\n                },\r\n                error: function (errorMsg) {\r\n                    logger.warn(\"GW error - \" + JSON.stringify(errorMsg) + \" for request \" + JSON.stringify(msg));\r\n                    delete requestsMap[requestId];\r\n                    errorMsg._tag = tag;\r\n                    reject(errorMsg);\r\n                },\r\n            };\r\n            connection\r\n                .send(domain, domain, msg, undefined, options)\r\n                .catch(function (err) {\r\n                requestsMap[requestId].error({ err: err });\r\n            });\r\n        });\r\n    }\r\n    function sendFireAndForget(msg) {\r\n        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        msg.peer_id = connection.peerId;\r\n        connection.send(domain, domain, msg);\r\n    }\r\n    return {\r\n        join: join,\r\n        leave: leave,\r\n        onJoined: onJoined,\r\n        onLeft: onLeft,\r\n        send: send,\r\n        sendFireAndForget: sendFireAndForget,\r\n        on: function (type, callback) {\r\n            connection.on(domain, type, function (msg) {\r\n                if (msg.domain !== domain) {\r\n                    return;\r\n                }\r\n                try {\r\n                    callback(msg);\r\n                }\r\n                catch (e) {\r\n                    logger.error(\"Callback  failed: \" + e + \" \\n msg was: \" + JSON.stringify(msg));\r\n                }\r\n            });\r\n        },\r\n        loggedIn: function (callback) { return connection.loggedIn(callback); },\r\n        connected: function (callback) { return connection.connected(callback); },\r\n        disconnected: function (callback) { return connection.disconnected(callback); },\r\n        get peerId() {\r\n            return connection.peerId;\r\n        },\r\n        get domain() {\r\n            return domain;\r\n        },\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3Domain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/gw3Domain.js\n// module id = 81\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCProtocol = (function () {\r\n    function HCProtocol() {\r\n    }\r\n    HCProtocol.prototype.processStringMessage = function (message) {\r\n        var messageObj = JSON.parse(message);\r\n        return {\r\n            msg: messageObj,\r\n            msgType: messageObj.type,\r\n        };\r\n    };\r\n    HCProtocol.prototype.createStringMessage = function (product, type, message, id) {\r\n        return JSON.stringify(message);\r\n    };\r\n    HCProtocol.prototype.login = function (message) {\r\n        return Promise.resolve({ application: undefined });\r\n    };\r\n    HCProtocol.prototype.logout = function () {\r\n    };\r\n    HCProtocol.prototype.loggedIn = function (callback) {\r\n        callback();\r\n        return function () {\r\n        };\r\n    };\r\n    HCProtocol.prototype.processObjectMessage = function (message) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    HCProtocol.prototype.createObjectMessage = function (product, type, message, id) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    return HCProtocol;\r\n}());\r\nexports.default = HCProtocol;\r\n//# sourceMappingURL=hc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/protocols/hc.js\n// module id = 82\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCTransport = (function () {\r\n    function HCTransport() {\r\n        this.connectionId = Math.floor(1e10 * Math.random()).toString();\r\n    }\r\n    HCTransport.prototype.send = function (message, product, type) {\r\n        if (product === \"metrics\") {\r\n            window.htmlContainer.metricsFacade.send(type, message);\r\n        }\r\n        else if (product === \"log\") {\r\n            window.htmlContainer.loggingFacade.send(type, message);\r\n        }\r\n        return Promise.resolve(undefined);\r\n    };\r\n    HCTransport.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    HCTransport.prototype.onMessage = function (callback) {\r\n    };\r\n    HCTransport.prototype.close = function () {\r\n    };\r\n    HCTransport.prototype.open = function () {\r\n    };\r\n    return HCTransport;\r\n}());\r\nexports.default = HCTransport;\r\n//# sourceMappingURL=hc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/transports/hc.js\n// module id = 83\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar Inproc = (function () {\r\n    function Inproc(token, gw, logger) {\r\n        this.registry = callback_registry_1.default();\r\n        this.gw = gw;\r\n        this.gwToken = token;\r\n        this.logger = logger;\r\n        this.connectToken = this.gw.connect(this.gwToken, this.messageHandler.bind(this));\r\n    }\r\n    Object.defineProperty(Inproc.prototype, \"isObjectBasedTransport\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Inproc.prototype.sendObject = function (msg) {\r\n        this.logger.debug(JSON.stringify(msg));\r\n        this.gw.send(this.connectToken, msg);\r\n        return Promise.resolve(undefined);\r\n    };\r\n    Inproc.prototype.send = function (msg, product, type) {\r\n        return Promise.reject(\"not supported\");\r\n    };\r\n    Inproc.prototype.onMessage = function (callback) {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    };\r\n    Inproc.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    Inproc.prototype.close = function () {\r\n    };\r\n    Inproc.prototype.open = function () {\r\n    };\r\n    Inproc.prototype.messageHandler = function (msg) {\r\n        if (this.logger.consoleLevel() === \"trace\") {\r\n            this.logger.debug(JSON.stringify(msg));\r\n        }\r\n        this.registry.execute(\"onMessage\", msg);\r\n    };\r\n    return Inproc;\r\n}());\r\nexports.default = Inproc;\r\n//# sourceMappingURL=inproc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/transports/inproc.js\n// module id = 84\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar callback_registry_1 = require(\"callback-registry\");\r\nvar utils_1 = require(\"../../utils\");\r\nvar WebSocket = utils_1.default.isNode() ? require(\"ws\") : window.WebSocket;\r\nvar WS = (function () {\r\n    function WS(settings, logger) {\r\n        this._running = true;\r\n        this._initied = false;\r\n        this._registry = callback_registry_1.default();\r\n        this._settings = settings;\r\n        this._logger = logger;\r\n    }\r\n    WS.prototype.onMessage = function (callback) {\r\n        return this._registry.add(\"onMessage\", callback);\r\n    };\r\n    WS.prototype.send = function (msg, product, type, options) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            options = options || {};\r\n            _this.waitForSocketConnection(function () {\r\n                try {\r\n                    _this._ws.send(msg);\r\n                    resolve();\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, reject, options.maxRetries, options.retryInterval);\r\n        });\r\n    };\r\n    WS.prototype.open = function () {\r\n        this._running = true;\r\n    };\r\n    WS.prototype.close = function () {\r\n        this._running = false;\r\n        this._ws.close();\r\n    };\r\n    WS.prototype.onConnectedChanged = function (callback) {\r\n        return this._registry.add(\"onConnectedChanged\", callback);\r\n    };\r\n    WS.prototype.initiateSocket = function () {\r\n        var _this = this;\r\n        this._logger.debug(\"initiating _ws to \" + this._settings.ws + \"...\");\r\n        this._ws = new WebSocket(this._settings.ws);\r\n        this._ws.onerror = function (err) {\r\n            _this.notifyStatusChanged(false, err);\r\n        };\r\n        this._ws.onclose = function () {\r\n            _this._logger.debug(\"_ws closed\");\r\n            _this.notifyStatusChanged(false);\r\n        };\r\n        this._ws.onopen = function () {\r\n            _this._logger.debug(\"_ws opened\");\r\n            _this.notifyStatusChanged(true);\r\n        };\r\n        this._ws.onmessage = function (message) {\r\n            _this._registry.execute(\"onMessage\", message.data);\r\n        };\r\n    };\r\n    WS.prototype.waitForSocketConnection = function (callback, failed, retriesLeft, retryInterval) {\r\n        var _this = this;\r\n        if (!callback) {\r\n            callback = function () { };\r\n        }\r\n        if (!failed) {\r\n            failed = function () { };\r\n        }\r\n        if (retryInterval === undefined) {\r\n            retryInterval = this._settings.reconnectInterval;\r\n        }\r\n        if (retriesLeft !== undefined) {\r\n            if (retriesLeft === 0) {\r\n                failed(\"wait for socket on \" + this._settings.ws + \" failed - no more retries left\");\r\n                return;\r\n            }\r\n            this._logger.debug(\"will retry \" + retriesLeft + \" more times (every \" + retryInterval + \" ms)\");\r\n        }\r\n        if (!this._running) {\r\n            failed(\"wait for socket on \" + this._settings.ws + \" failed - socket closed by user\");\r\n            return;\r\n        }\r\n        if (!this._ws || this._ws.readyState > 1) {\r\n            this.initiateSocket();\r\n        }\r\n        else if (this._ws.readyState === 1) {\r\n            return callback();\r\n        }\r\n        setTimeout(function () {\r\n            var retries = retriesLeft === undefined ? undefined : retriesLeft - 1;\r\n            _this.waitForSocketConnection(callback, failed, retries, retryInterval);\r\n        }, retryInterval);\r\n    };\r\n    WS.prototype.notifyStatusChanged = function (status, reason) {\r\n        this._registry.execute(\"onConnectedChanged\", status, reason);\r\n    };\r\n    return WS;\r\n}());\r\nexports.default = WS;\r\n//# sourceMappingURL=ws.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/connection/transports/ws.js\n// module id = 85\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3ContextData_1 = require(\"./gw3ContextData\");\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar msg = require(\"./gw3Messages\");\r\nvar contextMessageReplaySpec_1 = require(\"../../contextMessageReplaySpec\");\r\nvar GW3Bridge = (function () {\r\n    function GW3Bridge(config) {\r\n        var _this = this;\r\n        this._contextNameToData = {};\r\n        this._gw3Subscriptions = [];\r\n        this._nextCallbackSubscriptionNumber = 0;\r\n        this._contextNameToId = {};\r\n        this._contextIdToName = {};\r\n        this._connection = config.connection;\r\n        this._logger = config.logger;\r\n        this._gw3Session = this._connection.domain(\"global\", this._logger, [\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n        ]);\r\n        this.subscribeToContextCreatedMessages();\r\n        this.subscribeToContextUpdatedMessages();\r\n        this.subscribeToContextDestroyedMessages();\r\n        this._connection.replayer.drain(contextMessageReplaySpec_1.ContextMessageReplaySpec.name, function (message) {\r\n            var type = message.type;\r\n            if (!type) {\r\n                return;\r\n            }\r\n            if (type === msg.GW_MESSAGE_CONTEXT_CREATED ||\r\n                type === msg.GW_MESSAGE_CONTEXT_ADDED ||\r\n                type === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n                _this.handleContextCreatedMessage(message);\r\n            }\r\n            else if (type === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT ||\r\n                type === msg.GW_MESSAGE_CONTEXT_UPDATED ||\r\n                type === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n                _this.handleContextUpdatedMessage(message);\r\n            }\r\n            else if (type === msg.GW_MESSAGE_CONTEXT_DESTROYED ||\r\n                type === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n                _this.handleContextDestroyedMessage(message);\r\n            }\r\n        });\r\n    }\r\n    GW3Bridge.prototype.dispose = function () {\r\n        for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {\r\n            var sub = _a[_i];\r\n            this._connection.off(sub);\r\n        }\r\n        this._gw3Subscriptions.length = 0;\r\n        for (var contextName in this._contextNameToData) {\r\n            if (this._contextNameToId.hasOwnProperty(contextName)) {\r\n                delete this._contextNameToData[contextName];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.createContext = function (name, data) {\r\n        var _this = this;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            domain: \"global\",\r\n            name: name,\r\n            data: data,\r\n            lifetime: \"retained\",\r\n        })\r\n            .then(function (createContextMsg) {\r\n            _this._contextNameToId[name] = createContextMsg.context_id;\r\n            if (!_this._contextIdToName[createContextMsg.context_id]) {\r\n                _this._contextIdToName[createContextMsg.context_id] = name;\r\n                var contextData = _this._contextNameToData[name] || new gw3ContextData_1.GW3ContextData(createContextMsg.context_id, name, true, null);\r\n                contextData.isAnnounced = true;\r\n                contextData.name = name;\r\n                contextData.contextId = createContextMsg.context_id;\r\n                _this._contextNameToData[name] = contextData;\r\n                contextData.context = createContextMsg.data;\r\n                contextData.sentExplicitSubscription = true;\r\n                if (contextData.context) {\r\n                    _this.invokeUpdateCallbacks(contextData, contextData.context, null);\r\n                }\r\n                return _this.update(name, data).then(function () { return createContextMsg.context_id; });\r\n            }\r\n            return createContextMsg.context_id;\r\n        });\r\n    };\r\n    GW3Bridge.prototype.all = function () {\r\n        var _this = this;\r\n        return Object.keys(this._contextNameToData)\r\n            .filter(function (name) { return _this._contextNameToData[name].isAnnounced; });\r\n    };\r\n    GW3Bridge.prototype.update = function (name, delta) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, delta);\r\n        }\r\n        var calculatedDelta = this.calculateContextDelta(contextData.context, delta);\r\n        if (!Object.keys(calculatedDelta.added).length\r\n            && !Object.keys(calculatedDelta.updated).length\r\n            && !calculatedDelta.removed.length) {\r\n            return Promise.resolve();\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: calculatedDelta,\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, calculatedDelta, {\r\n                updaterId: gwResponse.peer_id\r\n            });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.set = function (name, data) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, data);\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: { reset: data },\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n                var _this = this;\r\n                return __generator(this, function (_a) {\r\n                    this.subscribe(name, function (data, delta, removed, un) {\r\n                        _this.unsubscribe(un);\r\n                        resolve(data);\r\n                    });\r\n                    return [2];\r\n                });\r\n            }); });\r\n        }\r\n        else {\r\n            return Promise.resolve(contextData.context);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribe = function (name, callback) {\r\n        var thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;\r\n        this._nextCallbackSubscriptionNumber += 1;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData ||\r\n            !contextData.isAnnounced) {\r\n            contextData = contextData || new gw3ContextData_1.GW3ContextData(undefined, name, false, undefined);\r\n            this._contextNameToData[name] = contextData;\r\n            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n        var hadCallbacks = contextData.hasCallbacks();\r\n        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n        if (!hadCallbacks) {\r\n            if (!contextData.joinedActivity) {\r\n                if (contextData.context &&\r\n                    contextData.sentExplicitSubscription) {\r\n                    callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n                    return Promise.resolve(thisCallbackSubscriptionNumber);\r\n                }\r\n                return this.sendSubscribe(contextData)\r\n                    .then(function () { return thisCallbackSubscriptionNumber; });\r\n            }\r\n            else {\r\n                callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n                return Promise.resolve(thisCallbackSubscriptionNumber);\r\n            }\r\n        }\r\n        else {\r\n            callback(contextData.context, contextData.context, [], thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.unsubscribe = function (subscriptionKey) {\r\n        for (var _i = 0, _a = Object.keys(this._contextNameToData); _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var contextId = this._contextNameToId[name_1];\r\n            var contextData = this._contextNameToData[name_1];\r\n            if (!contextData) {\r\n                return;\r\n            }\r\n            var hadCallbacks = contextData.hasCallbacks();\r\n            delete contextData.updateCallbacks[subscriptionKey];\r\n            if (contextData.isAnnounced &&\r\n                hadCallbacks &&\r\n                !contextData.hasCallbacks() &&\r\n                contextData.sentExplicitSubscription) {\r\n                this.sendUnsubscribe(contextData);\r\n            }\r\n            if (!contextData.isAnnounced &&\r\n                !contextData.hasCallbacks()) {\r\n                delete this._contextNameToData[name_1];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleUpdated = function (contextData, delta, extraData) {\r\n        var oldContext = contextData.context;\r\n        contextData.context = helpers_1.applyContextDelta(contextData.context, delta);\r\n        if (this._contextNameToData[contextData.name] === contextData &&\r\n            !helpers_1.deepEqual(oldContext, contextData.context)) {\r\n            this.invokeUpdateCallbacks(contextData, contextData.context, delta, extraData);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextCreatedMessages = function () {\r\n        var createdMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n        ];\r\n        for (var _i = 0, createdMessageTypes_1 = createdMessageTypes; _i < createdMessageTypes_1.length; _i++) {\r\n            var createdMessageType = createdMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", createdMessageType, this.handleContextCreatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextCreatedMessage = function (contextCreatedMsg) {\r\n        var createdMessageType = contextCreatedMsg.type;\r\n        if (createdMessageType === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;\r\n        }\r\n        else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_ADDED) {\r\n            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;\r\n        }\r\n        else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_CREATED) {\r\n        }\r\n        var name = this._contextIdToName[contextCreatedMsg.context_id];\r\n        if (!name) {\r\n            throw new Error(\"Received created event for context with unknown name: \" + contextCreatedMsg.context_id);\r\n        }\r\n        if (!this._contextNameToId[name]) {\r\n            throw new Error(\"Received created event for context with unknown id: \" + contextCreatedMsg.context_id);\r\n        }\r\n        var contextData = this._contextNameToData[name];\r\n        if (contextData) {\r\n            if (contextData.isAnnounced) {\r\n                return;\r\n            }\r\n            else {\r\n                if (!contextData.hasCallbacks()) {\r\n                    throw new Error(\"Assertion failure: contextData.hasCallbacks()\");\r\n                }\r\n                contextData.isAnnounced = true;\r\n                contextData.contextId = contextCreatedMsg.context_id;\r\n                contextData.activityId = contextCreatedMsg.activity_id;\r\n                if (!contextData.sentExplicitSubscription) {\r\n                    this.sendSubscribe(contextData);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._contextNameToData[name] = contextData =\r\n                new gw3ContextData_1.GW3ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextUpdatedMessages = function () {\r\n        var updatedMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY,\r\n        ];\r\n        for (var _i = 0, updatedMessageTypes_1 = updatedMessageTypes; _i < updatedMessageTypes_1.length; _i++) {\r\n            var updatedMessageType = updatedMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", updatedMessageType, this.handleContextUpdatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextUpdatedMessage = function (contextUpdatedMsg) {\r\n        var updatedMessageType = contextUpdatedMsg.type;\r\n        var contextId = contextUpdatedMsg.context_id;\r\n        var contextData = this._contextNameToData[this._contextIdToName[contextId]];\r\n        var justSeen = !contextData || !contextData.isAnnounced;\r\n        if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            if (!contextData) {\r\n                contextData = new gw3ContextData_1.GW3ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);\r\n                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;\r\n                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;\r\n                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;\r\n            }\r\n            else {\r\n                contextData.contextId = contextId;\r\n                contextData.isAnnounced = true;\r\n                contextData.activityId = contextUpdatedMsg.activity_id;\r\n            }\r\n            contextData.joinedActivity = true;\r\n        }\r\n        else {\r\n            if (!contextData || !contextData.isAnnounced) {\r\n                if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n                    contextData = contextData || new gw3ContextData_1.GW3ContextData(contextId, contextUpdatedMsg.name, true, null);\r\n                    contextData.sentExplicitSubscription = true;\r\n                    this._contextNameToData[contextUpdatedMsg.name] = contextData;\r\n                    this._contextIdToName[contextId] = contextUpdatedMsg.name;\r\n                    this._contextNameToId[contextUpdatedMsg.name] = contextId;\r\n                }\r\n                else {\r\n                    this._logger.error(\"Received 'update' for unknown context: \" + contextId);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        var oldContext = contextData.context;\r\n        if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            contextData.context = contextUpdatedMsg.data || {};\r\n        }\r\n        else if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            contextData.context = contextUpdatedMsg.context_snapshot || {};\r\n        }\r\n        else if (updatedMessageType === msg.GW_MESSAGE_CONTEXT_UPDATED) {\r\n            contextData.context = helpers_1.applyContextDelta(contextData.context, contextUpdatedMsg.delta);\r\n        }\r\n        else {\r\n            throw new Error(\"Unrecognized context update message \" + updatedMessageType);\r\n        }\r\n        if (justSeen ||\r\n            !helpers_1.deepEqual(contextData.context, oldContext) ||\r\n            updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            this.invokeUpdateCallbacks(contextData, contextData.context, null, { updaterId: contextUpdatedMsg.updater_id });\r\n        }\r\n    };\r\n    GW3Bridge.prototype.invokeUpdateCallbacks = function (contextData, data, delta, extraData) {\r\n        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };\r\n        for (var updateCallbackIndex in contextData.updateCallbacks) {\r\n            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {\r\n                try {\r\n                    var updateCallback = contextData.updateCallbacks[updateCallbackIndex];\r\n                    updateCallback(helpers_1.deepClone(data), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex), extraData);\r\n                }\r\n                catch (err) {\r\n                    this._logger.debug(\"Callback error: \" + JSON.stringify(err));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextDestroyedMessages = function () {\r\n        var destroyedMessageTypes = [\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n        ];\r\n        for (var _i = 0, destroyedMessageTypes_1 = destroyedMessageTypes; _i < destroyedMessageTypes_1.length; _i++) {\r\n            var destroyedMessageType = destroyedMessageTypes_1[_i];\r\n            var sub = this._connection.on(\"js-contexts\", destroyedMessageType, this.handleContextDestroyedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextDestroyedMessage = function (destroyedMsg) {\r\n        var destroyedMessageType = destroyedMsg.type;\r\n        var contextId;\r\n        var name;\r\n        if (destroyedMessageType === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n            name = destroyedMsg.activity_id;\r\n            contextId = this._contextNameToId[name];\r\n            if (!contextId) {\r\n                this._logger.error(\"Received 'destroyed' for unknown activity: \" + destroyedMsg.activity_id);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            contextId = destroyedMsg.context_id;\r\n            name = this._contextIdToName[contextId];\r\n            if (!name) {\r\n                this._logger.error(\"Received 'destroyed' for unknown context: \" + destroyedMsg.context_id);\r\n                return;\r\n            }\r\n        }\r\n        delete this._contextIdToName[contextId];\r\n        delete this._contextNameToId[name];\r\n        var contextData = this._contextNameToData[name];\r\n        delete this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            this._logger.error(\"Received 'destroyed' for unknown context: \" + contextId);\r\n            return;\r\n        }\r\n    };\r\n    GW3Bridge.prototype.sendSubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = true;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.sendUnsubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = false;\r\n        return this._gw3Session\r\n            .send({\r\n            type: msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.calculateContextDelta = function (from, to) {\r\n        var delta = { added: {}, updated: {}, removed: [], reset: null };\r\n        if (from) {\r\n            for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n                var x = _a[_i];\r\n                if (Object.keys(to).indexOf(x) !== -1\r\n                    && to[x] !== null\r\n                    && !helpers_1.deepEqual(from[x], to[x])) {\r\n                    delta.updated[x] = to[x];\r\n                }\r\n            }\r\n        }\r\n        for (var _b = 0, _c = Object.keys(to); _b < _c.length; _b++) {\r\n            var x = _c[_b];\r\n            if (!from || (Object.keys(from).indexOf(x) === -1)) {\r\n                if (to[x] !== null) {\r\n                    delta.added[x] = to[x];\r\n                }\r\n            }\r\n            else if (to[x] === null) {\r\n                delta.removed.push(x);\r\n            }\r\n        }\r\n        return delta;\r\n    };\r\n    return GW3Bridge;\r\n}());\r\nexports.GW3Bridge = GW3Bridge;\r\n//# sourceMappingURL=gw3Bridge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/gw3/gw3Bridge.js\n// module id = 86\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GW3ContextData = (function () {\r\n    function GW3ContextData(contextId, name, isAnnounced, activityId) {\r\n        this.updateCallbacks = {};\r\n        this.contextId = contextId;\r\n        this.name = name;\r\n        this.isAnnounced = isAnnounced;\r\n        this.activityId = activityId;\r\n        this.context = {};\r\n    }\r\n    GW3ContextData.prototype.hasCallbacks = function () {\r\n        return Object.keys(this.updateCallbacks).length > 0;\r\n    };\r\n    GW3ContextData.prototype.getState = function () {\r\n        if (this.isAnnounced && this.hasCallbacks()) {\r\n            return 3;\r\n        }\r\n        if (this.isAnnounced) {\r\n            return 2;\r\n        }\r\n        if (this.hasCallbacks()) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    };\r\n    return GW3ContextData;\r\n}());\r\nexports.GW3ContextData = GW3ContextData;\r\n//# sourceMappingURL=gw3ContextData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/gw3/gw3ContextData.js\n// module id = 87\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HCBridge = (function () {\r\n    function HCBridge(config) {\r\n        this._facade = window.htmlContainer.sharedContextFacade;\r\n    }\r\n    HCBridge.prototype.all = function () {\r\n        var allObj = this._facade.all();\r\n        if (!allObj || !allObj.keys) {\r\n            return [];\r\n        }\r\n        return allObj.keys;\r\n    };\r\n    HCBridge.prototype.update = function (name, delta) {\r\n        this._facade.update(name, delta);\r\n        return Promise.resolve();\r\n    };\r\n    HCBridge.prototype.set = function (name, data) {\r\n        this._facade.set(name, data);\r\n        return Promise.resolve();\r\n    };\r\n    HCBridge.prototype.subscribe = function (name, callback) {\r\n        var snapshot = null;\r\n        var key = this._facade.subscribe(name, function (data, delta, removed) {\r\n            if (!key && key !== 0) {\r\n                snapshot = data;\r\n                return;\r\n            }\r\n            callback(data, delta, removed, key);\r\n        });\r\n        if (snapshot) {\r\n            callback(snapshot, snapshot, [], key);\r\n            snapshot = null;\r\n        }\r\n        return Promise.resolve(key);\r\n    };\r\n    HCBridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                this.subscribe(name, function (data, un) {\r\n                    _this.unsubscribe(un);\r\n                    resolve(data);\r\n                });\r\n                return [2];\r\n            });\r\n        }); });\r\n    };\r\n    HCBridge.prototype.unsubscribe = function (key) {\r\n        this._facade.unsubscribe(key);\r\n    };\r\n    return HCBridge;\r\n}());\r\nexports.HCBridge = HCBridge;\r\n//# sourceMappingURL=hcBridge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/bridges/hcBridge.js\n// module id = 88\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3Bridge_1 = require(\"./bridges/gw3/gw3Bridge\");\r\nvar hcBridge_1 = require(\"./bridges/hcBridge\");\r\nvar ContextsModule = (function () {\r\n    function ContextsModule(config) {\r\n        this.config = config;\r\n        try {\r\n            if (config.gdMajorVersion === 2) {\r\n                var hc = window.htmlContainer;\r\n                if (!hc.sharedContextFacade) {\r\n                    throw new Error(\"Your version of HtmlContainer does not support contexts.\"\r\n                        + \" Get version 1.46.0.0 or later to have that feature.\");\r\n                }\r\n                this._bridge = new hcBridge_1.HCBridge(config);\r\n            }\r\n            else if (config.connection.protocolVersion === 3) {\r\n                this._bridge = new gw3Bridge_1.GW3Bridge(config);\r\n            }\r\n            else {\r\n                throw new Error(\"To use the Contexts library you must run in the\"\r\n                    + \" HTML Container or using a connection to Gateway v3.\");\r\n            }\r\n        }\r\n        catch (err) {\r\n            throw err;\r\n        }\r\n    }\r\n    ContextsModule.prototype.all = function () {\r\n        return this._bridge.all();\r\n    };\r\n    ContextsModule.prototype.update = function (name, delta) {\r\n        this.checkName(name);\r\n        return this._bridge.update(name, delta);\r\n    };\r\n    ContextsModule.prototype.set = function (name, data) {\r\n        this.checkName(name);\r\n        return this._bridge.set(name, data);\r\n    };\r\n    ContextsModule.prototype.subscribe = function (name, callback) {\r\n        var _this = this;\r\n        this.checkName(name);\r\n        return this._bridge\r\n            .subscribe(name, function (data, delta, removed, key, extraData) { return callback(data, delta, removed, function () { return _this._bridge.unsubscribe(key); }, extraData); })\r\n            .then(function (key) {\r\n            return function () {\r\n                _this._bridge.unsubscribe(key);\r\n            };\r\n        });\r\n    };\r\n    ContextsModule.prototype.get = function (name) {\r\n        return this._bridge.get(name);\r\n    };\r\n    ContextsModule.prototype.ready = function () {\r\n        return Promise.resolve(this);\r\n    };\r\n    ContextsModule.prototype.checkName = function (name) {\r\n        if (typeof name !== \"string\" ||\r\n            name == \"\") {\r\n            throw new Error(\"'name' must be non-empty string, got '\" + name + \"'\");\r\n        }\r\n    };\r\n    return ContextsModule;\r\n}());\r\nexports.ContextsModule = ContextsModule;\r\n//# sourceMappingURL=contextsModule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/contextsModule.js\n// module id = 89\n// module chunks = 0","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction applyContextDelta(context, delta) {\r\n    if (delta) {\r\n        if (delta.reset) {\r\n            context = __assign({}, delta.reset);\r\n            return context;\r\n        }\r\n        context = deepClone(context, null);\r\n        var added_1 = delta.added;\r\n        var updated_1 = delta.updated;\r\n        var removed = delta.removed;\r\n        if (added_1) {\r\n            Object.keys(added_1).forEach(function (key) {\r\n                context[key] = added_1[key];\r\n            });\r\n        }\r\n        if (updated_1) {\r\n            Object.keys(updated_1).forEach(function (key) {\r\n                mergeObjectsProperties(key, context, updated_1);\r\n            });\r\n        }\r\n        if (removed) {\r\n            removed.forEach(function (key) {\r\n                delete context[key];\r\n            });\r\n        }\r\n    }\r\n    return context;\r\n}\r\nexports.applyContextDelta = applyContextDelta;\r\nfunction deepClone(obj, hash) {\r\n    hash = hash || new WeakMap();\r\n    if (Object(obj) !== obj) {\r\n        return obj;\r\n    }\r\n    if (obj instanceof Set) {\r\n        return new Set(obj);\r\n    }\r\n    if (hash.has(obj)) {\r\n        return hash.get(obj);\r\n    }\r\n    var result = obj instanceof Date ? new Date(obj)\r\n        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)\r\n            : obj.constructor ? new obj.constructor()\r\n                : Object.create(null);\r\n    hash.set(obj, result);\r\n    if (obj instanceof Map) {\r\n        Array.from(obj, function (_a) {\r\n            var key = _a[0], val = _a[1];\r\n            return result.set(key, deepClone(val, hash));\r\n        });\r\n    }\r\n    return Object.assign.apply(Object, [result].concat(Object.keys(obj).map(function (key) {\r\n        var _a;\r\n        return (_a = {}, _a[key] = deepClone(obj[key], hash), _a);\r\n    })));\r\n}\r\nexports.deepClone = deepClone;\r\nvar mergeObjectsProperties = function (key, what, withWhat) {\r\n    var right = withWhat[key];\r\n    if (right === undefined) {\r\n        return what;\r\n    }\r\n    var left = what[key];\r\n    if (!left || !right) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    if (typeof left === \"string\" ||\r\n        typeof left === \"number\" ||\r\n        typeof left === \"boolean\" ||\r\n        typeof right === \"string\" ||\r\n        typeof right === \"number\" ||\r\n        typeof right === \"boolean\" ||\r\n        Array.isArray(left) ||\r\n        Array.isArray(right)) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    what[key] = Object.assign({}, left, right);\r\n    return what;\r\n};\r\nfunction deepEqual(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    if (!(x instanceof Object) || !(y instanceof Object)) {\r\n        return false;\r\n    }\r\n    if (x.constructor !== y.constructor) {\r\n        return false;\r\n    }\r\n    for (var p in x) {\r\n        if (!x.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (!y.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        if (x[p] === y[p]) {\r\n            continue;\r\n        }\r\n        if (typeof (x[p]) !== \"object\") {\r\n            return false;\r\n        }\r\n        if (!deepEqual(x[p], y[p])) {\r\n            return false;\r\n        }\r\n    }\r\n    for (var p in y) {\r\n        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.deepEqual = deepEqual;\r\n//# sourceMappingURL=helpers.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/helpers.js\n// module id = 90\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar contextsModule_1 = require(\"./contextsModule\");\r\nexports.ContextsModule = contextsModule_1.ContextsModule;\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/contexts/main.js\n// module id = 91\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar LogLevel = (function () {\r\n    function LogLevel() {\r\n    }\r\n    LogLevel.canPublish = function (level, restriction) {\r\n        var levelIdx = LogLevel.order.indexOf(level);\r\n        var restrictionIdx = LogLevel.order.indexOf(restriction);\r\n        return levelIdx >= restrictionIdx;\r\n    };\r\n    LogLevel.off = \"off\";\r\n    LogLevel.trace = \"trace\";\r\n    LogLevel.debug = \"debug\";\r\n    LogLevel.info = \"info\";\r\n    LogLevel.warn = \"warn\";\r\n    LogLevel.error = \"error\";\r\n    LogLevel.order = [LogLevel.trace, LogLevel.debug, LogLevel.info, LogLevel.warn, LogLevel.error, LogLevel.off];\r\n    return LogLevel;\r\n}());\r\nexports.default = LogLevel;\r\n//# sourceMappingURL=levels.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/logger/levels.js\n// module id = 92\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar levels_1 = require(\"./levels\");\r\nvar LoggerImpl = (function () {\r\n    function LoggerImpl(name, parent, metricSystem) {\r\n        this._subloggers = [];\r\n        this._name = name;\r\n        this._parent = parent;\r\n        if (parent) {\r\n            this._path = parent.path + \".\" + name;\r\n        }\r\n        else {\r\n            this._path = name;\r\n        }\r\n        this._loggerFullName = \"[\" + this._path + \"]\";\r\n        if (typeof metricSystem !== \"undefined\") {\r\n            this.metricsLevel(\"warn\", metricSystem.subSystem(name));\r\n        }\r\n    }\r\n    Object.defineProperty(LoggerImpl.prototype, \"name\", {\r\n        get: function () {\r\n            return this._name;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(LoggerImpl.prototype, \"path\", {\r\n        get: function () {\r\n            return this._path;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    LoggerImpl.prototype.subLogger = function (name) {\r\n        var existingSub = this._subloggers.filter(function (subLogger) {\r\n            return subLogger.name === name;\r\n        })[0];\r\n        if (existingSub !== undefined) {\r\n            return existingSub;\r\n        }\r\n        Object.keys(this).forEach(function (key) {\r\n            if (key === name) {\r\n                throw new Error(\"This sub logger name is not allowed.\");\r\n            }\r\n        });\r\n        var sub = new LoggerImpl(name, this);\r\n        this._subloggers.push(sub);\r\n        return sub;\r\n    };\r\n    LoggerImpl.prototype.publishLevel = function (level) {\r\n        if (level !== null && level !== undefined) {\r\n            this._publishLevel = level;\r\n        }\r\n        return this._publishLevel || this._parent.publishLevel();\r\n    };\r\n    LoggerImpl.prototype.consoleLevel = function (level) {\r\n        if (level !== null && level !== undefined) {\r\n            this._consoleLevel = level;\r\n        }\r\n        return this._consoleLevel || this._parent.consoleLevel();\r\n    };\r\n    LoggerImpl.prototype.metricsLevel = function (level, metricsSystem) {\r\n        if (level !== null && level !== undefined) {\r\n            this._metricLevel = level;\r\n        }\r\n        if (metricsSystem !== undefined) {\r\n            if (typeof metricsSystem === \"object\" && typeof metricsSystem.objectMetric === \"function\") {\r\n                this._metricSystem = metricsSystem;\r\n            }\r\n            else {\r\n                throw new Error(\"Please specify metric system\");\r\n            }\r\n        }\r\n        return this._metricLevel || this._parent.metricsLevel();\r\n    };\r\n    LoggerImpl.prototype.log = function (message, level) {\r\n        this.publishMessage(level || levels_1.default.info, message);\r\n    };\r\n    LoggerImpl.prototype.trace = function (message) {\r\n        this.log(message, levels_1.default.trace);\r\n    };\r\n    LoggerImpl.prototype.debug = function (message) {\r\n        this.log(message, levels_1.default.debug);\r\n    };\r\n    LoggerImpl.prototype.info = function (message) {\r\n        this.log(message, levels_1.default.info);\r\n    };\r\n    LoggerImpl.prototype.warn = function (message) {\r\n        this.log(message, levels_1.default.warn);\r\n    };\r\n    LoggerImpl.prototype.error = function (message) {\r\n        this.log(message, levels_1.default.error);\r\n    };\r\n    LoggerImpl.prototype.toAPIObject = function () {\r\n        var that = this;\r\n        return {\r\n            name: this.name,\r\n            subLogger: this.subLogger.bind(that),\r\n            publishLevel: this.publishLevel.bind(that),\r\n            consoleLevel: this.consoleLevel.bind(that),\r\n            metricsLevel: this.metricsLevel.bind(that),\r\n            log: this.log.bind(that),\r\n            trace: this.trace.bind(that),\r\n            debug: this.debug.bind(that),\r\n            info: this.info.bind(that),\r\n            warn: this.warn.bind(that),\r\n            error: this.error.bind(that),\r\n        };\r\n    };\r\n    LoggerImpl.prototype.publishMessage = function (level, message) {\r\n        var loggerName = this._loggerFullName;\r\n        if (level === levels_1.default.error) {\r\n            var e = new Error();\r\n            if (e.stack) {\r\n                message = message + \"\\n\" +\r\n                    (e.stack.split(\"\\n\").slice(3).join(\"\\n\"));\r\n            }\r\n        }\r\n        if (levels_1.default.canPublish(level, this.consoleLevel())) {\r\n            var toPrint = loggerName + \": \" + message;\r\n            switch (level) {\r\n                case levels_1.default.trace:\r\n                    console.trace(toPrint);\r\n                    break;\r\n                case levels_1.default.debug:\r\n                    if (console.debug) {\r\n                        console.debug(toPrint);\r\n                    }\r\n                    else {\r\n                        console.log(toPrint);\r\n                    }\r\n                    break;\r\n                case levels_1.default.info:\r\n                    console.info(toPrint);\r\n                    break;\r\n                case levels_1.default.warn:\r\n                    console.warn(toPrint);\r\n                    break;\r\n                case levels_1.default.error:\r\n                    console.error(toPrint);\r\n                    break;\r\n            }\r\n        }\r\n        if (levels_1.default.canPublish(level, this.publishLevel())) {\r\n            LoggerImpl.GetConnection().send(\"log\", \"LogMessage\", {\r\n                instance: LoggerImpl.Instance,\r\n                level: levels_1.default.order.indexOf(level),\r\n                logger: loggerName,\r\n                message: message,\r\n            });\r\n        }\r\n        if (levels_1.default.canPublish(level, this.metricsLevel())) {\r\n            if (this._metricSystem !== undefined) {\r\n                this._metricSystem.objectMetric(\"LogMessage\", {\r\n                    Level: level,\r\n                    Logger: loggerName,\r\n                    Message: message,\r\n                    Time: new Date(),\r\n                });\r\n                if (level === levels_1.default.error) {\r\n                    this._metricSystem.setState(100, message);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return LoggerImpl;\r\n}());\r\nexports.default = LoggerImpl;\r\n//# sourceMappingURL=logger.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/logger/logger.js\n// module id = 93\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar logger_1 = require(\"./logger\");\r\nexports.default = (function (settings) {\r\n    var identity = settings.identity;\r\n    if (!identity) {\r\n        throw new Error(\"identity is missing\");\r\n    }\r\n    var identityStr = identity.system + \"\\\\\" + identity.service + \"\\\\\" + identity.instance;\r\n    logger_1.default.Instance = identityStr;\r\n    logger_1.default.GetConnection = settings.getConnection;\r\n    var mainLogger = new logger_1.default(\"main\");\r\n    mainLogger.publishLevel(settings.publish || \"off\");\r\n    mainLogger.consoleLevel(settings.console || \"info\");\r\n    mainLogger.metricsLevel(settings.metrics || \"off\");\r\n    var apiLogger = mainLogger.toAPIObject();\r\n    return apiLogger;\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/logger/main.js\n// module id = 94\n// module chunks = 0","\"use strict\";\r\nvar glue_1 = require(\"./glue\");\r\nvar pjson = require(\"../package.json\");\r\nif (typeof window !== \"undefined\") {\r\n    window.GlueCore = glue_1.default;\r\n}\r\nglue_1.default.default = glue_1.default;\r\nglue_1.default.version = pjson.version;\r\nmodule.exports = glue_1.default;\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/main.js\n// module id = 95\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction addressMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var conflation = definition.conflation;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.ADDRESS;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = addressMetric;\r\n//# sourceMappingURL=address.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/address.js\n// module id = 96\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction countMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || 0;\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.COUNT;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function incrementBy(num) {\r\n        update(_value + num);\r\n    }\r\n    function increment() {\r\n        incrementBy(1);\r\n    }\r\n    function decrement() {\r\n        incrementBy(-1);\r\n    }\r\n    function decrementBy(num) {\r\n        incrementBy(num * -1);\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get path() {\r\n            return _path;\r\n        },\r\n        get value() {\r\n            return _value;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n        incrementBy: incrementBy,\r\n        increment: increment,\r\n        decrement: decrement,\r\n        decrementBy: decrementBy,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = countMetric;\r\n//# sourceMappingURL=count.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/count.js\n// module id = 97\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction numberMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _path = parent.path.slice(0);\r\n    var _value = value || 0;\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.NUMBER;\r\n    _path.push(parent.name);\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function incrementBy(num) {\r\n        update(_value + num);\r\n    }\r\n    function increment() {\r\n        incrementBy(1);\r\n    }\r\n    function decrement() {\r\n        incrementBy(-1);\r\n    }\r\n    function decrementBy(num) {\r\n        incrementBy(num * -1);\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        type: type,\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n        incrementBy: incrementBy,\r\n        increment: increment,\r\n        decrement: decrement,\r\n        decrementBy: decrementBy,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = numberMetric;\r\n//# sourceMappingURL=number.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/number.js\n// module id = 98\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nvar helpers_1 = require(\"../../helpers\");\r\nfunction objectMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.OBJECT;\r\n    function update(newValue) {\r\n        mergeValues(newValue);\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    function mergeValues(values) {\r\n        return Object.keys(_value).forEach(function (k) {\r\n            if (typeof values[k] !== \"undefined\") {\r\n                _value[k] = values[k];\r\n            }\r\n        });\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = objectMetric;\r\n//# sourceMappingURL=object.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/object.js\n// module id = 99\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction rateMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.RATE;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = rateMetric;\r\n//# sourceMappingURL=rate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/rate.js\n// module id = 100\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction statisticsMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.STATISTICS;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = statisticsMetric;\r\n//# sourceMappingURL=statistics.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/statistics.js\n// module id = 101\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction stringMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.STRING;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        type: type,\r\n        update: update,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = stringMetric;\r\n//# sourceMappingURL=string.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/string.js\n// module id = 102\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction timespanMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.TIMESPAN;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function start() {\r\n        update(true);\r\n    }\r\n    function stop() {\r\n        update(false);\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        start: start,\r\n        stop: stop,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = timespanMetric;\r\n//# sourceMappingURL=timespan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/timespan.js\n// module id = 103\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"../../helpers\");\r\nvar metric_types_1 = require(\"../const/metric-types\");\r\nfunction timestampMetric(definition, parent, transport, value) {\r\n    helpers_1.default.validate(definition, parent, transport);\r\n    var _transport = transport;\r\n    var _value = value || \"\";\r\n    var _path = parent.path.slice(0);\r\n    _path.push(parent.name);\r\n    var name = definition.name;\r\n    var description = definition.description;\r\n    var period = definition.period;\r\n    var resolution = definition.resolution;\r\n    var conflation = definition.conflation;\r\n    var system = parent;\r\n    var repo = parent.repo;\r\n    var id = parent.path + \"/\" + name;\r\n    var type = metric_types_1.default.TIMESTAMP;\r\n    function update(newValue) {\r\n        _value = newValue;\r\n        _transport.updateMetric(me);\r\n    }\r\n    function now() {\r\n        update(new Date());\r\n    }\r\n    function getValueType() {\r\n        return undefined;\r\n    }\r\n    var me = {\r\n        name: name,\r\n        description: description,\r\n        period: period,\r\n        resolution: resolution,\r\n        system: system,\r\n        repo: repo,\r\n        id: id,\r\n        type: type,\r\n        conflation: conflation,\r\n        get value() {\r\n            return _value;\r\n        },\r\n        get path() {\r\n            return _path;\r\n        },\r\n        update: update,\r\n        now: now,\r\n        getValueType: getValueType,\r\n    };\r\n    _transport.createMetric(me);\r\n    return me;\r\n}\r\nexports.default = timestampMetric;\r\n//# sourceMappingURL=timestamp.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/metrics/timestamp.js\n// module id = 104\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar serializer_1 = require(\"./serializer\");\r\nfunction default_1(connection, config) {\r\n    var DEFAULT_HEARTBEAT_INTERVAL = 3000;\r\n    var heartbeatTimer;\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var _connection = connection;\r\n    var heartbeatInterval = config.heartbeatInterval || DEFAULT_HEARTBEAT_INTERVAL;\r\n    var send = function (type, message) {\r\n        _connection.send(\"metrics\", type, message);\r\n    };\r\n    function sendFull(repo) {\r\n        if (!repo.root) {\r\n            return;\r\n        }\r\n        if (repo.root.subSystems.length === 0) {\r\n            return;\r\n        }\r\n        sendFullSystem(repo.root);\r\n    }\r\n    function sendFullSystem(system) {\r\n        createSystem(system);\r\n        system.subSystems.forEach(function (sub) {\r\n            sendFullSystem(sub);\r\n        });\r\n        system.metrics.forEach(function (metric) {\r\n            createMetric(metric);\r\n        });\r\n    }\r\n    function heartbeat(repo) {\r\n        send(\"HeartbeatMetrics\", {\r\n            publishingInterval: heartbeatInterval,\r\n            instance: repo.instance,\r\n        });\r\n    }\r\n    function createSystem(system) {\r\n        if (system.parent !== undefined) {\r\n            send(\"CreateMetricSystem\", {\r\n                id: system.id,\r\n                instance: system.repo.instance,\r\n                definition: {\r\n                    name: system.name,\r\n                    description: system.description,\r\n                    path: system.path,\r\n                },\r\n            });\r\n        }\r\n    }\r\n    function updateSystem(system, state) {\r\n        send(\"UpdateMetricSystem\", {\r\n            id: system.id,\r\n            instance: system.repo.instance,\r\n            state: state,\r\n        });\r\n    }\r\n    function createMetric(metric) {\r\n        send(\"CreateMetric\", serializer_1.default(metric));\r\n    }\r\n    function updateMetric(metric) {\r\n        send(\"UpdateMetric\", serializer_1.default(metric));\r\n    }\r\n    function init(repo) {\r\n        heartbeat(repo);\r\n        _connection.on(\"metrics\", \"MetricsSnapshotRequest\", function (instanceInfo) {\r\n            if (instanceInfo.Instance !== repo.instance) {\r\n                return;\r\n            }\r\n            sendFull(repo);\r\n        });\r\n        _connection.disconnected(function () { return clearInterval(heartbeatTimer); });\r\n        if (typeof window !== \"undefined\" && typeof window.htmlContainer === \"undefined\") {\r\n            heartbeatTimer = setInterval(function () {\r\n                heartbeat(repo);\r\n            }, heartbeatInterval);\r\n        }\r\n    }\r\n    var me = {\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n        init: init,\r\n    };\r\n    return me;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw1.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw1/gw1.js\n// module id = 105\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = require(\"../../const/metric-types\");\r\nfunction metricToMessage(metric) {\r\n    var definition = getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution, metric.conflation);\r\n    function getMetricDefinition(name, value, path, type, description, period, resolution, conflation) {\r\n        var _definition = {\r\n            name: name,\r\n            description: description,\r\n            type: type ? type : getTypeFromValue(value),\r\n            path: path,\r\n            resolution: resolution,\r\n            period: period,\r\n            conflation: conflation,\r\n        };\r\n        if (_definition.type === metric_types_1.default.OBJECT) {\r\n            _definition.Composite = Object.keys(value).reduce(function (arr, key) {\r\n                var val = value[key];\r\n                arr.push(getMetricDefinition(key, val, path));\r\n                return arr;\r\n            }, []);\r\n        }\r\n        return _definition;\r\n    }\r\n    function serializeValue(value, _metric) {\r\n        if (value && value.constructor === Date) {\r\n            return {\r\n                value: {\r\n                    type: _valueTypes.indexOf(\"date\"),\r\n                    value: value.valueOf(),\r\n                    isArray: false,\r\n                },\r\n            };\r\n        }\r\n        if (typeof value === \"object\") {\r\n            return {\r\n                CompositeValue: Object.keys(value).reduce(function (arr, key) {\r\n                    var val = serializeValue(value[key]);\r\n                    val.InnerMetricName = key;\r\n                    arr.push(val);\r\n                    return arr;\r\n                }, []),\r\n            };\r\n        }\r\n        var valueType = _metric ? _metric.getValueType() : undefined;\r\n        valueType = valueType || _valueTypes.indexOf(typeof value);\r\n        return {\r\n            value: {\r\n                type: valueType,\r\n                value: value,\r\n                isArray: false,\r\n            },\r\n        };\r\n    }\r\n    function getTypeFromValue(value) {\r\n        var typeAsString = value.constructor === Date ? \"timestamp\" : typeof value;\r\n        switch (typeAsString) {\r\n            case \"string\":\r\n                return metric_types_1.default.STRING;\r\n            case \"number\":\r\n                return metric_types_1.default.NUMBER;\r\n            case \"timestamp\":\r\n                return metric_types_1.default.TIMESTAMP;\r\n            case \"object\":\r\n                return metric_types_1.default.OBJECT;\r\n        }\r\n        return 0;\r\n    }\r\n    var _valueTypes = [\r\n        \"boolean\",\r\n        \"int\",\r\n        \"number\",\r\n        \"long\",\r\n        \"string\",\r\n        \"date\",\r\n        \"object\",\r\n    ];\r\n    return {\r\n        id: metric.id,\r\n        instance: metric.repo.instance,\r\n        definition: definition,\r\n        value: serializeValue(metric.value, metric),\r\n    };\r\n}\r\nexports.default = metricToMessage;\r\n//# sourceMappingURL=serializer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw1/serializer.js\n// module id = 106\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar serializer_1 = require(\"./serializer\");\r\nfunction default_1(connection, config) {\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var joinPromise;\r\n    var session;\r\n    var init = function (repo) {\r\n        var resolveReadyPromise;\r\n        joinPromise = new Promise(function (resolve) {\r\n            resolveReadyPromise = resolve;\r\n        });\r\n        session = connection.domain(\"metrics\", config.logger);\r\n        session.onJoined(function (reconnect) {\r\n            if (!reconnect) {\r\n                resolveReadyPromise();\r\n                resolveReadyPromise = undefined;\r\n            }\r\n            var rootStateMetric = {\r\n                name: \"/State\",\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var defineRootMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [rootStateMetric],\r\n            };\r\n            session.send(defineRootMetricsMsg);\r\n            if (reconnect) {\r\n                replayRepo(repo);\r\n            }\r\n        });\r\n        session.join(config.identity);\r\n    };\r\n    var replayRepo = function (repo) {\r\n        replaySystem(repo.root);\r\n    };\r\n    var replaySystem = function (system) {\r\n        createSystem(system);\r\n        system.metrics.forEach(function (m) {\r\n            createMetric(m);\r\n        });\r\n        system.subSystems.forEach(function (ss) {\r\n            replaySystem(ss);\r\n        });\r\n    };\r\n    var createSystem = function (system) {\r\n        if (system.parent === undefined) {\r\n            return;\r\n        }\r\n        joinPromise.then(function () {\r\n            var metric = {\r\n                name: serializer_1.normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var createMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [metric],\r\n            };\r\n            session.send(createMetricsMsg);\r\n        });\r\n    };\r\n    var updateSystem = function (system, state) {\r\n        joinPromise.then(function () {\r\n            var shadowedUpdateMetric = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: serializer_1.normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                        value: {\r\n                            Description: state.description,\r\n                            Value: state.state,\r\n                        },\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(shadowedUpdateMetric);\r\n            var stateObj = serializer_1.composeMsgForRootStateMetric(system);\r\n            var rootMetric = {\r\n                type: \"publish\",\r\n                peer_id: connection.peerId,\r\n                values: [{\r\n                        name: \"/State\",\r\n                        value: {\r\n                            Description: stateObj.description,\r\n                            Value: stateObj.value,\r\n                        },\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(rootMetric);\r\n        });\r\n    };\r\n    var createMetric = function (metric) {\r\n        joinPromise.then(function () {\r\n            var m = serializer_1.serializeMetric(metric);\r\n            var createMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [m],\r\n            };\r\n            session.send(createMetricsMsg);\r\n            if (typeof metric.value !== \"undefined\") {\r\n                updateMetric(metric);\r\n            }\r\n        });\r\n    };\r\n    var updateMetric = function (metric) {\r\n        joinPromise.then(function () {\r\n            var value = serializer_1.getMetricValueByType(metric);\r\n            var publishMetricsMsg = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: serializer_1.normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name),\r\n                        value: value,\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            session.send(publishMetricsMsg);\r\n        });\r\n    };\r\n    return {\r\n        init: init,\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=gw3.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw3/gw3.js\n// module id = 107\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar metric_types_1 = require(\"../../const/metric-types\");\r\nfunction getMetricTypeByValue(metric) {\r\n    if ((metric.value && metric.value.constructor === Date) || metric.type === metric_types_1.default.TIMESPAN || metric.type === metric_types_1.default.TIMESTAMP) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof metric.value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof metric.value === \"string\" || metric.type === metric_types_1.default.STRING || metric.type === metric_types_1.default.RATE) {\r\n        return \"string\";\r\n    }\r\n    else if (typeof metric.value === \"object\") {\r\n        return \"object\";\r\n    }\r\n}\r\nfunction getTypeByValue(value) {\r\n    if (value.constructor === Date) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof value === \"string\") {\r\n        return \"string\";\r\n    }\r\n    else if (typeof value === \"object\") {\r\n        return \"object\";\r\n    }\r\n    else {\r\n        return \"string\";\r\n    }\r\n}\r\nfunction serializeMetric(metric) {\r\n    var serializedMetrics = {};\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"object\") {\r\n        var values = Object.keys(metric.value).reduce(function (memo, key) {\r\n            var innerType = getTypeByValue(metric.value[key]);\r\n            if (innerType === \"object\") {\r\n                var composite = defineNestedComposite(metric.value[key]);\r\n                memo[key] = {\r\n                    type: \"object\",\r\n                    description: \"\",\r\n                    context: {},\r\n                    composite: composite,\r\n                };\r\n            }\r\n            else {\r\n                memo[key] = {\r\n                    type: innerType,\r\n                    description: \"\",\r\n                    context: {},\r\n                };\r\n            }\r\n            return memo;\r\n        }, {});\r\n        serializedMetrics.composite = values;\r\n    }\r\n    serializedMetrics.name = normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name);\r\n    serializedMetrics.type = type;\r\n    serializedMetrics.description = metric.description;\r\n    serializedMetrics.context = {};\r\n    return serializedMetrics;\r\n}\r\nexports.serializeMetric = serializeMetric;\r\nfunction defineNestedComposite(values) {\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var type = getTypeByValue(values[key]);\r\n        if (type === \"object\") {\r\n            memo[key] = {\r\n                type: \"object\",\r\n                description: \"\",\r\n                context: {},\r\n                composite: defineNestedComposite(values[key]),\r\n            };\r\n        }\r\n        else {\r\n            memo[key] = {\r\n                type: type,\r\n                description: \"\",\r\n                context: {},\r\n            };\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction normalizeMetricName(name) {\r\n    if (typeof name !== \"undefined\" && name.length > 0 && name[0] !== \"/\") {\r\n        return \"/\" + name;\r\n    }\r\n    else {\r\n        return name;\r\n    }\r\n}\r\nexports.normalizeMetricName = normalizeMetricName;\r\nfunction getMetricValueByType(metric) {\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"timestamp\") {\r\n        return Date.now();\r\n    }\r\n    else {\r\n        return publishNestedComposite(metric.value);\r\n    }\r\n}\r\nexports.getMetricValueByType = getMetricValueByType;\r\nfunction publishNestedComposite(values) {\r\n    if (typeof values !== \"object\") {\r\n        return values;\r\n    }\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var value = values[key];\r\n        if (typeof value === \"object\" && value.constructor !== Date) {\r\n            memo[key] = publishNestedComposite(value);\r\n        }\r\n        else if (value.constructor === Date) {\r\n            memo[key] = new Date(value).getTime();\r\n        }\r\n        else if (value.constructor === Boolean) {\r\n            memo[key] = value.toString();\r\n        }\r\n        else {\r\n            memo[key] = value;\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction flatten(arr) {\r\n    return arr.reduce(function (flat, toFlatten) {\r\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\r\n    }, []);\r\n}\r\nfunction getHighestState(arr) {\r\n    return arr.sort(function (a, b) {\r\n        return b.state - a.state;\r\n    })[0];\r\n}\r\nfunction aggregateDescription(arr) {\r\n    var msg = \"\";\r\n    arr.forEach(function (m, idx, a) {\r\n        var path = m.path.join(\".\");\r\n        if (idx === a.length - 1) {\r\n            msg += path + \".\" + m.name + \": \" + m.description;\r\n        }\r\n        else {\r\n            msg += path + \".\" + m.name + \": \" + m.description + \",\";\r\n        }\r\n    });\r\n    if (msg.length > 100) {\r\n        return msg.slice(0, 100) + \"...\";\r\n    }\r\n    else {\r\n        return msg;\r\n    }\r\n}\r\nfunction composeMsgForRootStateMetric(system) {\r\n    var aggregatedState = system.root.getAggregateState();\r\n    var merged = flatten(aggregatedState);\r\n    var highestState = getHighestState(merged);\r\n    var aggregateDesc = aggregateDescription(merged);\r\n    return {\r\n        description: aggregateDesc,\r\n        value: highestState.state,\r\n    };\r\n}\r\nexports.composeMsgForRootStateMetric = composeMsgForRootStateMetric;\r\n//# sourceMappingURL=serializer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/core/protocols/gw3/serializer.js\n// module id = 108\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar gw3_1 = require(\"./core/protocols/gw3/gw3\");\r\nvar gw1_1 = require(\"./core/protocols/gw1/gw1\");\r\nvar repository_1 = require(\"./repository\");\r\nexports.default = (function (settings) {\r\n    var options = {\r\n        connection: settings.connection,\r\n        identity: settings.identity,\r\n        logger: settings.logger,\r\n        heartbeatInterval: settings.heartbeatInterval,\r\n        settings: {},\r\n        clickStream: settings.clickStream,\r\n    };\r\n    if (!options.connection || typeof options.connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var _protocol;\r\n    if (options.connection.protocolVersion === 3) {\r\n        _protocol = gw3_1.default(options.connection, settings);\r\n    }\r\n    else {\r\n        _protocol = gw1_1.default(options.connection, settings);\r\n    }\r\n    var repo = repository_1.default(options, _protocol);\r\n    var rootSystem = repo.root;\r\n    return rootSystem;\r\n});\r\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/main.js\n// module id = 109\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar system_1 = require(\"./system\");\r\nfunction repository(options, protocol) {\r\n    if (!options.identity) {\r\n        throw new Error(\"Identity missing from metrics configuration\");\r\n    }\r\n    if (!options.identity.service || typeof options.identity.service !== \"string\") {\r\n        throw new Error(\"Service missing or invalid in metrics identity configuration\");\r\n    }\r\n    if (!options.identity.system || typeof options.identity.system !== \"string\") {\r\n        throw new Error(\"System missing or invalid in metrics identity configuration\");\r\n    }\r\n    if (!options.identity.instance || typeof options.identity.instance !== \"string\") {\r\n        throw new Error(\"Instance missing or invalid in metrics identity configuration\");\r\n    }\r\n    var identity = options.identity;\r\n    var instance = options.identity.system + \"/\" + options.identity.service + \"/\" + options.identity.instance;\r\n    function _initSystemMetrics(rootSystem, useClickStream) {\r\n        if (typeof navigator !== \"undefined\") {\r\n            rootSystem.stringMetric(\"UserAgent\", navigator.userAgent);\r\n        }\r\n        if (useClickStream && typeof document !== \"undefined\") {\r\n            var clickStream_1 = rootSystem.subSystem(\"ClickStream\");\r\n            var documentClickHandler = function (e) {\r\n                if (!e.target) {\r\n                    return;\r\n                }\r\n                var target = e.target;\r\n                clickStream_1.objectMetric(\"LastBrowserEvent\", {\r\n                    type: \"click\",\r\n                    timestamp: new Date(),\r\n                    target: {\r\n                        className: e.target ? target.className : \"\",\r\n                        id: target.id,\r\n                        type: \"<\" + target.tagName.toLowerCase() + \">\",\r\n                        href: target.href || \"\",\r\n                    },\r\n                });\r\n            };\r\n            clickStream_1.objectMetric(\"Page\", {\r\n                title: document.title,\r\n                page: window.location.href,\r\n            });\r\n            if (document.addEventListener) {\r\n                document.addEventListener(\"click\", documentClickHandler);\r\n            }\r\n            else {\r\n                document.attachEvent(\"onclick\", documentClickHandler);\r\n            }\r\n        }\r\n        var startTime = rootSystem.stringMetric(\"StartTime\", (new Date()).toString());\r\n        var urlMetric = rootSystem.stringMetric(\"StartURL\", \"\");\r\n        var appNameMetric = rootSystem.stringMetric(\"AppName\", \"\");\r\n        if (typeof window !== \"undefined\") {\r\n            if (typeof window.location !== \"undefined\") {\r\n                var startUrl = window.location.href;\r\n                urlMetric.update(startUrl);\r\n            }\r\n            if (typeof window.glue42gd !== \"undefined\") {\r\n                appNameMetric.update(window.glue42gd.appName);\r\n            }\r\n        }\r\n    }\r\n    var me = {\r\n        identity: identity,\r\n        instance: instance,\r\n        get root() {\r\n            return _root;\r\n        },\r\n    };\r\n    protocol.init(me);\r\n    var _root = system_1.default(\"\", me, protocol);\r\n    _initSystemMetrics(_root, options.clickStream || options.clickStream === undefined);\r\n    return me;\r\n}\r\nexports.default = repository;\r\n//# sourceMappingURL=repository.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/repository.js\n// module id = 110\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar address_1 = require(\"./core/metrics/address\");\r\nvar count_1 = require(\"./core/metrics/count\");\r\nvar number_1 = require(\"./core/metrics/number\");\r\nvar object_1 = require(\"./core/metrics/object\");\r\nvar rate_1 = require(\"./core/metrics/rate\");\r\nvar statistics_1 = require(\"./core/metrics/statistics\");\r\nvar string_1 = require(\"./core/metrics/string\");\r\nvar timespan_1 = require(\"./core/metrics/timespan\");\r\nvar timestamp_1 = require(\"./core/metrics/timestamp\");\r\nvar metric_types_1 = require(\"./core/const/metric-types\");\r\nfunction system(name, repo, protocol, parent, description) {\r\n    if (!repo) {\r\n        throw new Error(\"Repository is required\");\r\n    }\r\n    if (!protocol) {\r\n        throw new Error(\"Transport is required\");\r\n    }\r\n    var _transport = protocol;\r\n    var _name = name;\r\n    var _description = description || \"\";\r\n    var _repo = repo;\r\n    var _parent = parent;\r\n    var _path = _buildPath(parent);\r\n    var _state = {};\r\n    var id = _arrayToString(_path, \"/\") + name;\r\n    var identity = repo.identity;\r\n    var root = repo.root;\r\n    var _subSystems = [];\r\n    var _metrics = [];\r\n    function subSystem(nameSystem, descriptionSystem) {\r\n        if (!nameSystem || nameSystem.length === 0) {\r\n            throw new Error(\"name is required\");\r\n        }\r\n        var match = _subSystems.filter(function (s) { return s.name === nameSystem; });\r\n        if (match.length > 0) {\r\n            return match[0];\r\n        }\r\n        var _system = system(nameSystem, _repo, _transport, me, descriptionSystem);\r\n        _subSystems.push(_system);\r\n        return _system;\r\n    }\r\n    function setState(state, stateDescription) {\r\n        _state = { state: state, description: stateDescription };\r\n        _transport.updateSystem(me, _state);\r\n    }\r\n    function stringMetric(definition, value) {\r\n        return _getOrCreateMetric.call(me, definition, metric_types_1.default.STRING, value, function (metricDef) { return string_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function numberMetric(definition, value) {\r\n        return _getOrCreateMetric.call(me, definition, metric_types_1.default.NUMBER, value, function (metricDef) { return number_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function countMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.COUNT, value, function (metricDef) { return count_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function addressMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.ADDRESS, value, function (metricDef) { return address_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function objectMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.OBJECT, value, function (metricDef) { return object_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function timespanMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.TIMESPAN, value, function (metricDef) { return timespan_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function timestampMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.TIMESTAMP, value, function (metricDef) { return timestamp_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function rateMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.RATE, value, function (metricDef) { return rate_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function statisticsMetric(definition, value) {\r\n        return _getOrCreateMetric.call(this, definition, metric_types_1.default.STATISTICS, value, function (metricDef) { return statistics_1.default(metricDef, me, _transport, value); });\r\n    }\r\n    function _unionToMetricDef(def) {\r\n        var metricDefinition = {};\r\n        if (typeof def === \"string\") {\r\n            metricDefinition.name = def;\r\n        }\r\n        else {\r\n            metricDefinition = def;\r\n        }\r\n        if (metricDefinition.name === undefined) {\r\n            throw new Error(\"Metric name is required\");\r\n        }\r\n        return metricDefinition;\r\n    }\r\n    function _getOrCreateMetric(definition, expectedType, value, createMetric) {\r\n        var metricDefinition = _unionToMetricDef(definition);\r\n        var matching = _metrics.filter(function (shadowedMetric) { return shadowedMetric.name === metricDefinition.name; });\r\n        if (matching.length > 0) {\r\n            var existing = matching[0];\r\n            if (existing.type !== expectedType) {\r\n                throw new Error(\"A metric named \" + metricDefinition.name + \" is already defined with different type.\");\r\n            }\r\n            if (typeof value !== \"undefined\") {\r\n                existing.update(value);\r\n            }\r\n            return existing;\r\n        }\r\n        var metric = createMetric(metricDefinition);\r\n        _metrics.push(metric);\r\n        return metric;\r\n    }\r\n    function _buildPath(shadowedSystem) {\r\n        if (!shadowedSystem || !shadowedSystem.parent) {\r\n            return [];\r\n        }\r\n        var path = _buildPath(shadowedSystem.parent);\r\n        path.push(shadowedSystem.name);\r\n        return path;\r\n    }\r\n    function _arrayToString(path, separator) {\r\n        return ((path && path.length > 0) ? path.join(separator) : \"\");\r\n    }\r\n    function getAggregateState() {\r\n        var aggState = [];\r\n        if (Object.keys(_state).length > 0) {\r\n            aggState.push({\r\n                name: _name,\r\n                path: _path,\r\n                state: _state.state,\r\n                description: _state.description,\r\n            });\r\n        }\r\n        _subSystems.forEach(function (shadowedSubSystem) {\r\n            var result = shadowedSubSystem.getAggregateState();\r\n            if (result.length > 0) {\r\n                aggState.push.apply(aggState, result);\r\n            }\r\n        });\r\n        return aggState;\r\n    }\r\n    var me = {\r\n        get name() {\r\n            return _name;\r\n        },\r\n        get description() {\r\n            return _description;\r\n        },\r\n        get repo() {\r\n            return _repo;\r\n        },\r\n        get parent() {\r\n            return _parent;\r\n        },\r\n        path: _path,\r\n        id: id,\r\n        identity: identity,\r\n        root: root,\r\n        get subSystems() {\r\n            return _subSystems;\r\n        },\r\n        get metrics() {\r\n            return _metrics;\r\n        },\r\n        subSystem: subSystem,\r\n        getState: function () {\r\n            return _state;\r\n        },\r\n        setState: setState,\r\n        stringMetric: stringMetric,\r\n        statisticsMetric: statisticsMetric,\r\n        rateMetric: rateMetric,\r\n        timestampMetric: timestampMetric,\r\n        timespanMetric: timespanMetric,\r\n        objectMetric: objectMetric,\r\n        addressMetric: addressMetric,\r\n        countMetric: countMetric,\r\n        numberMetric: numberMetric,\r\n        getAggregateState: getAggregateState,\r\n    };\r\n    _transport.createSystem(me);\r\n    return me;\r\n}\r\nexports.default = system;\r\n//# sourceMappingURL=system.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/metrics/system.js\n// module id = 111\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1() {\r\n    function now() {\r\n        return new Date().getTime();\r\n    }\r\n    var startTime = now();\r\n    var endTime;\r\n    var period;\r\n    function stop() {\r\n        endTime = now();\r\n        period = now() - startTime;\r\n        return period;\r\n    }\r\n    return {\r\n        get startTime() {\r\n            return startTime;\r\n        },\r\n        get endTime() {\r\n            return endTime;\r\n        },\r\n        get period() {\r\n            return period;\r\n        },\r\n        stop: stop\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src_js/timer.js\n// module id = 112\n// module chunks = 0","module.exports = require(\"cluster\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cluster\"\n// module id = 113\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 114\n// module chunks = 0","module.exports = require(\"https\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 115\n// module chunks = 0","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 116\n// module chunks = 0","module.exports = require(\"tls\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tls\"\n// module id = 117\n// module chunks = 0","module.exports = require(\"zlib\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"zlib\"\n// module id = 118\n// module chunks = 0"],"sourceRoot":""}