import { UnsubscribeFunction } from "callback-registry";

/**
 * Factory method that creates a new glue instance
 */
export default function GlueCoreFactory(config?: Glue42Core.Config, ext?: Glue42Core.Extension): Promise<Glue42Core.GlueCore>;

declare global {
    interface Window {
        htmlContainer?: HtmlContainerObject;
        glueDesktop?: GlueDesktopObject;
        glue42gd?: GDObject;
        WebSocket: any;
        XDomainRequest?: any;
    }
}

export interface GlueDesktopObject {
    version: string;
}

export interface HtmlContainerObject {
    activityFacade: {
        init: () => void;
        init2: () => void;
        getActivityTypes: () => void;
        subscribeForJoinBreakEvents?: () => void;
        unregisterActivityType: () => void;
        registerActivityType: () => void;
        getWindowTypes: () => void;
        registerWindowFactory: () => void;
        initiate: () => void;
        getActivities: () => void;
        setActivityContext: () => void;
    };
    applicationName: string;
    getFrameColors: () => string[];
    browserWindowName: string;
    containerName: string;
    containerVersion: string;
    machineName: string;
    jsAgmFacade: {
        protocolVersion: number;
        jsonValueDatePrefix: string;
        initAsync(cfg: string, success: (i: Glue42Core.AGM.Instance) => void, error: (err: string) => void): void;
        init(cfg: string): Glue42Core.AGM.Instance;

        register(method: string, handler: ((args: string, caller: Glue42Core.AGM.Instance) => string) | ((args: object, caller: Glue42Core.AGM.Instance) => void | object), returnAsJson?: boolean): void;
        registerAsync(method: object, callback: (args: any, instance: Glue42Core.AGM.Instance, tracker: any) => void): void;

        unregister(name: string): void;

        invoke(method: string, args: string, target: string, options: string, success: (result: any) => void, error: (err: string) => void): void;
        invoke2(method: string, args: string, target: string, options: string, success: (result: any) => void, error: (err: string) => void): void;

        methodAdded(callback: (method: Glue42Core.AGM.MethodDefinition) => void): void;
        methodRemoved(callback: (method: Glue42Core.AGM.MethodDefinition) => void): void;

        serverAdded(callback: (server: Glue42Core.AGM.Instance) => void): void;
        serverRemoved(callback: (server: Glue42Core.AGM.Instance) => void): void;

        serverMethodAdded(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.MethodDefinition }) => void): void;
        serverMethodRemoved(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.MethodDefinition }) => void): void;

        methodsForInstance(instance: string): string;

        servers(filter?: string): string;
        methods(filter?: string): string;

        subscribe2(name: string, params: string, success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: string) => void): void;

        createStream2(methodDefinition: string,
            subscriptionRequestHandler: (request: Glue42Core.AGM.SubscriptionRequest) => void,
            subscriptionAddedHandler: (request: Glue42Core.AGM.StreamSubscription) => void,
            subscriptionRemovedHandler: (request: Glue42Core.AGM.StreamSubscription) => void,
            success: (stream: Glue42Core.AGM.Stream) => void,
            error: (err: string) => void): void;
    };
    metricsFacade: {
        done: () => void;
        getIdentity: () => {
            system: string;
            service: string;
            instance: string;
        };
        send(type: string, message: string | object): void;
    };
    loggingFacade: {
        send(type: string, message: string | object): void;
    };
    monitors: Array<{
        height: number;
        isPrimary: boolean;
        left: number;
        name: string;
        scale: number;
        scaleX: number;
        scaleY: number;
        top: number;
        width: number;
        workingAreaHeight: number;
        workingAreaLeft: number;
        workingAreaTop: number;
        workingAreaWidth: number;
    }>;
    pID: string;
    perfDataNeeded: boolean;
    perfDataDelay?: number;
    updatePerfData: (perf: object) => void;
    sharedContextFacade: {
        all: () => void;
        set: () => void;
        setContext: () => void;
        subscribe: () => void;
        unsubscribe: () => void;
        update: () => void;
        updateContext: () => void;
    };
    windowId: string;
    windowStyleAttributes: string;
    getContext: () => object;
}

export interface GDObject {
    /** Id of the window */
    windowId: string;
    /** Name of the application running in the window */
    appName: string;
    /** Instance of the application running in the window */
    appInstanceId: string;
    gwURL: string;
    pid: number;
    getGWToken(): Promise<string>;
    activityInfo: {
        activityId: string;
        activityType: string;
        windowType: string;
        windowName: string;
        gwToken: string;
        isOwner: boolean;
    }
    getWindowInfo(id: string): {
        applicationName: string;
        activityId?: string;
        activityWindowId?: string;
    },
    updatePerfData: (perf: object) => void
}


export interface GlueDesktopObject {
    version: string;
}

export interface HtmlContainerObject {
    activityFacade: {
        init: () => void;
        init2: () => void;
        getActivityTypes: () => void;
        subscribeForJoinBreakEvents?: () => void;
        unregisterActivityType: () => void;
        registerActivityType: () => void;
        getWindowTypes: () => void;
        registerWindowFactory: () => void;
        initiate: () => void;
        getActivities: () => void;
        setActivityContext: () => void;
    };
    applicationName: string;
    getFrameColors: () => string[];
    browserWindowName: string;
    containerName: string;
    containerVersion: string;
    machineName: string;
    jsAgmFacade: {
        protocolVersion: number;
        jsonValueDatePrefix: string;
        initAsync(cfg: string, success: (i: Glue42Core.AGM.Instance) => void, error: (err: string) => void): void;
        init(cfg: string): Glue42Core.AGM.Instance;

        register(method: string, handler: ((args: string, caller: Glue42Core.AGM.Instance) => string) | ((args: object, caller: Glue42Core.AGM.Instance) => void | object), returnAsJson?: boolean): void;
        registerAsync(method: object, callback: (args: any, instance: Glue42Core.AGM.Instance, tracker: any) => void): void;

        unregister(name: string): void;

        invoke(method: string, args: string, target: string, options: string, success: (result: any) => void, error: (err: string) => void): void;
        invoke2(method: string, args: string, target: string, options: string, success: (result: any) => void, error: (err: string) => void): void;

        methodAdded(callback: (method: Glue42Core.AGM.MethodDefinition) => void): void;
        methodRemoved(callback: (method: Glue42Core.AGM.MethodDefinition) => void): void;

        serverAdded(callback: (server: Glue42Core.AGM.Instance) => void): void;
        serverRemoved(callback: (server: Glue42Core.AGM.Instance) => void): void;

        serverMethodAdded(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.MethodDefinition }) => void): void;
        serverMethodRemoved(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.MethodDefinition }) => void): void;

        methodsForInstance(instance: string): string;

        servers(filter?: string): string;
        methods(filter?: string): string;

        subscribe2(name: string, params: string, success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: string) => void): void;

        createStream2(methodDefinition: string,
            subscriptionRequestHandler: (request: Glue42Core.AGM.SubscriptionRequest) => void,
            subscriptionAddedHandler: (request: Glue42Core.AGM.StreamSubscription) => void,
            subscriptionRemovedHandler: (request: Glue42Core.AGM.StreamSubscription) => void,
            success: (stream: Glue42Core.AGM.Stream) => void,
            error: (err: string) => void): void;
    };
    metricsFacade: {
        done: () => void;
        getIdentity: () => {
            system: string;
            service: string;
            instance: string;
        };
        send(type: string, message: string | object): void;
    };
    loggingFacade: {
        send(type: string, message: string | object): void;
    };
    monitors: Array<{
        height: number;
        isPrimary: boolean;
        left: number;
        name: string;
        scale: number;
        scaleX: number;
        scaleY: number;
        top: number;
        width: number;
        workingAreaHeight: number;
        workingAreaLeft: number;
        workingAreaTop: number;
        workingAreaWidth: number;
    }>;
    pID: string;
    perfDataNeeded: boolean;
    perfDataDelay?: number;
    updatePerfData: (perf: object) => void;
    sharedContextFacade: {
        all: () => void;
        set: () => void;
        setContext: () => void;
        subscribe: () => void;
        unsubscribe: () => void;
        update: () => void;
        updateContext: () => void;
    };
    windowId: string;
    windowStyleAttributes: string;
    getContext: () => object;
}

export interface GDObject {
    /** Id of the window */
    windowId: string;
    /** Name of the application running in the window */
    appName: string;
    /** Instance of the application running in the window */
    appInstanceId: string;
    gwURL: string;
    pid: number;
    getGWToken(): Promise<string>;
    activityInfo: {
        activityId: string;
        activityType: string;
        windowType: string;
        windowName: string;
        gwToken: string;
        isOwner: boolean;
    }
    getWindowInfo(id: string): {
        applicationName: string;
        activityId?: string;
        activityWindowId?: string;
    }
}

export namespace Glue42Core {

    /**
     * An object used to configure glue
     */
    export interface Config {
        /**
         * Application name. If not specified the value depends on the hosting environment:
         *  - in browser - document.title + random number (e.g., ClientList321333)
         *  - in HC - containerName + browserWindowName (e.g., Internal.ClientList)
         */
        application?: string;

        /** Configurations for GW connection */
        gateway?: {
            /** Url for the WebSocket connections to the gateway */
            ws?: string;

            /** Url for the http connections to the gateway */
            http?: string;

            /** Version of the gateway that you’re connection to. Possible values are: 1, 2, 3 */
            protocolVersion?: number;

            /**
             * Reconnect interval in milliseconds.
             * Default is 500.
             */
            reconnectInterval?: number;

            /**
             * Number of reconnect attempts.
             * Default is 10.
             */
            reconnectAttempts?: number;

            /** A way to pass custom token provider for gateway V3 tokens */
            gwTokenProvider?: {
                get: () => string;
            };

            /**
             * Connect to a gateway running in the same process (you can spin off one by using tick42-gateway package)
             * Works only if protocolVersion is 3
             */
            inproc?: {
                /** Token returned when starting gateway from tick42-gateway package */
                token: {};

                /** Facade object - this is the default export of tick42-gateway */
                facade: Glue42Core.Connection.GW3Facade;
            };

            /**
             * if protocolVersion == 3, used to create the connection's replayer
             * property; allows out-of-band subscription and replaying of Glue
             * messages
             */
            replaySpecs?: Glue42Core.Connection.MessageReplaySpec[];

            /** If true (default false) will always connect to GW, no matter what env the app runs in */
            force?: boolean;

        };

        /** Contains metrics configurations */
        metrics?: boolean | {
            /**
             * Metrics system, if not specified defaults to:
             * - browser - ‘Browser’
             * - HC - 'HtmlContainer’ + container_name
             */
            system: string;

            /**
             * Metrics service, if not specified defaults to:
             * - browser - document.title || 'unknown’
             * - HC - 'JS.’ + browser_window_name
             */
            service: string;

            /**
             * Metrics instance, if not specified defaults to:
             * - browser - ’~’ + random_number
             * - HC - ’~’ + machine_name
             */
            instance: string;
        };

        agm?: boolean;

        bus?: boolean;

        /** Defines logger levels per output target */
        logger?: {
            /** Console log level */
            console: string;
            /** File log level */
            publish: string;
            /** Metrics log level */
            metrics: string;
        }

        /**
          * Authentication can use one of the following flows:
          * * username/password
          * * token - access tokens can be generated after successful login from the Auth Provider (e.g Auth0)
          * * gatewayToken - gateway tokens are one off, time limited tokens generated from GW after explicit request. To generate one use `glue.connection.authToken()` method
          */
        auth?: {
            /** Username to be used */
            username?: string;

            /** Password to be used */
            password?: string;

            /** Authenticate using token generated from the auth provider. */
            token?: string;

            /** Authenticate using gatewayToken */
            gatewayToken?: string;
        } | string | number;
    }

    export interface Extension {
        /* Array of libs to be injected to glue - use only in libraries that wrap glue-core*/
        libs?: ExternalLib[];

        /* Allow to override version - use only in libraries that wrap glue-core **/
        version?: string;

        /* Allow wrappers to enrich glue object **/
        enrichGlue?: (glue: GlueCore) => void;

        /* Extension options object that will be merged to the config object of glue core **/
        extOptions?: any;
    }

    export interface ExternalLib {
        name: string;
        create: (core: GlueCore) => GlueInnerLib;
    }

    /**
     * Authentication can use one of the following flows:
     * * username/password
     * * token - access tokens can be generated after successful login from the Auth Provider (e.g Auth0)
     * * gatewayToken - gateway tokens are one off, time limited tokens generated from GW after explicit request. To generate one use `glue.connection.authToken()` method
     */
    export interface Auth {
        /** Username to be used */
        username?: string;

        /** Password to be used */
        password?: string;

        /**
         * Authenticate using token generated from the auth provider.
         */
        token?: string;

        /**
         * Authenticate using gatewayToken
         */
        gatewayToken?: string;
    }

    export interface GlueCore {
        /** Connection */
        connection?: Glue42Core.Connection.API;

        /** Logger library */
        logger?: Glue42Core.Logger.API;

        /** Agm library */
        agm?: Glue42Core.AGM.API;

        /** Bus library */
        bus?: Glue42Core.Bus.API;

        /** Metrics library */
        metrics?: Glue42Core.Metrics.API;

        /** Contexts library */
        contexts?: Glue42Core.Contexts.API;

        /** Brings up GD feedback dialog */
        feedback: () => void;

        /** Info object containing versions of all included libs and glue itself */
        info: object;

        /** Glue version */
        version: string;

        /**
         * @ignore
         * Performance data
         */
        performance?: object;

        /**
         * @ignore
         * Config as passed from the user
         */
        userConfig: Config;

        /**
         * @ignore
         * The config used by the library. This is a transformed and possibly extended version of the userConfig object
         */
        config?: any;

        /**
         * Shutdowns glue. This will remove all Interop methods and streams registered by the application
         */
        done(): Promise<void>;
    }

    /** @ignore */
    export interface GlueInnerLib {
        version?: string;
        ready?: () => Promise<any>;
        initTime?: number;
        initStartTime?: number;
        initEndTime?: number;
    }

    export interface LoggerConfig {
        /** Console log level */
        console: string;
        /** File log level */
        publish: string;
        /** Metrics log level */
        metrics: string;
    }

    /**
     * @docmenuorder 2
     * @docName Interop
     * @intro
     * The Interop API enables applications to:
     *
     * - **offer functionality** to other applications (JavaScript **and** native executables) by **registering** AGM methods
     * - **discover applications which offer methods**
     * - **invoke** (call) methods on the user's desktop and across the network
     * - **stream and subscribe to real-time data** using the streaming API.
     *
     * We call applications which offer methods and streams *AGM servers*, and applications which consume them *AGM clients*, and collectively - **AGM instances**.
     *
     * **ACE-enabled** aka **GLUE-enabled** aka **AGM-enabled** aka **Connected** application is simply one which offers functionality to or consumes from other applications using AGM methods (or Activities which we'll cover later).
     *
     * Each AGM application is identified by its **AGM instance**, which is a set of known key/value pairs uniquely identifying an application. Here's an example from the Client Portfolio application:
     *
     * |Key|Example|Description|
     * |---|-------|-----------|
     * |application|clientportfolio_0|application name|
     * |environment|TRAINING|e.g. DEV, SIT, UAT, PROD|
     * |machine|WINBOOKPRO|
     * |pid|2864|process ID|
     * |region|TICK42|e.g. EMEA, NA, APAC|
     * |service|null|namespace with a region and environment|
     * |user|Stoyan|currently logged on user|
     *
     * ## See also
     * - [Interop Documentation](../../../../agm/)
     */
    export namespace AGM {
        /**
         * @ignore
         */
        export interface Settings {
            connection: Connection.API;
            logger: Logger.API;
            instance: any;
            /** Default for how much to wait for method to appear when invoking. If not set 3000 */
            waitTimeoutMs?: number;
            /** Default for how much to wait of the method to respond when invoking. If not set 3000 */
            methodResponseTimeout?: number;
            /** If set will use AGM through GW  */
            forceGW?: boolean;
            gdVersion: number;
        }

        /**
         * @docmenuorder 1
         */
        export interface API extends GlueInnerLib {
            /** Instance of the current application */
            instance: Instance;
            /** Registers a new agm method */
            register(name: string | MethodDefinition, handler: (args: object, caller: Instance) => object | void): void;
            /**
             * Registers a new async agm method. Async methods can delay returning the result
             * for method invocation.
             */
            registerAsync(name: string | MethodDefinition, handler: (args: object, caller: Instance, successCallback: (args?: object) => void, errorCallback: (error?: string | object) => void) => void): void;
            /** Un-register agm method */
            unregister(definition: string | MethodDefinition): void;
            /**
             * Invokes an AGM method with some arguments on target servers.
             * @example
             * ```javascript
             * glue.agm.invoke(
             *   'Sum',
             *   { a: 37, b: 5 }) // everything else is optional
             *   .then(function(result) {
             *      console.log('37 + 5 = ' + result.returned.answer)
             *   })
             *   .catch(function(err) {
             *      console.error('Failed to execute Sum' + err.message)
             *   })
             * ```
             */
            invoke(method: string | MethodDefinition, argumentObj?: object, target?: string | Instance | Instance[], options?: InvokeOptions, success?: InvokeSuccessHandler<any>, error?: InvokeErrorHandler): Promise<InvocationResult<any>>;
            /**
             * Invokes an AGM method with some arguments on target servers.
             * @example
             * ```javascript
             * glue.agm.invoke(
             *   'Sum',
             *   { a: 37, b: 5 }) // everything else is optional
             *   .then(function(result) {
             *      console.log('37 + 5 = ' + result.returned.answer)
             *   })
             *   .catch(function(err) {
             *      console.error('Failed to execute Sum' + err.message)
             *   })
             * ```
             */
            invoke<T>(method: string | MethodDefinition, argumentObj?: object, target?: string | Instance | Instance[], options?: InvokeOptions, success?: InvokeSuccessHandler<T>, error?: InvokeErrorHandler): Promise<InvocationResult<T>>;
            /** Creates a new event stream */
            createStream(methodDefinition: string | MethodDefinition, options?: StreamOptions, successCallback?: (args?: object) => void, errorCallback?: (error?: string | object) => void): Promise<Stream>;
            /** Subscribes to a stream */
            subscribe(methodDefinition: string | MethodDefinition, parameters?: SubscriptionParams): Promise<Subscription>;
            /**
             * Returns all agm aware applications.
             * Optionally the list can be filtered to servers that provide some method
             * by specifying a methodFilter
             */
            servers(filter?: MethodFilter): Instance[];
            /**
             * Returns all methods that match the given filter.
             * If no filter specified returns all methods.
             */
            methods(filter?: MethodFilter): MethodDefinition[];
            /** Subscribe for events when a method is added for the first time by any application */
            methodAdded(callback: (method: MethodDefinition) => void): UnsubscribeFunction;
            /** Subscribe for events when a method is removed from the last application offering it */
            methodRemoved(callback: (method: MethodDefinition) => void): UnsubscribeFunction;
            /** Subscribe for events when an application offering methods (server) is discovered */
            serverAdded(callback: (server: Instance) => void): UnsubscribeFunction;
            /** Subscribe for events when an application no longer offers AGM methods */
            serverRemoved(callback: (server: Instance) => void): UnsubscribeFunction;
            /**
             * Subscribe for events when a method is offered by an application. This will be called for each server offering the method
             * where {@link methodAdded} will be called only for the first time the method is registered.
             */
            serverMethodAdded(callback: (info: {
                server: Instance;
                method: MethodDefinition;
            }) => void): UnsubscribeFunction;
            /** Subscribe for events when a server stops offering some method */
            serverMethodRemoved(callback: (info: {
                server: Instance;
                method: MethodDefinition;
            }) => void): UnsubscribeFunction;
            /** Returns all agm methods registered by some server */
            methodsForInstance(server: Instance): MethodDefinition[];
        }
        export interface SubscriptionParams {
            waitTimeoutMs?: number;
            target?: string | Instance | Instance[];
            arguments?: object;
            methodResponseTimeout?: number;
        }
        /** Request for subscription - it can be accepted or rejected */
        export interface SubscriptionRequest {
            /** Instance of the application that wants to subscribe to the stream */
            instance: Instance;
            /** Arguments passed with the subscription request */
            arguments: object;
            /** Accept the request */
            accept(): void;
            /** Accept the request on some branch */
            acceptOnBranch(branchKey: string): void;
            /** Reject the request */
            reject(reason: string): void;
        }
        /** Different handlers that can be supplied when creating streams */
        export interface StreamOptions {
            /**
             * Subscribe for subscription requests. These can be accepted, rejected or accepted on custom branch.
             * If this handler is attached each request should be explicitly accepted.
             */
            subscriptionRequestHandler?: (request: SubscriptionRequest) => void;
            /** Subscribe for subscription added events */
            subscriptionAddedHandler?: (request: StreamSubscription) => void;
            /** Subscribe for subscription removed events */
            subscriptionRemovedHandler?: (request: StreamSubscription) => void;
        }
        export interface Stream {
            /** Stream definition object */
            definition: MethodDefinition;
            /** Name of the stream */
            name: string;
            /** Push data to the stream. If branches argument is passed data will be sent to those branches only */
            push(data: object, branches?: string | string[]): void;
            /**
             * Returns the list of available branches.
             * If key is specified returns the corresponding branch or null
             */
            branches(key?: string): StreamBranch[] | StreamBranch;
            /** Returns a list of active subscriptions to the stream */
            subscriptions(): StreamSubscription[];
            /** Close the stream. This will close all subscriptions */
            close(): void;
        }
        /** Branch of stream create by our application */
        export interface StreamBranch {
            /** Branch key */
            key: string;
            /** All subscriptions to that branch */
            subscriptions(): StreamSubscription[];
            /** Close the branch */
            close(): void;
            /** Push data to this branch only */
            push(data: object): void;
        }
        /** Subscription to a stream registered by our application */
        export interface StreamSubscription {
            /** Arguments used to subscribe to the stream */
            arguments: object;
            /** The key of the subscription's branch */
            branchKey: string;
            /** Instance of the subscriber */
            instance: Instance;
            /** The stream this subscription is for */
            stream: Stream;
            /** Close the subscription (this will not close the stream) */
            close(): void;
            /** Push data to this subscription only */
            push(data: object): void;
        }
        /** Stream subscription opened by our application */
        export interface Subscription {
            /** Arguments that were used to open the subscription */
            requestArguments: object;
            /** Instance of the application providing the stream */
            serverInstance: Instance;
            /** Stream definition */
            stream: MethodDefinition;
            /** Subscribe for data events */
            onData(callback: (data: StreamData) => void): void;
            /** Subscribe for subscription close event */
            onClosed(callback: () => void): void;
            /** Subscribe for subscription failed event */
            onFailed(callback: (err: any) => void): void;
            /** Closes the subscription */
            close(): void;
        }
        /** Stream data received by the subscriber */
        export interface StreamData {
            /** Data from the stream */
            data: object;
            /** Instance of the application publishing the stream */
            server: Instance;
            /** Arguments that were used to open the subscription */
            requestArguments: object;
            /** Message from the publisher of the stream */
            message: string;
            /** If true the data is targeted to us only */
            private: boolean;
        }
        /** Object describing an AGM method registered by some application */
        export interface MethodDefinition {
            name: string;
            objectTypes?: string[];
            displayName?: string;
            accepts?: string;
            returns?: string;
            description?: string;
            version?: number;
            /** True if the method is a stream */
            supportsStreaming?: boolean;
            /** Returns all servers that provide the method */
            getServers?: () => Instance[];
        }
        /** Object describing a filter matching one or more AGM methods */
        export interface MethodFilter {
            name?: string;
            objectTypes?: string[];
            displayName?: string;
            accepts?: string;
            returns?: string;
            description?: string;
        }
        /** Each AGM application is identified by its AGM instance, which is a set of known key/value pairs. */
        export interface Instance {
            /** Application name */
            application?: string;
            /** Process id of the instance */
            pid?: number;
            /** Machine name of the instance */
            machine?: string;
            /** Username */
            user?: string;
            /** Environment in which the application runs */
            environment?: string;
            /** Region in which the application runs */
            region?: string;
            /** Service string of the application */
            service?: string;
            /** (GD3 only) Instance - unique string identifying the application */
            instance?: string;
            /** (GD3 only) GD windowId of the instance - only set if running in GD hosted window */
            windowId?: string;
            /** (GD3 only) Gateway peer id of the instance */
            peerId?: string;
            /** Returns all methods registered by that instance */
            getMethods?(): MethodDefinition[];
            /** Returns all streams registered by that instance */
            getStreams?(): MethodDefinition[];
        }
        export interface InvokeOptions {
            waitTimeoutMs?: number;
            methodResponseTimeoutMs?: number;
        }
        /** Result from an invocation */
        export interface InvocationResult<T> {
            /** Returned object */
            returned: T;
            /** Method that was invoked */
            method: MethodDefinition;
            /** Instance of the application that executed the method */
            executed_by: Instance;
            /** Arguments of the invocation */
            called_with: object;
            /** In case of results from multiple servers this will hold array of InvokeResults */
            all_return_values?: Array<InvocationResult<T>>;
            /** In case of results from multiple servers this will hold array of InvokeResults */
            all_errors?: object[];
            /** Message from the application that executed the method */
            message: string;
            /** Status from the application that executed the method */
            status: number;
        }
        export type InvokeSuccessHandler<T> = (result: InvocationResult<T>) => void;
        export type InvokeErrorHandler = (error: {
            method: MethodDefinition;
            called_with: object;
            executed_by: Instance;
            message: string;
            status: number;
            returned: object;
        }) => void;
    }

    /**
     * @docmenuorder 10
     * @intro
     * GLUE Gateway allows applications to communicate with each other remotely. It can be running on the user desktop or in the cloud.
     *
     * The Gateway Connection module is used to provide connectivity between GLUE for JavaScript modules (agm, metrics, etc) and GLUE Gateway.
     *
     * Applications can use different events (connected, disconnected) to show connectivity status.
     */
    export namespace Connection {
        /**
         * Settings used to initialize connection library
         *
         * @ignore
         */
        export interface Settings {
            identity?: Identity;
            logger?: Logger.API;
            protocolVersion?: number;
            ws?: string;
            http?: string;
            httpInterval?: number;
            /** If connection is lost, try reconnecting on some interval */
            reconnectInterval?: number;
            /** If connection is lost, how many times to try */
            reconnectAttempts?: number;
            /**
             * Use this to initialize with gateway object.
             * The connection will use that object as inproc transport to GW.
             * This will only work if protocolVersion is 3 otherwise will be ignored
             */
            gw?: {
                token: object;
                facade: GW3Facade;
            };
            force?: boolean;
            replaySpecs?: MessageReplaySpec[];
            gdVersion?: number;
        }
        /** @ignore */
        export interface AuthRequest {
            token?: string;
            gatewayToken?: string;
            username?: string;
            password?: string;
        }
        /** @ignore */
        export interface Identity {
            application: string;
            instance?: string;
            region?: string;
            environment?: string;
            machine?: string;
            process?: number;
            system?: string;
            service?: string;
            user?: string;
            windowId?: string;
        }
        /**
         * Connection to Gateway
         */
        export interface API extends GlueInnerLib {
            /**
             * Protocol version of the current connection.
             */
            protocolVersion: number;
            /**
             * Send a new message using the connection
             *
             * @ignore
             */
            send(product: string, type: string, message: object, id?: string, options?: SendMessageOptions): Promise<void>;
            /**
             * Subscribe for messages. Returns an object that can be used to unsubscribe
             *
             * @ignore
             */
            on(product: string, type: string, messageHandler: (msg: object) => void): {
                type: string;
                id: number;
            };
            /**
             * Cancel subscription for message types
             *
             * @ignore
             */
            off(info: {
                type: string;
                id: number;
            }): void;
            /** @ignore */
            login(message: AuthRequest): Promise<Identity>;
            /** @ignore */
            logout(): void;
            /**
             * Subscribe for event raised when the connection managed to login(only for connections that support authentication)
             *
             */
            loggedIn(callback: (() => void)): () => void;
            /**
             * Subscribe for connected events
             */
            connected(callback: (server: string) => void): () => void;
            /**
             * Subscribe for disconnected events
             */
            disconnected(callback: () => void): () => void;
        }
        /**
         * GW3 connection - adds GW3 specific info and domain session abstraction
         *
         * @ignore
         */
        export interface GW3Connection extends API {
            peerId: string;
            token: string;
            info: object;
            resolvedIdentity: object;
            availableDomains: object[];
            gatewayToken: string;
            replayer: MessageReplayer;
            /**
             * Creates a domain wrapper used to handles domain session lifetime and events for a given connection/domain pair
             */
            domain(domain: string, logger?: Logger.API, successMessages?: string[], errorMessages?: string[]): GW3DomainSession;
            /**
             * Generates a new token that can be passed to another application and used to authenticate as the same user.
             * The token is one off and has time restricted validity.
             * The returned token can be then used when initializing glue:
             *
             * ```javascript
             * Glue({
             *  gateway: {
             *    gatewayToken: token
             *  }
             * })
             * ```
             */
            authToken(): Promise<string>;
        }
        /**
         * GW3 domain session
         *
         * @ignore
         */
        export interface GW3DomainSession {
            peerId: string;
            domain: string;
            /**
             * Joins the domain.
             */
            join(options?: object): Promise<object>;
            /**
             * Leaves the domain.
             */
            leave(): void;
            /**
             * Subscribe for join events (for the specific domain).
             * The wasReconnect flag indicates if this is auto join after connection drop
             */
            onJoined(callback: (wasReconnect: boolean) => void): any;
            /**
             * Subscribe for leave events (for the specific domain).
             */
            onLeft(callback: () => void): any;
            /**
             * Send a message to GW.
             * A promise that is resolved when a success result for the is received or rejected if the GW returns an error
             */
            send(msg: object, tag?: object, options?: SendMessageOptions): Promise<object>;
            /**
             * Use this to send a message to GW if you don't care about the result.
             * You may pass requestId or it will be generated internally
             */
            sendFireAndForget(msg: {
                request_id?: string;
                [key: string]: any;
            }): void;
            /**
             * Subscribe for messages from GW
             */
            on(type: string, callback: (msg: object) => void): void;
            loggedIn(callback: (() => void)): void;
            connected(callback: (server: string) => void): void;
            disconnected(callback: () => void): void;
        }
        /**
         * GW3 facade that allows working with the gateway directly inproc
         * This is exposed from tick42-gateway package
         *
         * @ignore
         */
        export interface GW3Facade {
            connect(gw: object, handler: (msg: object) => void): object;
            send(token: object, msg: object): void;
        }
        /** @ignore */
        export interface SendMessageOptions {
            skipPeerId?: boolean;
            retryInterval?: number;
            maxRetries?: number;
        }

        /**
        * Allows out-of-band subscription to GW messages in protocolVersion 3
        */
        export interface MessageReplaySpec {
            /**
             * used to identify a set of message types
             * e.g. 'context' for ['create-context', 'subscribe-context', 'subscribed-context' ...]
             */
            name: string;

            /**
             * types of messages corresponding to this name
             */
            types: string[];
        }

        export interface MessageReplayer {
            init(connection: Connection.API): void;

            processMessage(type: string, msg: object): void;

            drain(name: string, callback: (msg: object) => void): void;
        }
    }

    /**
     * @docmenuorder 9
     * @intro
     * The Tick42 Logging API enables JavaScript applications:
     *
     * - to create a **hierarchy of sub-loggers** mapped to application components, where you can control the level of logging of each component
     * - to **route** the output of log messages (depending on the logging level) to a variety of targets:
     * 	- the developer console
     * 	- external output - usually a rolling file on the desktop but really any target log4net supports
     * 	- Metrics
     * 	- GNS
     *
     * The last three targets give the developer or support person the ability to:
     *
     * - connect to a remote desktop and **pull the application's log files** using the **AGM Support Tool**
     * - connect on the Metrics bus and **monitor the application in real-time** using the **Metrics Viewer**, or record log messages routed to Metrics in a Cassandra database for later analysis
     * - **raise notifications on the desktop** which can be displayed as toasts
     */
    export namespace Logger {
        /** @ignore */
        export interface Identity {
            instance: string;
            service: string;
            system: string;
        }

        /**
         * Configuration object from Logging library
         * @ignore
         */
        export interface Settings {
            identity: Identity;
            getConnection: () => Connection.API;
            publish: string;
            console: string;
            metrics: string;
        }

        export interface API {
            /** Name of the logger */
            name: string;

            /** Version of the logging API */
            version?: string;

            /** Create a new logger, which is a sublogger of the current one */
            subLogger(name: string): Logger.API;

            /** Set or get the current threshold level for publishing to file */
            publishLevel(level?: string): string;

            /** Set or get the current threshold level for writing to the console */
            consoleLevel(level?: string): string;

            /** Set or get the current threshold level for publishing metrics */
            metricsLevel(level?: string, metricsSystem?: Metrics.System): string;

            log(message: string, level?: string): void;
            trace(message: string): void;
            debug(message: string): void;
            info(message: string): void;
            warn(message: string): void;
            error(message: string): void;
        }
    }

    /**
     * @docmenuorder 7
     * @intro
     * Tick42 Metrics is a product consisting of:
     *
     * - a Metrics **Publishing API** (available for .NET, Java, JavaScript and C++), which enables applications to report their health and key performance indicators
     * - a **Desktop and Web Metrics Viewer** applications which can connect to the Tick42 message bus and discover and display all applications publishing metrics
     * - a **Subscription API** (Java and .NET) which enables developers to write their own analytic tools or custom Metrics viewers
     * - a **Metrics Republisher** application, which can be configured to take a sub-set of the most important metrics published on the desktop and re-publish these to a data centre; this can also publish information about all processes running on an user's desktop; on the data centre end it can re-publish Metrics to various targets such as Geneos or Splunk
     * - a **Metrics Sumary** application, which can aggregate certain metrics and republish the aggregated values; it also can be configured to monitor and publish KPIs for all processes running on the desktop
     * - a **Metrics Recorder** which can record all or a sub-set of the published Metrics to a Cassandra database for later analysis
     * - a **Cassandra Metrics DB Web Viewer** which can look at and export the recorded metrics as a CSV
     *
     * All Tick42 products and components publish Metrics, including any JavaScript application (by simply including GLUE), regardless of whether the JS apps publish their own metrics or not.
     *
     * The Metrics JavaScript API allows JavaScript applications to publish metrics.
     *
    * ## See also
     * - [Metrics Documentation](../../../../metrics/)
     */
    export namespace Metrics {
        /** @docmenuorder 1 */

        export interface API extends System, GlueInnerLib {
            /**
             * The feature metric in under the subSystem with the name "reporting". This metric is different, published in TickByTick mode.
             * @param name
             * @param action
             * @param payload
             *
             * @example
             * ```javascript
             * glue.metrics.featureMetric('export', 'exportToExcel', 'file.xls')
             * ```
             */
            featureMetric(name: string, action: string, payload: string): void;
        }

        /**
         * Library configuration
         * @ignore
         */
        export interface Settings {
            identity: Identity;
            connection: Connection.API;
            logger: Logger.API;
            heartbeatInterval?: number;
            /** If true will auto create click stream metrics in root system */
            clickStream?: boolean;
        }

        export interface Identity {
            instance: string;
            service: string;
            system: string;
        }

        export interface Repository {
            /** Returns the identity of the system */
            identity: Identity;

            /** Returns the instance of the system */
            instance: string;

            /** Returns the root of the metrics API */
            root: System;
        }

        export interface System {

            /** Returns the name of the system */
            name: string;

            /** Returns the description of the system */
            description: string;

            /** Returns the repository of the system */
            repo: Repository;

            /** Returns the parent system of the current system */
            parent: System;

            path: string[];

            id: string;

            identity: Identity;

            /** The root system in the repository */
            root: System;

            /** Returns array of the subsystem */
            subSystems: System[];

            /** Returns array of the metrics */
            metrics: Metric[];

            /** Create a new subsystem */
            subSystem(name: string, description?: string): System;

            getState(): State;

            /** Update a state of the metric */
            setState(state: number, description?: string): void;

            getAggregateState(): SystemStateInfo[];

            /** Create a new addressMetric */
            addressMetric(definition: string | MetricDefinition, value: any): AddressMetric;

            /** Create a new countMetric */
            countMetric(definition: string | MetricDefinition, value: number): CountMetric;

            /** Create a new numberMetric */
            numberMetric(definition: string | MetricDefinition, value: number): NumberMetric;

            /** Create a new objectMetric */
            objectMetric(definition: string | MetricDefinition, value: any): ObjectMetric;

            /** Create a new rateMetric */
            rateMetric(definition: string | MetricDefinition, value: any): RateMetric;

            /** Create a new statiticsMetric */
            statisticsMetric(definition: string | MetricDefinition, value: any): StatisticsMetric;

            /** Create a new stringMetric */
            stringMetric(definition: string | MetricDefinition, value: string): StringMetric;

            /** Create a new timespanMetric */
            timespanMetric(definition: string | MetricDefinition, value: any): TimespanMetric;

            /** Create a new timestampMetric */
            timestampMetric(definition: string | MetricDefinition, value: any): TimestampMetric;
        }

        export const enum ConflationMode {
            Sampled = 0,
            TickByTick = 1
        }

        export interface State {
            state?: number;
            description?: string;
        }

        export interface MetricDefinition {
            name?: string;
            description?: string;
            period?: string;
            resolution?: string;
            conflation?: ConflationMode;
        }

        export interface Metric {

            /** Returns the name of the metric */
            name: string;

            /** Returns the description of the metric */
            description: string;

            period: string;

            /** Returns the resolution of the metric */
            resolution: string;

            /** Returns the system of the metric */
            system: System;

            /** Returns the repository of the metric */
            repo: Repository;

            /** Returns the id of the metric */
            id: string;

            /** Returns the type of the metric */
            type: number;

            /** Returns array of the path */
            path: string[];

            conflation: ConflationMode;

            value: any;

            /** Update the value of the metric */
            update(value: any): void;

            getValueType(): void;
        }

        export interface AddressMetric extends Metric {

            /** Returns the value of the metric */
            value: any;
        }

        export interface CountMetric extends Metric {

            /** Returns the value of the metric */
            value: number;

            /** Update the value of the metric */
            update(value: number): void;

            /** Increment the value of the metric by */
            incrementBy(num: number): void;

            /** Increment the value of the metric by +1 */
            increment(): void;

            /** Decrement the value of the metric by -1 */
            decrement(): void;

            /** Decrement the value of the metric by */
            decrementBy(num: number): void;
        }

        export interface NumberMetric extends Metric {

            /** Returns the value of the metric */
            value: number;

            /** Update the value of the metric */
            update(value: number): void;

            /** Increment the value of the metric by (value + number) */
            incrementBy(num: number): void;

            /** Increment the value of the metric by (value + 1) */
            increment(): void;

            /**  Decrement the value of the metric by (value - 1) */
            decrement(): void;

            /** Decrement the value of the metric by (number * -1) */
            decrementBy(num: number): void;
        }

        export interface ObjectMetric extends Metric {

            /** Returns the value of the metric */
            value: any;

            /** Update the value of the metric */
            update(value: any): void;
        }

        export interface RateMetric extends Metric {

            /** Returns the value of the metric */
            value: number;

            /** Update the value of the metric */
            update(value: number): void;
        }

        export interface StatisticsMetric extends Metric {

            /** Returns the value of the metric */
            value: any;

            /** Update the value of the metric */
            update(value: number): void;
        }

        export interface StringMetric extends Metric {

            /** Returns the value of the metric */
            value: string;

            /** Update the value of the metric */
            update(value: string): void;
        }

        export interface TimespanMetric extends Metric {

            /** Returns the value of the metric */
            value: any;

            /** Update the value of the metric */
            update(value: string): void;

            /** Start the metric */
            start(): void;

            /** Stop the metric */
            stop(): void;
        }

        export interface TimestampMetric extends Metric {

            /** Returns the value of the metric */
            value: any;

            /** Update the value of the metric */
            update(value: string): void;

            /** Update metric by the current date and time */
            now(): void;

        }

        export interface SystemStateInfo extends State {
            name?: string;
            path?: string[];
        }
    }

    /**
     * @docmenuorder 8
     * @intro
     * A module that deals with contexts. Context is a pair of name and value, where the values is a simple object.
     *
     * An example for context would be the common applications theme settings that define the style of all running applications.
     * This data is meant to be used by different applications.
     *
     * ## See also
     * - [Shared Contexts Documentation](../../../../contexts/)
     */
    export namespace Contexts {
        export interface API extends GlueInnerLib {
            /**
             * Returns all known contexts names. Using context name you can subscribe for changes, update or set context value
             */
            all(): string[];

            /**
             * Updates a context with some object. The object properties will replace the context properties, any other
             * context properties will remain in the context. If the context does not exists the update call will create it.
             *
             * @example
             * ```javascript
             * // if theme does not exists creates a context called theme with initial value
             * glue.contexts.update("theme", {font:10, "font-family":"Arial"})
             *
             * // increases font to 11, after that call context is { font:10, font-family:"Arial"}
             * glue.contexts.update("theme", {font:11})
             * ```
             * @param name Name of the context to be updated
             * @param data The object that will be applied to the context
             */
            update(name: string, data: any): Promise<void>;

            /**
             * Replaces a context
             * @param name Name of the context to be updated
             * @param data The object that will be applied to the context
             */
            set(name: string, data: any): Promise<void>;

            /**
             * Subscribe for context events
             * @param name name of the context to subscribe for
             * @param callback function that will receive updates.
             * @returns Function execute the returned function to unsubscribe
             */
            subscribe(name: string, callback: (data: any, delta: any, removed: string[], unsubscribe: () => void) => void): Promise<() => void>;
        }

        /** @ignore */
        export interface ContextsConfig {
            connection: Glue42Core.Connection.API;

            logger: Glue42Core.Logger.API;

            gdMajorVersion: number;
        }

        export interface ContextDelta {
            added: { [index: string]: any };

            updated: { [index: string]: any };

            removed: string[];

            reset: { [index: string]: any };
        }

        export type ContextName = string;
        export type ContextSubscriptionKey = number;

    }

     /**
     * @docName Bus
     * @intro
     * The Pub/Sub API enables applications to:
     *
     * - publish messages on a topic
     * - subscribe for messages on a topic
     *
     * ## See also
     * - [Pub/Sub Documentation](../../../../bus/)
     */
    export namespace Bus {
        export interface API extends GlueInnerLib {
            /**
             * Publish the provided data on a specific topic on the message bus. 
             * Optional options object can be provided to publish a message to specific peers.
             * 
             * @example
             * ```javascript
             * glue.bus.publish('prices', { RIC: 'VOD.L', price: 21.2 })      
             * ```
             */
            publish(
                topic: string,
                data: object,
                options?: MessageOptions
            ): void

            /**
             * Subscribe for receiving data published on specific topic on the message bus. The provided callback will be invoked for each received message.
             * Optional options object can be provided to receive messages published only by specific peers.
             * 
             * Returns a promise which resolves when the subscription is successful. The promise resolves with a subscription object which can be used to unsubscribe and stop receiving messages.
             * 
             * @example
             * ```javascript
             * glue.bus.subscribe(
             *   'prices',
             *   function (data, topic, source) {
             *      console.log(data, topic, source)
             *   })
             * ```
             */
            subscribe(
                topic: string,
                callback: (data: object, topic: string, source: object) => void,
                options?: MessageOptions
            ): Promise<Subscription>
        }

        /**
         * If routingKey is provided when publishing a message, then the message will be delivered only to peers that have provided the same routing key during subscription or no routing key at all. 
         * If routingKey is provided when subscribing for a topic, then only messages that have been published with a matching routing key or no routing key at all will be received by the subscriber.
         * If target is provided when publishing a message, then the message will be delivered only to subscribers for which all properties of target object match the respective fields on the subscribers identity.
         * If target is provided when subscribing for a topic, the provided object will be compared to the identity of the publishers of the messages and only when those match, the messages will be received by the subscriber.
         */
        export interface MessageOptions {
            routingKey?: string,
            target?: object
        }

        /**
         * Subscription object that can be used to unsubscribe from a topic and stop receiving data.
         */
        export interface Subscription {
            unsubscribe: () => Promise<void>
        }

        export interface Settings {
            connection: Connection.API;
            logger: Logger.API;
        }
    }
}

declare module 'glue42core' {
    export = Glue42Core;
}
